[
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html",
    "title": "In Class Exercise 5",
    "section": "",
    "text": "This exercise will help reinforce our learning from Hands on exercise 5. Additionally, we explore the sfdep package and its uses."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#performing-relational-join",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#performing-relational-join",
    "title": "In Class Exercise 5",
    "section": "5.3.1 Performing relational join",
    "text": "5.3.1 Performing relational join\nWe will update the attribute table of Hunan’s SpatialPolygonsDataFrame with the attribute fields of the hunan2012 data-frame. We can do this by using the left_join() function of the dplyr package.\n\nhunan_GDPPC &lt;- left_join(hunan,hunan2012) %&gt;%\n  select(1:4, 7, 15)\n\n\n5.3.1.2 Plotting a Choropleth map\n\ntmap_mode('plot')\ntm_shape(hunan_GDPPC)+\n  tm_fill('GDPPC', style='quantile', palette = 'Blues', title= 'GDPPC')"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#deriving-queens-contiguity-weights-sfdep-methods",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#deriving-queens-contiguity-weights-sfdep-methods",
    "title": "In Class Exercise 5",
    "section": "5.4.1 Deriving Queens Contiguity Weights: sfdep methods",
    "text": "5.4.1 Deriving Queens Contiguity Weights: sfdep methods\n\nwm_q=hunan_GDPPC%&gt;%\n  mutate(nb=st_contiguity(geometry),\n         wt=st_weights(nb,\n                       style='W'),\n         .before=1)\n\n\nnb: A neighbor list object as created by st_neighbor.\nstyle: Default ‘W’ for row standardized weights. This value can also be ‘B’, ‘C’, ‘U’, ‘minimax’, and ‘S’\nallow_zero: if TRUE, assigns zero as a lagged value to zone without neighbors."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#computing-global-morans-i",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#computing-global-morans-i",
    "title": "In Class Exercise 5",
    "section": "5.4.2 Computing Global Moran’s I",
    "text": "5.4.2 Computing Global Moran’s I\nWe use the global_moran() function to compute this.\n\nmoranI= global_moran(wm_q$GDPPC,\n                     wm_q$nb,\n                     wm_q$wt)\n\nThe below code chunk, using global_moran_test() helps us conduct the test easier.\n\nglobal_moran_test(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt)\n\n\n    Moran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nSince p-value is less than 0.05, we infer that there is indeed a sign of positive autocorrelation."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#global-morans-permutation-test",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#global-morans-permutation-test",
    "title": "In Class Exercise 5",
    "section": "5.4.3 Global Moran’s Permutation Test",
    "text": "5.4.3 Global Moran’s Permutation Test\nIn practice, we generally use Monte Carlo simulation to conduct tests. This is where the global_moran_perm() function comes into play. The nsim argument is key.\n\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value &lt; 2.2e-16\nalternative hypothesis: two.sided"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#computing-local-morans-i",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#computing-local-morans-i",
    "title": "In Class Exercise 5",
    "section": "5.4.4 Computing Local Moran’s I",
    "text": "5.4.4 Computing Local Moran’s I\nIn this section, we use the local_moran() function of the sfdep package.\n\nlisa=wm_q%&gt;%\n  mutate(local_moran=local_moran(\n    GDPPC, nb, wt, nsim=99),\n    .before=1)%&gt;%\n  unnest(local_moran)\n\nunnest() helps us combine the data into the intended data-frame."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-p-value-of-local-morans-i",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-p-value-of-local-morans-i",
    "title": "In Class Exercise 5",
    "section": "5.4.5 Visualizing p-value of local Moran’s I",
    "text": "5.4.5 Visualizing p-value of local Moran’s I\n\ntmap_mode('plot')\ntm_shape(lisa)+\n  tm_fill('p_ii_sim')+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title = 'p-value of Local Morans I',\n            main.title.size = 2)\n\n\n\n\n\n\n\n\n\n5.4.5.1 Visualizing Local Moran’s I\n\ntm_shape(lisa)+\n  tm_fill('ii')+\n  tm_borders(alpha=0.5)+\n  tm_view(set.zoom.limits = c(6,8))+\n  tm_layout(main.title='Local Morans I of GDPPC',\n            main.title.size = 2)\n\n\n\n\n\n\n\n\n\n\n5.4.5.2 Visualizing both\n\nmap1= tm_shape(lisa)+\n  tm_fill('p_ii_sim')+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title = 'p-value of Local Morans I',\n            main.title.size = 2)\n\nmap2= tm_shape(lisa)+\n  tm_fill('ii')+\n  tm_borders(alpha=0.5)+\n  tm_view(set.zoom.limits = c(6,8))+\n  tm_layout(main.title='Local Morans I of GDPPC',\n            main.title.size = 2)\n\ntmap_arrange(map1,map2, ncol=2)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-lisa-map",
    "href": "In-class_Ex/In-class_Ex5/In-class_Ex5.html#visualizing-lisa-map",
    "title": "In Class Exercise 5",
    "section": "5.4.6 Visualizing LISA map",
    "text": "5.4.6 Visualizing LISA map\nLISA map is a categorical map showing outliers and clusters. There are two types of outliers- high-low and low-high outliers. Likewise, there are two types of clusters namely High-High and Low-Low.\nIn fact, LISA map is an interpreted map by combining local Moran’s I of geographical areas and their respective p values.\n\nlisa_sig=lisa%&gt;%\n  filter(p_ii&lt;0.05)\ntmap_mode('plot')\ntm_shape(lisa)+\n  tm_polygons()+\n  tm_borders(alpha=0.5)+\n  tm_shape(lisa_sig)+\n  tm_fill('mean')+\n  tm_borders(alpha=0.4)\n\n\n\n\n\n\n\n\nWe see two outliers in the cluster on the North-East region of Hunan which contains mostly high-high regions. rm -f .git/index.lock"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS626-GAA",
    "section": "",
    "text": "Introduction\nWelcome to my journey through ISSS626 Geospatial Analytics. This website contains my coursework that were completed through this course.\n\n\n\nAbout\nMy name is Arjun Singh and I am a student at Singapore Management University pursuing a Masters degree in Analytics. This website documents my journey of learning Geospatial Analytics under the guidance of Professor Tin Seong Kam.\nIf you have any inquiries, feel free to reach out to me at arjun.singh.2023@smu.edu.sg\n“It is a rough road that leads to the heights of greatness.”- Seneca"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html",
    "title": "Take Home Exercise 1",
    "section": "",
    "text": "According to the World Health Organisation (WHO), road traffic accidents cause approximately 1.19 million deaths annually and result in between 20 and 50 million people with being down with non-fatal injuries. Over half of all road traffic deaths occur among vulnerable road users, such as pedestrians, cyclists and motorcyclists.\nRoad traffic injuries are the leading cause of death for children and young adults aged 5–29 while two-thirds of road traffic fatalities occur among people of working age (18–59 years). 9 in 10 fatalities on the roads occur in low and middle-income countries, even though these countries have only around 60% of the world’s vehicles.\nIn addition to the human suffering caused by road traffic injuries, they also inflict a heavy economic burden on victims and their families, both through treatment costs for the injured and through loss of productivity of those killed or disabled. More broadly, road traffic injuries have a serious impact on national economies, costing countries 3% of their annual GDP.\nThailand’s roads are the deadliest in Southeast Asia and among the worst in the world, according to the World Health Organisation. About 20,000 people die in road accidents each year, or about 56 deaths a day (WHO).\nBetween 2014 and 2021, Thailand experienced a notable increase in accidents. Specifically, 19% of all accidents in Thailand occurred on the national highways, which constituted the primary public thoroughfares connecting various regions, provinces, districts, and significant locations within a comprehensive network.\nWithin the broader context of accidents across the country, there existed a considerable 66% likelihood of encountering accident-prone zones, often termed ‘black spots,’ distributed as follows: 66% on straight road segments, 13% at curves, 6% at median points of cross-shaped intersections, 5% at T-shaped intersections and Y-shaped intersections, 3% at cross-shaped intersections, 2% on bridges, and 2% on steep slopes, respectively."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#aspatial-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#aspatial-data",
    "title": "Take Home Exercise 1",
    "section": "1.2.1 Aspatial Data",
    "text": "1.2.1 Aspatial Data\nWe first import in the data-frame contained data of all accidents in the Bangkok Metropolitan Region. For this, we implement the read_rds() function as shown in the code chunk below.\n\nrdacc_sf=read_rds(\"data/rds/acc_sf\")%&gt;% \n  mutate(hourofday= hour(incident_datetime))%&gt;%\n  mutate(traffic_period = case_when(\n    # Define peak hours: 7-9 AM and 4-7 PM (16-19 in 24-hour format)\n    hourofday &gt;= 7 & hourofday &lt;= 9 ~ \"Peak\",\n    hourofday &gt;= 16 & hourofday &lt;= 19 ~ \"Peak\",\n    TRUE ~ \"Off-Peak\"  # Everything else is off-peak\n  ))\nst_crs(rdacc_sf)\n\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#geospatial-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#geospatial-data",
    "title": "Take Home Exercise 1",
    "section": "1.2.2 Geospatial Data",
    "text": "1.2.2 Geospatial Data\nWe import the OpenStreetMap export of Thailand into our environment using the st_read() function.\n\nroad_sf &lt;- st_read(dsn = \"data/rawdata\", layer=\"hotosm_tha_roads_lines_shp\")\n\n\nIt is important to note the details shown in the output above. Most important takeaway from the above output is that there is no CRS information. This information is crucial as it informs our data preparation steps. We must ensure that the right CRS information is set in order to carry out analysis.\n\nBelow, we import the boundary data. map_sf is the boundary data at the province level (ADM1), while map2_sf is the boundary data at the district level (ADM2). We will be using both over the course of our analysis.\n\nmap_sf &lt;- st_read(dsn = \"data/rawdata\", layer=\"tha_admbnda_adm1_rtsd_20220121\")\n\nReading layer `tha_admbnda_adm1_rtsd_20220121' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\Take-home_Ex\\Take-home_Ex1\\data\\rawdata' \n  using driver `ESRI Shapefile'\nSimple feature collection with 77 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n\n\n\nmap2_sf &lt;- st_read(dsn = \"data/rawdata\", layer=\"tha_admbnda_adm2_rtsd_20220121\")\n\nReading layer `tha_admbnda_adm2_rtsd_20220121' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\Take-home_Ex\\Take-home_Ex1\\data\\rawdata' \n  using driver `ESRI Shapefile'\nSimple feature collection with 928 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n\n\nAfter importing the boundary data, we notice immediately that the EPSG code isn’t accurate. The EPSG code of Thailand is 32647 while the data-frame has an EPSG code of 4326.\nWe use the st_transform() function to convert the EPSG code to the correct value of 32647.\n\nmap_sf=st_transform(map_sf,crs = 32647)\nmap2_sf=st_transform(map2_sf,crs = 32647)\n\nGiven that the OSM data-frame has no CRS information, we will first initialize it to WGS84 using the default EPSG code of 4326 by using the st_set_crs() function of the sf package.\n\nroad_sf=st_set_crs(road_sf, 4326)\n\nWe will then implement the st_crs() function to verify if the boundary data has the accurate CRS information after we transformed it above.\n\nst_crs(map_sf)\n\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#data-preparation-and-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#data-preparation-and-wrangling",
    "title": "Take Home Exercise 1",
    "section": "1.2.3 Data Preparation and Wrangling",
    "text": "1.2.3 Data Preparation and Wrangling\nGiven our area of interest is the Bangkok Metropolitan Region, we create a list of all provinces in this area in order to facilitate filtering for our analysis.\n\nbmr_province=c(\"Bangkok\", \"Samut Prakan\", \"Samut Sakhon\", \"Nonthaburi\", \"Nakhon Pathom\", \"Pathum Thani\")\n\nBelow, we implement the filter() function in order to filter the boundary data, at the province and district level, as well as the accident data, down to our region of interest- the Bangkok Metropolitan Region.\n\nbmr_boundary=map_sf %&gt;% \n  filter(ADM1_EN %in% bmr_province)\nbmr_boundary2=map2_sf %&gt;% \n  filter(ADM1_EN %in% bmr_province)\nbmr_accsf=rdacc_sf %&gt;% \n  filter(province_en %in% bmr_province)\n\n\nst_bbox(bmr_boundary)\n\n     xmin      ymin      xmax      ymax \n 587893.5 1484413.7  712440.5 1579076.3 \n\n\nWe now implement the st_crs() function in order to transform the EPSG code of the road_sf data-frame from 4326 to 32647. This allows us to have the accurate geometry values to facilitate future spatial joins, as well as analysis.\n\n# If road_sf was originally in EPSG:4326, reproject it properly\nroad_sf &lt;- st_transform(road_sf, crs = 32647)\n\nAfter ensuring that the CRS values are consistent, we can proceed with implementing the st_intersection() function and join the two data-frames based on their geometries.\nThe st_intersection() function is applied at the province level below.\n\nbmr_roads=st_intersection(map2_sf, road_sf)\n\nAs earlier, we will save this as an RDS file in order to improve computational efficiency.\n\nwrite_rds(bmr_roads, \"data/rds/bmrroads\")\n\n\nbmr_roads=read_rds(\"data/rds/bmrroads\")\n\nBelow, the st_intersection() function is applied at the district level and saved as an RDS file.\n\nbmr_districts=st_intersection(map2_sf, bmr_roads)\nwrite_rds(\"data/rds/bmr_districts_roads\")\n\n\nbmr_districts=read_rds(\"data/rds/bmr_districts_roads\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#kernel-density-estimation-kde",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#kernel-density-estimation-kde",
    "title": "Take Home Exercise 1",
    "section": "1.4.1 Kernel Density Estimation (KDE)",
    "text": "1.4.1 Kernel Density Estimation (KDE)\nKDE will allow us to better estimate the distribution of accidents acrosss the Bangkok Metropolitan Region. Using this, we can make more informed decisions on where to focus resources on to reduce the rate of accidents across the region.\nWe start off by preparing the data for KDE.\n\n# Step 3: Define the window (bounding box) from the boundary\nboundary_bbox &lt;- bbox(boundary_sp)  # Get bounding box of boundary\nwindow &lt;- owin(xrange = boundary_bbox[1, ], yrange = boundary_bbox[2, ])  # Define window\n\n# Step 4: Extract the coordinates from the SpatialPoints object\ncoordinates &lt;- coordinates(bmracc_sp)\n\n# Step 5: Convert the SpatialPoints into a ppp object using the window\nbmracc_ppp &lt;- ppp(x = coordinates[,1], y = coordinates[,2], window = window)\n\n# Step 6: Check the structure of the resulting point pattern object\nsummary(bmracc_ppp)\n\nPlanar point pattern:  12986 points\nAverage intensity 1.101448e-06 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 10 decimal places\n\nWindow: rectangle = [587893.5, 712440.5] x [1484413.7, 1579076.3] units\n                    (124500 x 94660 units)\nWindow area = 11789900000 square units\n\n# You can now use the ppp object for spatial analysis with spatstat\n\n\nNote that you must ensure to convert the spatial objects into ppp (planar point pattern) form before proceeding with Kernel Density Estimation. The spatstat package requires data to be in this format before conducting point pattern analysis. This also improves computational efficiency.\n\n\n1.4.1.1 Dealing with Duplicates\nAfter creating the above PPP object, we check for duplicates by implementing the code chunk below.\n\nany(duplicated(bmracc_ppp))\n\n[1] TRUE\n\n\nWe check the number of duplicates in our data-frame using the code chunk below. The multiplicity() function creates a list of all duplicates after which the sum() function counts the total.\n\nsum(multiplicity(bmracc_ppp)&gt;1)\n\n[1] 2293\n\n\nThere are over 2293 duplicates. In this case, it means we have 2293 overlapping data points.\nUsing the rjitter() function, we deal with these data points by spacing them out slightly around the point. The function adds noise to the data and spreads these points out a little to facilitate visualization.\n\nbmr_ppp_jit &lt;- rjitter(bmracc_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\n\n\n1.4.1.2 Creating an owin object\nWhen analyzing Spatial Point patterns, it is a good practice to confine the boundaries of the analysis with a Geographical area, such as Singapore’s boundary. Using the spatstat package, we can create an owin object that is designed to represent such polygonal regions.\nWe use the as.owin() function as shown in the code chunk below.\n\nbmr_owin &lt;- as.owin(bmr_boundary)\n\nWe use the plot() function to verify if the owin object has been correctly created.\n\nplot(bmr_owin)\n\n\n\n\n\n\n\n\n\n\n1.4.1.3 Computing KDE using automatic bandwidth selection\nWe use the density() function of the spatstat package to compute the kernel density. These are the key configurations used in the computation:\n\nbw.diggle() automatic bandwidth selection method.\nThe smoothing kernel used in this instance is gaussian. Other smoothing methods include “epanechnikov”, “quartic”. or “disc”.\n\n\nkde_bmracc_bw &lt;- density(bmr_ppp_jit,\n                              sigma=bw.diggle,\n                              edge=TRUE,\n                            kernel=\"gaussian\") \n\n\nThe other two methods aside from bw.diggle() are bw.scott() and bw.ppl(). While bw.diggle() focuses on minimizing error in spatial density estimation for point process data and is tailor-made for spatial applications, bw.scott() (Scott’s rule) provides a rule-of-thumb bandwidth and is used in several KDE applications across different types of data besides just spatial data. bw.ppl() uses a more complex and data-driven approach (plug-in) for selecting the bandwidth, aiming to minimize the error in KDE. Like bw.diggle(), It is also tailor-made for spatial point processes, however, it takes a slightly different approach to bw.diggle()\n\nWe will now plot the above using the plot() function.\n\nplot(kde_bmracc_bw)\n\n\n\n\n\n\n\n\nImmediately we notice that the density values are very small. This is because the unit of measurement is in meter, meaning that the density values are computed with a unit of ‘number of points per square meter.’\nWe now use the rescale.ppp() function of the spatstat package to convert the unit of measurement from meter to kilometer. This is done by implementing the code chunk below.\n\nbmracc_ppp.km &lt;- rescale.ppp(bmr_ppp_jit, 1000, \"km\")\n\nAfter this, we re-deploy the density() function using the re-scaled data and plot the KDE map.\n\nkde_bmracc.bw &lt;- density(bmracc_ppp.km, \n                         sigma=bw.diggle, \n                         edge=TRUE, \n                         kernel=\"gaussian\")\nplot(kde_bmracc.bw)\n\n\n\n\n\n\n\n\n\n\n1.4.1.4 Converting the KDE output into a grid object\n\n1.4.1.4.1 Gridded raster\nWe convert the gridded kernel density objects into RasterLayer object by using raster() of the raster package.\n\nkde_bmracc_bw_raster &lt;- raster(kde_bmracc.bw)\n\nThe CRS above is NA, so we now set the CRS to EPSG 32647 of Thailand.\nAfter that, we can implement the plot() function to plot the same.\n\nprojection(kde_bmracc_bw_raster) &lt;- CRS(\"+init=EPSG:32647\")\nplot(kde_bmracc_bw_raster)\n\n\n\n\n\n\n\n\nFrom the above, we infer that the South-East region, specifically districts around the Samut Prakan province seem to have a higher density of accidents.\n\n\n\n1.4.1.4.2 Peak vs Off-Peak Hours KDE [Spatio-Temporal Analysis)\nWe now want to check for the difference in accident density for off-peak and peak hours and see if there is any difference.\nWe go through the same data preparation steps as above.\n\n#First extract target values\npeak=bmr_accsf%&gt;%filter(traffic_period=='Peak')\noff_peak=bmr_accsf%&gt;%filter(traffic_period=='Off-Peak')\n\n#Convert to Spatial objects\npeak=as_Spatial(peak)\noff_peak=as_Spatial(off_peak)\n\n# Convert to SP object\npeak_sp &lt;- as(peak, \"SpatialPoints\")\noffpeak_sp &lt;- as(off_peak, \"SpatialPoints\")\n\n# Converting to Point Planar Patterns\ncoordinates_peak &lt;- coordinates(peak_sp)\ncoordinates_offpeak&lt;- coordinates(offpeak_sp)\npeak_ppp &lt;- ppp(x = coordinates_peak[,1], y = coordinates_peak[,2], window = window)\noffpeak_ppp&lt;- ppp(x= coordinates_offpeak[,1], y= coordinates_offpeak[,2], window=window)\n\n# Deal with Duplicates\npeak_ppp_jit &lt;- rjitter(peak_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\noffpeak_ppp_jit &lt;- rjitter(offpeak_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\nWe can now carry out Kernel Density Estimation using the density() function. We will first rescale the values using the rescale.ppp() function as shown in the code chunk below.\n\n#Rescale PPP to facilitate understanding\npeak_ppp.km &lt;- rescale.ppp(peak_ppp_jit, 1000, \"km\")\noffpeak_ppp.km &lt;- rescale.ppp(offpeak_ppp_jit, 1000, \"km\")\n\nNow, we apply KDE.\n\nPeakOff Peak\n\n\n\nkde_peak.bw &lt;- density(peak_ppp.km, \n                         sigma=bw.diggle, \n                         edge=TRUE, \n                         kernel=\"gaussian\")\nplot(kde_peak.bw)\n\n\n\n\n\n\n\n\n\n\n\nkde_offpeak.bw &lt;- density(offpeak_ppp.km, \n                         sigma=bw.diggle, \n                         edge=TRUE, \n                         kernel=\"gaussian\")\nplot(kde_offpeak.bw)\n\n\n\n\n\n\n\n\n\n\n\nWe do a slight difference in densities especially across the highway leading from Samut Prakan into Bangkok then into Patum Thani, where there is a higher density of accidents in the off-peak hours. This can be further analyzed to determine exact hours of high volumes to develop policies."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#network-kernel-density-estimation-nkde",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#network-kernel-density-estimation-nkde",
    "title": "Take Home Exercise 1",
    "section": "1.4.1.5 Network Kernel Density Estimation (NKDE)",
    "text": "1.4.1.5 Network Kernel Density Estimation (NKDE)\nBy completing Kernel Density Estimation, we have identified two provinces of interest, Bangkok and Samut Prakan.\nWe will first extract our target regions using the code chunk below.\n\nsmt_prk_boundary= bmr_boundary2%&gt;%\n  filter(ADM1_EN=='Samut Prakan')\nsmt_prk_roads= bmr_roads%&gt;%\n  filter(ADM1_EN=='Samut Prakan')\n\n\n# We now extract the three districts with the highest number of accidents in Bangkok\nbkk_boundary= bmr_boundary2%&gt;%\n  filter(ADM2_EN %in% c(\"Lat Krabang\", \"Saphan Sung\", \"Khan Na Yao\"))\nbkk_roads= bmr_districts%&gt;%\n  filter(ADM2_EN %in% c(\"Lat Krabang\", \"Saphan Sung\", \"Khan Na Yao\"))\n\nWe will now join the OpenStreetMap data, smt_prk_roads and bkk_roads, using st_intersection function of the sf package.\n\n#Samut Prakan\nsmt_pkn_roads_intersection=st_intersection(smt_prk_roads, smt_prk_boundary)\n\n\n# Bangkok Districts\nbkk_roads_intersection=st_intersection(bkk_roads, bkk_boundary)\n\nWe will now filter down our accident data, bmr_accsf, down to our target regions.\n\n#Samut Prakan\nsmt_pkn_acc=bmr_accsf%&gt;%\n  filter(province_en=='Samut Prakan')\n\n\n#Bangkok Districts\nbkk_acc=bmr_accsf%&gt;%\n  filter(province_en=='Bangkok')\ndistrict_accidents=st_intersection(bkk_acc, bkk_boundary)\n\nWe can now start with Network Kernel Density Estimation.\nWe must first cut the SpatialLines object into Lixels by implementing the lixelize_lines() function with a specified minimal distance.\n\n# We first ensure that the geometries are in the right format for lixelization.\nsmt_pkn_roads_intersection=st_cast(smt_pkn_roads_intersection, 'LINESTRING', group_or_split= TRUE)\nsamut_prakan_lines=st_cast(smt_pkn_roads_intersection,'LINESTRING')\nlixels_smt_pkn &lt;- lixelize_lines(smt_pkn_roads_intersection, \n                         10000, \n                         mindist = 5000)\n\n\n# Filter out POINT geometries\nbkk_roads_lines &lt;- bkk_roads_intersection[st_is(bkk_roads_intersection, c(\"LINESTRING\", \"MULTILINESTRING\")), ]\n\n# Cast MULTILINESTRING to LINESTRING\nbkk_roads_linestring &lt;- st_cast(bkk_roads_lines, \"LINESTRING\", group_or_split = TRUE)\n\n# Create Lixels\nlixels_bkk &lt;- lixelize_lines(bkk_roads_linestring, \n                         10000, \n                         mindist = 5000)\n\n\nThere is another function, lixelize_lines.mc() that provides multicore support and is typically used in spatial analysis or geospatial data processing, specifically in contexts where large datasets of lines (such as roads, paths, or boundaries) need to be broken down into smaller, equally spaced segments or “lixels” (line pixels). This process is known as “lixelization.”\nThe main purpose of the lixelize_lines.mc() function is to improve the efficiency of the lixelization process by utilizing multiple CPU cores simultaneously. This is particularly beneficial when dealing with large datasets, as processing each line sequentially can be time-consuming.\n\nWe now proceed to generate a SpatialPointsDataFrame with line centre points using the lines_center() function of spNetwork.\n\nsamples_smt_pkn &lt;- lines_center(lixels_smt_pkn) \n\n\nsamples_bkk &lt;- lines_center(lixels_bkk)\n\nNow, we can perform NKDE. We use the nkde() function to carry it out.\n\n# Samut Prakan NKDE\ndensities_smt_prk &lt;- nkde(lixels_smt_pkn, \n                  events = smt_pkn_acc,\n                  w = rep(1, nrow(smt_pkn_acc)),\n                  samples = samples_smt_pkn,\n                  kernel_name = \"quartic\",\n                  bw = 1000, \n                  method = \"simple\")\n\n\nwrite_rds(densities_smt_prk, \"data/rds/density_samut\")\n\n\ndensities_smt_prk=read_rds('data/rds/density_samut')\n\n\n# Perform NKDE for Bangkok Districts\ndensities_bkk &lt;- nkde(\n  lines = lixels_bkk    ,               # Road network\n  events = district_accidents,      # Subset of accident data (for testing)\n  w = rep(1,nrow(district_accidents)),                # Weights (equal for all events)\n  samples = samples_bkk,           # Sample points along the road network\n  kernel_name = \"quartic\",         # Kernel type (quartic kernel)\n  bw = 500, # Bandwidth (smoothing parameter)\n  div = 'bw',\n  method = \"simple\",               # Simple method for NKDE,\n  verbose = TRUE\n  )          # Spatial grid resolution (lower for faster computation)                   \nwrite_rds(densities_bkk, 'data/rds/density_bkk')\n\n\ndensities_bkk=read_rds('data/rds/density_bkk')\n\n\n\nThe kernel_name argument specifies the type of kernel function used.\nPossible kernel methods supported by spNetwork include:\n\nQuartic\nTriangle\nGaussian\nScaled Gaussian\nTricube\nCosine\nTriweight\nEpanechnikov\nUniform\n\nThe method argument indicates the method used to calculate Network Kernel Density Estimation (NKDE).\nspNetwork supports three popular methods:\n\nSimple (method = \"simple\"):\n\nIntroduced by Xie et al. (2008).\nDistances between events and sampling points are replaced by network distances.\nThe kernel formula is adapted to calculate density over a linear unit instead of an areal unit.\n\nDiscontinuous (method = \"discontinuous\"):\n\nProposed by Okabe et al. (2008).\nDivides the mass density of an event at intersections of lixels.\nResults in a discontinuous kernel function.\n\nContinuous (method = \"continuous\"):\n\nAlso proposed by Okabe et al. (2008).\nAdjusts the density before intersections to create a continuous kernel function.\nStill divides the mass of the density at intersections but with a continuous adjustment.\n\n\n\n\nWe will now visualize NKDE.\nWe must first insert the computed density values into samples and lixels objects as the density field.\n\n#Samut Prakan\nsamples_smt_pkn$density&lt;- densities_smt_prk\nlixels_smt_pkn$density &lt;- densities_smt_prk\n\n\n#Bangkok Districts\nsamples_bkk$density&lt;- densities_bkk\nlixels_bkk$density &lt;- densities_bkk\n\nWe now upscale the density for both in the interest of easier understanding.\n\n#Samut Prakan\nsamples_smt_pkn$density &lt;- samples_smt_pkn$density*1000\nlixels_smt_pkn$density &lt;- lixels_smt_pkn$density*1000\n\n\n#Bangkok Districts\nsamples_bkk$density &lt;- samples_bkk$density*1000\nlixels_bkk$density &lt;- lixels_bkk$density*1000\n\nWe can now plot the map as the data is now prepared.\nWe will use the tmap package to produce a highly cartographic and interactive map.\n\n#Samut Prakan\ntmap_mode('plot')\ntm_shape(lixels_smt_pkn)+\n  tm_lines(col=\"density\")+\ntm_shape(smt_pkn_acc)+\n  tm_dots()\n\n\n\n\n\n\n\n\nThe interactive map above effectively reveals road segments with relatively higher density of accidents than road segments with relatively lower density of accidents with the help of shading. The roads with darker shades have a relatively higher density.\n\n#Bangkok Districts\ntmap_mode('plot')\ntm_shape(lixels_bkk)+\n  tm_lines(col=\"density\")\n\n\n\n\n\n\n\n\nWe see a highway on the North West side, across roads such as Kanchanapishek Road, of the three districts have a particularly high density of accidents on it after examining the plots above. This can be further investigated in order to develop policies and improve roads in those specific regions.\nFrom all our analysis, we take away that the south-eastern part of Bangkok Metropolitan Region was a hotspot, and this map above allows us to further understand the distribution of accidents across the region.\n\n1.4.1.5.1 Network Constrained G- and K-Function Analysis\nWe will now conduct a test for Complete Spatial Randomness by using the kfunctions() function of the spNetwork package.\nThe hypotheses are as follows:\n\nHo: The observed spatial point events (i.e distribution of accidents) are uniformly distributed over a street network in Samut Prakan.\nH1: The observed spatial point events (i.e: distribution of accidents) are not uniformly distributed over a street network in Samut Prakan.\n\n\n# Samut Prakan\nkfun_accidents &lt;- kfunctions(smt_pkn_roads_intersection, \n                             smt_pkn_acc,\n                             start = 0, \n                             end = 1000, \n                             step = 50, \n                             width = 50, \n                             nsim = 50, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05,\n                             agg = 1)  # Set aggregation to merge close points\n\n\nwrite_rds(kfun_accidents, \"data/rds/kfunction\")\n\n\nkfun_accidents=read_rds('data/rds/kfunction')\n\nWe now do the same for the selected Bangkok Districts.\n\n# Manually snap points with a larger tolerance\nsnapped_points &lt;- st_snap(district_accidents, bkk_roads_linestring, tolerance = 100)\n\n# Now run kfunctions on the snapped points\nkfun_accidents_bkk &lt;- kfunctions(\n  bkk_roads_linestring, \n  snapped_points,\n  start = 0, \n  end = 1000, \n  step = 50, \n  width = 50, \n  nsim = 50, \n  resolution = 50,\n  verbose = FALSE, \n  conf_int = 0.05,\n  agg = 500  # Reasonable aggregation value\n)\n\nwrite_rds(kfun_accidents_bkk, 'data/rds/kfunction_bkk')\n\n\nkfun_accidents_bkk=read_rds('data/rds/kfunction_bkk')\n\n\nBelow are the arguments of the function above:\n\nlines: A SpatialLinesDataFrame containing the sampling points. The geometries must be valid; using invalid geometries may cause the process to crash.\npoints: A SpatialPointsDataFrame representing the points on the network. These points will be snapped to the network for analysis.\nstart: A numeric value indicating the starting point for evaluating the k and g functions.\nend: A numeric value specifying the endpoint for evaluating the k and g functions.\nstep: A numeric value that determines the interval between evaluations of the k and g functions.\nwidth: The width of each “donut” or ring used in calculating the g-function.\nnsim: An integer representing the number of Monte Carlo simulations to perform. In the example above, 50 simulations were conducted; however, more simulations are often necessary for accurate inference.\nresolution: Specifies the resolution when simulating random points on the network. A higher resolution can significantly reduce calculation time. If set to NULL, random points can occur anywhere on the network. If a value is provided, the network’s edges are divided according to this resolution, and random points are selected from the vertices of the newly segmented network.\nconf_int: A numeric value indicating the confidence interval width, with the default set to 0.05.\n\n\nThe k-function will output the following:\n\nplotk, a ggplot2 object representing the values of the k-function.\nplotg, a ggplot2 object representing the values of the g-function.\nvalues, a DataFrame with the values used to build the plots.\n\nBelow, we visualize the plots generated.\nWe start with Samut Prakan.\n\nPlot KPlot G\n\n\n\nkfun_accidents$plotk\n\n\n\n\n\n\n\n\nBased on the plot above, we can see the the blue line are entirely above the envelope at the bottom, indicating that we do indeed have sufficient evidence to reject the null hypothesis and conclude that the distribution of accidents across Samut Prakan do exhibit spatial clustering tendencies.\n\n\n\nkfun_accidents$plotg\n\n\n\n\n\n\n\n\nBased on the plot above, we can see that the blue line is entirely above the envelope at the bottom, similar to the k plot, indicating that we do indeed have sufficient evidence to reject the null hypothesis and conclude that the distribution of accidents across Samut Prakan do exhibit Spatial Clustering tendencies.\n\n\n\nWe will now plot the K and G plot for the selected Bangkok Districts.\n\nK PlotG Function\n\n\n\nplot(kfun_accidents_bkk$plotk)\n\n\n\n\n\n\n\n\n\n\n\nplot(kfun_accidents_bkk$plotg)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#second-order-spatial-point-pattern-analysis.",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#second-order-spatial-point-pattern-analysis.",
    "title": "Take Home Exercise 1",
    "section": "1.4.2 Second-Order Spatial Point Pattern Analysis.",
    "text": "1.4.2 Second-Order Spatial Point Pattern Analysis.\nWe now focus on Second Order Spatial Point Patterns Analysis.\nWe first filter the data down to the regions of interest and create separate boundaries for each of them. Following this, we produce an owin object using the as.owin() function.\n\n# Filtering the data down to the regions of interest\nbkk = bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Bangkok\")\nsmt_pkn = bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Samut Prakan\")\nntbr = bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Nonthaburi\")\nnkn_ptn= bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Nakhon Pathom\")\nsmt_skn= bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Samut Sakhon\")\nptm_thn= bmr_boundary%&gt;%\n  filter(ADM1_EN=='Pathum Thani')\n\n# Creating the owin object\nbkk_owin = as.owin(bkk)\nsmt_pkn_owin = as.owin(smt_pkn)\nntbr_owin = as.owin(ntbr)\nnkn_ptn_owin = as.owin(nkn_ptn)\nsmt_skn_owin = as.owin(smt_skn)\nptm_thn_owin= as.owin(ptm_thn)\n\n#Creating point planar patterns\nacc_bkk_ppp = bmr_ppp_jit[bkk_owin]\nacc_smt_pkn_ppp = bmr_ppp_jit[smt_pkn_owin]\nacc_ntbr_ppp = bmr_ppp_jit[ntbr_owin]\nacc_nkn_ptn_ppp = bmr_ppp_jit[nkn_ptn_owin]\nacc_smt_skn_ppp= bmr_ppp_jit[smt_skn_owin]\nacc_ptm_thn_ppp= bmr_ppp_jit[ptm_thn_owin]\n\n\n1.4.2.1 Calculating G-function estimates and testing for Complete Spatial Randomness\nWe now focus on computing G-function estimates.\nThe test below allows us to understand if accidents in the Bangkok Metropolitan Region exhibit Spatial Clustering or if they are Randomly Distributed.\nWe apply the test for Complete Spatial Randomness to each region individually. The tests are conducted at a 5% significance level.\nThe hypotheses are as follows.\n\nH0: There is no spatial clustering. The accidents are randomly distributed across the region.\nH1: There is spatial clustering. The accidents are NOT randomly distributed across the region.\n\n\nBangkokSamut PrakhanNonthaburiNakhon PathomSamut SakhonPatum Thani\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Bangkok. Following that, we plot the result.\n\nG_bkk = Gest(acc_bkk_ppp, correction = \"border\")\nplot(G_bkk, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now carry out the monte carlo simulation test, using the envelope() function, for complete spatial randomness.\n\nG_bkk.csr &lt;- envelope(acc_bkk_ppp, Gest, nsim = 99)\n\nGenerating 99 simulations of CSR  ...\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, \n99.\n\nDone.\n\n\n\nplot(G_bkk.csr)\n\n\n\n\n\n\n\n\nIt is clear that that there is clustering exhibited in this scenario as the black line, observed values, is far above the envelope. We have sufficient evidence to reject the null hypothesis.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Samut Prakhan. Following that, we plot the result.\n\nG_smt_pkn = Gest(acc_smt_pkn_ppp, correction = \"border\")\nplot(G_smt_pkn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now implement a monte carlo simulation test, using the envelope() function, for Complete Spatial Random in Samut Prakan.\n\nG_smt_pkn.csr &lt;- envelope(acc_smt_pkn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_smt_pkn.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Samut Prakan do indeed exhibit clustering, more so than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Nonthaburi. Following that, we plot the result.\n\nG_ntbr = Gest(acc_ntbr_ppp, correction = \"border\")\nplot(G_ntbr, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now implement a Monte-Carlo Simulation test, using the envelope() function, to check for complete spatial randomness of roads accidents in Nonthaburi.\n\nG_ntbr.csr &lt;- envelope(acc_ntbr_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_ntbr.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Nonthaburi do indeed exhibit clustering, more than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Nakhon Pathom. Following that, we plot the result.\n\nG_nkn_ptn = Gest(acc_nkn_ptn_ppp, correction = \"border\")\nplot(G_nkn_ptn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte-Carlo Simulation test, using the envelope() function, for complete spatial randomness for accidents in Nakhon Pathom.\n\nG_nkn_ptn.csr &lt;- envelope(acc_nkn_ptn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_nkn_ptn.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Nakhon Pathom do indeed exhibit clustering, more than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Samut Sakhon. Following that, we plot the result.\n\nG_smt_skn = Gest(acc_smt_skn_ppp, correction = \"border\")\nplot(G_smt_skn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte-Carlo Simulation test, using the envelope() function, for complete spatial randomness for accidents in Samut Sakhon.\n\nG_smt_skn.csr &lt;- envelope(acc_smt_skn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_smt_skn.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Samut Sakhon do indeed exhibit clustering, more so than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the Spatstat package to compute a G-function estimation for Patum Thani\n\nG_ptm_thn = Gest(acc_ptm_thn_ppp, correction = \"border\")\nplot(G_nkn_ptn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte Carlo Simulation Test for Complete Spatial Randomness by implementing the envelope() function.\n\nG_ptm_thn.csr &lt;- envelope(acc_ptm_thn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_ptm_thn.csr)\n\n\n\n\n\n\n\n\nWe have sufficient Evidence to reject the null hypothesis and can conclude that accidents in Pathum Thani are not randomly distributed and do indeed exhibit spatial clustering.\n\n\n\n\n\nThe grey zone indicates the confidence envelop (In this case, we have set it as 95% as indicated by the critical value of 0.05)\nWhen an observed L value is greater than its corresponding L(theo) value for a particular distance and lower than the upper confidence envelop, spatial clustering for that distance is statistically NOT significant (e.g. distance between B and C).\nWhen an observed L value is smaller than its corresponding L(theo) value for a particular distance and beyond the lower confidence envelop, spatial dispersion for that distance is statistically significant. - When an observed L value is smaller than its corresponding L(theo) value for a particular distance and within the lower confidence envelop, spatial dispersion for that distance is statistically NOT significant (e.g. distance between A and B).\n\n\n\n1.4.2.2 Clark and Evans Test\nWe now perform the Clark-Evans test of Aggregation for a spatial point pattern by using the clarkevans.test() function of spatstat.\nThe Clark and Evans is a method used to analyze the spatial distribution of points in selected areas of interest. It allows us to understand whether a point pattern is Random, Clustered or Regularly Spaced by comparing the observed nearest-neighbor distances between points to the expected distances under a random distribution.\nThe hypotheses that we will be testing are as follows:\nHo = The distribution of accidents are randomly distributed.\nH1= The distribution of accidents are not randomly distributed.\nThe tests will be conducted at a 5% significance level.\n\nBangkokSamut PrakhanSamut SakhonNonthaburiNakhon PathomPatum Thani\n\n\n\nclarkevans.test(acc_bkk_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_bkk_ppp\nR = 0.17748, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_smt_pkn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_smt_pkn_ppp\nR = 0.19392, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_smt_skn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_smt_skn_ppp\nR = 0.27252, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_ntbr_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_ntbr_ppp\nR = 0.41864, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_nkn_ptn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_nkn_ptn_ppp\nR = 0.30788, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_ptm_thn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_ptm_thn_ppp\nR = 0.27399, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nFrom the above outputs, we are able to reject the null hypothesis given the observed p-value is less than 0.05. We have sufficient evidence and can conclude that the distribution of accidents across the Bangkok Metropolitan Region are not randomly distributed and do indeed exhibit spatial clustering.\n\nThe R value is an important part of the output.\n\nWhen R=1, it means there is random spatial distribution.\nWhen R&gt;1 It means that there is Regularly Spaced Spatial Distribution\nWhen R&lt;1, it means that there is Clustered Spatial Distribution."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-weights",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-weights",
    "title": "Take Home Exercise 1",
    "section": "1.4.3 Spatial Weights",
    "text": "1.4.3 Spatial Weights\nWe now create a data-frame, boundary_with_accident_count, in order to assign Spatial Weights and carry out further analysis.\nWe start off by conducting a spatial join with the help of the st_join() function of the sf package to join bmr_accsf, accident data of the Bangkok Metropolitan Region.\nWe then use the left_join() function of the dplyr package to join this with the boundary data in order to facilitate analysis.\nWe then save it as an RDS file.\n\naccidents_with_districts &lt;- st_join(bmr_accsf, bmr_boundary2, join = st_intersects)\n# Group by adm2_en and count the number of accidents per district\naccident_counts_by_adm2 &lt;- accidents_with_districts %&gt;%\n  group_by(ADM2_EN) %&gt;%\n  summarise(accident_count = n())\n\n# Perform a left join with the boundary data\nboundary_with_accident_count &lt;- bmr_boundary2 %&gt;%\n  st_join(accident_counts_by_adm2, by = \"ADM2_EN\")\nboundary_with_accident_count &lt;- boundary_with_accident_count %&gt;%\n  mutate(accident_count = ifelse(is.na(accident_count), 0, accident_count))\nwrite_rds(boundary_with_accident_count, \"data/rds/boundary_with_acc_count\")\n\n\nboundary_with_accident_count=read_rds(\"data/rds/boundary_with_acc_count\")\n\nAfter successfully completing the relational join, we can now plot a choropleth map to visualize the number of accidents in the Bangkok Metropolitan Region using various functions of the tmap package\n\nbasemap &lt;- tm_shape(boundary_with_accident_count) +\n  tm_polygons() +\n  tm_text(\"ADM2_EN.x\", size=0.5)\ngdppc &lt;- qtm(boundary_with_accident_count, \"accident_count\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\nThe above map reinforces our earlier finding that the Eastern/South-Eastern region of the Bangkok Metropolitan Region have the most accidents. One district in the bottom left, part of the Samut Sakhon province, also has a high volume of accidents.\n\n1.4.3.1 Computing Contiguity Spatial Weights\nWe now implement the poly2nb() function of the spdep package to compute contiguity weight matrices for the study area selected.\nUsing this function, we are able to build a ‘neighbors list’ based on regions with contiguous boundaries.\nIn this function, we will pass an argument, ‘queen’, that can be set as either TRUE (default) or FALSE. If the ‘queen’ argument is not explicitly set to FALSE, the function returns a list of first order neighbors using the Queen criteria.\nYou may refer to the spdep package documentation here to learn more about its functions and arguments.\n\n1.4.3.1.1 Computing (QUEEN) contiguity based neighbors\nThe poly2nb() function is implemented as shown in the code chunk below. Using this, we are able to compute a Queen contiguity weight matrix.\n\nwm_q &lt;- poly2nb(boundary_with_accident_count, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 1  5 10 24 20 12  6  1 \n1 least connected region:\n66 with 2 links\n1 most connected region:\n30 with 9 links\n\n\nThe most connected area has 9 neighbors. In general, most districts have approximately 5 to 6 neighbors.\n\n\n1.4.3.1.2 Computing (ROOK) contiguity based neighbors\nFor this, we will set the queen argument of the poly2nb() function to false.\n\nwm_r &lt;- poly2nb(boundary_with_accident_count, queen=FALSE) \nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 422 \nPercentage nonzero weights: 6.761737 \nAverage number of links: 5.341772 \nLink number distribution:\n\n 2  3  4  5  6  7  8 \n 1  5 16 20 22 11  4 \n1 least connected region:\n66 with 2 links\n4 most connected regions:\n1 5 17 54 with 8 links\n\n\nThe most connected area has 8 neighbors. In general, most districts have approximately 5 to 6 neighbors.\n\n\n\n1.4.3.2 Visualizing contiguity weights\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons in this situation, so we need to ensure that our points are in order to produce our connectivity graphs.\nUsually, the method of choice will be polygon centroids. We calculate using the sf package before moving onto the graphs. Getting latitude and longitude of the Polygon Centroids.\nWe need points to associate with each polygon before we can make our connectivity graph. It won’t be as simple as applying the st_centroid() function of the sf sf object: us.bound. We need the coordinates in a separate data-frame for this to work.\nTo do this, we will use a mapping function which will apply a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of us.bound.\nThe function that we implement in this situation will be st_centroid().\nWe will be using the map_dbl variation of map from the purrr package.\n\n1.4.3.2.1 Obtaining Coordinate values\n\nLongitudeLatitudeCoords\n\n\n\nlongitude &lt;- map_dbl(boundary_with_accident_count$geometry, ~st_centroid(.x)[[1]])\n\n\n\n\nlatitude &lt;- map_dbl(boundary_with_accident_count$geometry, ~st_centroid(.x)[[2]])\n\n\n\nNow that we have the latitude and longitude values, we can use the cbind() function to put the longitude and latitude values into the same object, coords.\n\ncoords &lt;- cbind(longitude, latitude)\n\n\nhead(coords)\n\n     longitude latitude\n[1,]  661951.4  1521172\n[2,]  664121.1  1523923\n[3,]  700735.2  1532207\n[4,]  664808.5  1518057\n[5,]  676193.5  1533602\n[6,]  677305.1  1522820\n\n\n\n\n\nWe can now plot the contiguity weights side by side for comparison.\n\npar(mfrow=c(1,2))\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"purple\")\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"darkgreen\")\n\n\n\n\n\n\n\n\n\n\nQueen Contiguity creates more connections as seen above, as it considers both shared vertices AND edges. This results in a more dense network.\nRook Contiguity results in fewer connections as it only considers shared borders as opposed to Queen Contiguity. This results in a simpler network.\n\n\nWe often use these in order to proceed with Spatial Autocorrelation Analysis to understand the neighbors taken into consideration amongst other factors.\n\n\n\n1.4.3.3 Adaptive Distance Weight Matrix\nOne of the characteristics of fixed distance weight matrices is that the more densely settled areas (usually urban areas) tend to have more neighbors and the less densely settled areas (usually rural areas) tend to have lesser neighbors.\nHaving many neighbors smoothens the neighbor relationship across more neighbors.\nIt is possible to control the numbers of neighbors directly using k-nearest neighbors by either accepting asymmetric neighbors or imposing symmetry\n\nknn6 &lt;- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 474 \nPercentage nonzero weights: 7.594937 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nWe immediately see a difference when comparing the above output to wm_q and wm_r. The number of non-zero links is higher.\nWe can create the plot for the same using the plot() function.\n\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\n\n\n\n1.4.3.4 Row standardized weights matrix\n\n1.4.3.4.1 Weights Based on Inversed Distance Weighting (IDW)\nWe first compute the distances between areas by implementing the nbdists() function of the spdep package.\n\ndist &lt;- nbdists(wm_q, coords, longlat = FALSE)\nids &lt;- lapply(dist, function(x) 1/(x))\nids\n\n[[1]]\n[1] 0.0002854535 0.0006582134 0.0004566217 0.0002167536 0.0003080119\n[6] 0.0002757322 0.0003371576 0.0002806965\n\n[[2]]\n[1] 0.0002854535 0.0002055287 0.0003012437 0.0003439200 0.0003703229\n[6] 0.0002193608 0.0001383976 0.0002982074\n\n[[3]]\n[1] 8.230456e-05 7.194802e-05 7.691011e-05 6.386761e-05\n\n[[4]]\n[1] 0.0005397094 0.0003348823 0.0004742967 0.0004145926 0.0006228750\n\n[[5]]\n[1] 1.466707e-04 1.197978e-04 1.317261e-04 1.901079e-04 1.449448e-04\n[6] 2.005737e-04 1.397857e-04 8.481219e-05\n\n[[6]]\n[1] 0.0001622765 0.0002212846 0.0002009303 0.0001431074 0.0001781389\n[6] 0.0002901167\n\n[[7]]\n[1] 0.0002055287 0.0005397094 0.0003428497 0.0003432013 0.0003504051\n[6] 0.0002113326 0.0005031250 0.0001878859\n\n[[8]]\n[1] 0.0006582134 0.0003012437 0.0003348823 0.0003428497 0.0007193454\n\n[[9]]\n[1] 0.0001452881 0.0001919620 0.0002478517 0.0001846853 0.0003608347\n[6] 0.0001275280\n\n[[10]]\n[1] 8.230456e-05 1.204212e-04 1.185473e-04 1.177461e-04 1.338999e-04\n\n[[11]]\n[1] 7.194802e-05 1.204212e-04 7.412539e-05 8.957108e-05 5.200876e-05\n[6] 6.530843e-05 8.333031e-05\n\n[[12]]\n[1] 0.0002120327 0.0003601503 0.0003033661 0.0002204848 0.0002299417\n\n[[13]]\n[1] 0.0004566217 0.0004742967 0.0003432013 0.0007193454 0.0005352046\n\n[[14]]\n[1] 0.0003439200 0.0004723701 0.0002181006 0.0001852359 0.0003556913\n\n[[15]]\n[1] 0.0002167536 0.0004178016 0.0005004725 0.0002059056 0.0002024628\n[6] 0.0002988328 0.0002534194\n\n[[16]]\n[1] 0.0003080119 0.0004178016 0.0001666057 0.0003222415 0.0002506523\n\n[[17]]\n[1] 0.0001622765 0.0004355978 0.0001468778 0.0001493430 0.0002022661\n[6] 0.0001455745 0.0002525101 0.0003209334\n\n[[18]]\n[1] 0.0002757322 0.0004145926 0.0005352046 0.0005004725 0.0003077165\n[6] 0.0003335152\n\n[[19]]\n[1] 0.0001666057 0.0002462888 0.0001860044 0.0001509068 0.0001330087\n[6] 0.0001378191 0.0002092546\n\n[[20]]\n[1] 0.0003371576 0.0003222415 0.0002462888 0.0001834292 0.0002732088\n\n[[21]]\n[1] 8.969997e-05 1.203769e-04 1.245294e-04 9.569804e-05 4.958860e-05\n\n[[22]]\n[1] 0.0002059056 0.0002506523 0.0001860044 0.0001834292 0.0002152303\n[6] 0.0001971194 0.0001095917\n\n[[23]]\n[1] 2.053579e-04 1.119769e-04 1.692192e-04 6.579843e-05 1.036058e-04\n\n[[24]]\n[1] 0.0002120327 0.0002024628 0.0003529966 0.0002347366 0.0001982741\n[6] 0.0001621175\n\n[[25]]\n[1] 0.0002806965 0.0003703229 0.0001509068 0.0002732088 0.0001935337\n[6] 0.0001208318\n\n[[26]]\n[1] 0.0004723701 0.0004355978 0.0001754699 0.0003013611\n\n[[27]]\n[1] 0.0001466707 0.0002212846 0.0002022599 0.0003179325 0.0001494025\n\n[[28]]\n[1] 0.0006228750 0.0003504051 0.0003601503 0.0003077165 0.0003330968\n[6] 0.0002241661\n\n[[29]]\n[1] 2.193608e-04 2.181006e-04 1.935337e-04 2.480081e-04 1.269610e-04\n[6] 1.731795e-04 8.705329e-05\n\n[[30]]\n[1] 0.0001383976 0.0001197978 0.0001852359 0.0001468778 0.0001754699\n[6] 0.0002480081 0.0002134931 0.0001692547 0.0001150417\n\n[[31]]\n[1] 0.0003033661 0.0002988328 0.0003335152 0.0003529966 0.0003330968\n\n[[32]]\n[1] 1.452881e-04 7.412539e-05 1.648225e-04 1.385556e-04 1.384360e-04\n[6] 9.877756e-05\n\n[[33]]\n[1] 0.0002113326 0.0001919620 0.0002204848 0.0002241661 0.0004631083\n[6] 0.0001381990\n\n[[34]]\n[1] 0.0002009303 0.0002478517 0.0001493430 0.0001648225 0.0002087434\n[6] 0.0001252900\n\n[[35]]\n[1] 2.534194e-04 8.969997e-05 2.152303e-04 2.347366e-04 1.338459e-04\n[6] 1.190158e-04\n\n[[36]]\n[1] 1.317261e-04 1.741388e-04 1.477787e-04 9.360890e-05 1.023839e-04\n[6] 4.522313e-05\n\n[[37]]\n[1] 0.0002982074 0.0005031250 0.0003556913 0.0002022661 0.0003013611\n[6] 0.0001760696\n\n[[38]]\n[1] 0.0001901079 0.0001431074 0.0001455745 0.0002022599 0.0002134931\n[6] 0.0001969405\n\n[[39]]\n[1] 0.0001878859 0.0001846853 0.0002525101 0.0004631083 0.0002087434\n[6] 0.0001760696\n\n[[40]]\n[1] 0.0001330087 0.0001971194 0.0002053579 0.0001396487 0.0001509543\n\n[[41]]\n[1] 0.0001449448 0.0001269610 0.0001692547 0.0001741388 0.0001155726\n[6] 0.0001062678\n\n[[42]]\n[1] 2.005737e-04 1.477787e-04 1.006357e-04 5.914874e-05\n\n[[43]]\n[1] 0.0001397857 0.0001185473 0.0003179325 0.0001503042 0.0001120205\n\n[[44]]\n[1] 1.781389e-04 1.177461e-04 8.957108e-05 1.494025e-04 1.385556e-04\n[6] 1.252900e-04 1.503042e-04\n\n[[45]]\n[1] 0.0002901167 0.0003209334 0.0001969405\n\n[[46]]\n[1] 7.691011e-05 8.481219e-05 1.338999e-04 1.006357e-04 1.120205e-04\n[6] 7.834800e-05\n\n[[47]]\n[1] 3.608347e-04 1.384360e-04 8.847607e-05 7.825942e-05 1.380165e-04\n\n[[48]]\n[1] 1.378191e-04 1.119769e-04 1.396487e-04 1.390484e-04 5.812114e-05\n[6] 9.420908e-05\n\n[[49]]\n[1] 0.0001203769 0.0001982741 0.0001338459 0.0001460302 0.0001218403\n\n[[50]]\n[1] 1.245294e-04 1.095917e-04 1.692192e-04 1.190158e-04 1.509543e-04\n[6] 4.881437e-05 7.827893e-05\n\n[[51]]\n[1] 8.847607e-05 4.260505e-05 9.775096e-05 7.211651e-05 6.976002e-05\n\n[[52]]\n[1] 5.200876e-05 4.260505e-05 6.461671e-05 1.208164e-04\n\n[[53]]\n[1] 6.530843e-05 9.877756e-05 7.825942e-05 9.775096e-05 6.461671e-05\n[6] 1.098016e-04\n\n[[54]]\n[1] 1.275280e-04 2.299417e-04 1.621175e-04 1.381990e-04 1.380165e-04\n[6] 1.460302e-04 7.211651e-05 8.749710e-05\n\n[[55]]\n[1] 9.569804e-05 1.218403e-04 6.976002e-05 8.749710e-05\n\n[[56]]\n[1] 8.333031e-05 1.208164e-04 1.098016e-04\n\n[[57]]\n[1] 0.0001731795 0.0001150417 0.0001155726 0.0001121332 0.0000764271\n[6] 0.0000755279 0.0001320269\n\n[[58]]\n[1] 2.092546e-04 1.208318e-04 8.705329e-05 1.390484e-04 1.121332e-04\n[6] 1.356813e-04 6.810787e-05\n\n[[59]]\n[1] 7.642710e-05 1.356813e-04 1.153320e-04 5.588948e-05 1.070876e-04\n\n[[60]]\n[1] 7.552790e-05 1.153320e-04 8.048614e-05 9.201600e-05 7.698649e-05\n\n[[61]]\n[1] 5.588948e-05 8.048614e-05 8.676092e-05 7.105006e-05 5.108714e-05\n\n[[62]]\n[1] 9.360890e-05 1.062678e-04 1.320269e-04 9.201600e-05 1.156307e-04\n[6] 6.087272e-05\n\n[[63]]\n[1] 1.023839e-04 1.156307e-04 5.287764e-05 4.047452e-05 6.619029e-05\n[6] 3.620195e-05 9.994772e-05\n\n[[64]]\n[1] 5.287764e-05 8.616137e-05 5.274538e-05 6.005288e-05\n\n[[65]]\n[1] 4.047452e-05 8.616137e-05 5.965942e-05 1.524056e-04\n\n[[66]]\n[1] 5.274538e-05 5.965942e-05\n\n[[67]]\n[1] 7.698649e-05 8.676092e-05 6.087272e-05 6.619029e-05 7.655740e-05\n\n[[68]]\n[1] 6.386761e-05 4.522313e-05 5.914874e-05 7.834800e-05 3.620195e-05\n[6] 1.524056e-04\n\n[[69]]\n[1] 9.994772e-05 6.005288e-05 7.655740e-05\n\n[[70]]\n[1] 4.117989e-05 5.885227e-05 6.155251e-05 4.225974e-05\n\n[[71]]\n[1] 4.117989e-05 5.953357e-05 4.110606e-05\n\n[[72]]\n[1] 5.885227e-05 5.899804e-05 4.000195e-05 8.692110e-05 8.457300e-05\n\n[[73]]\n[1] 6.155251e-05 5.953357e-05 5.899804e-05 6.741263e-05\n\n[[74]]\n[1] 7.105006e-05 4.110606e-05 4.000195e-05 6.741263e-05 3.789103e-05\n\n[[75]]\n[1] 6.579843e-05 5.812114e-05 4.225974e-05 8.692110e-05 7.172077e-05\n[6] 1.056880e-04 5.465069e-05\n\n[[76]]\n[1] 9.420908e-05 6.810787e-05 1.070876e-04 5.108714e-05 8.457300e-05\n[6] 3.789103e-05 7.172077e-05\n\n[[77]]\n[1] 4.958860e-05 4.881437e-05 7.004105e-05 6.324110e-05\n\n[[78]]\n[1] 1.036058e-04 7.827893e-05 1.056880e-04 7.004105e-05 5.420721e-05\n\n[[79]]\n[1] 5.465069e-05 6.324110e-05 5.420721e-05\n\n\nWe now need to assign weights to each neighboring polygon. We use equal weights (style=“W”), where each neighboring polygon is assigned a weight of 1 divided by the number of neighbors.\nThis means each neighboring county’s weight is calculated as 1/(# of neighbors), and these weights are then used to sum the weighted income values.\nWhile this method is intuitive for summarizing neighbors’ values, it has a drawback: polygons at the edges of the study area may rely on fewer neighbors, potentially skewing the spatial autocorrelation results.\n\n\nNote on style argument\n\n\nNote: For simplicity, we’ll use the style=“W” option in this example, but be aware that more robust options, such as style=“B”, are available.\n\n\n\nrswm_q &lt;- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0      S1       S2\nW 79 6241 79 29.8143 321.0615\n\n\nSetting the argument zero.policy to TRUE allows for lists of non-neighbors. This should be used with caution as users may not be aware of missing neighbors in their data however setting zero,policy to FALSE would return an error.\nThe code chunk below is implemented to check the weights of the first polygons eight neighbors type:\n\nrswm_q$weights[10]\n\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n\nUsing the same method, we derive a row standardized distance weight matrix by using the code chunk below.\n\nrswm_ids &lt;- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \n\nWeights style: B \nWeights constants summary:\n   n   nn         S0           S1           S2\nB 79 6241 0.07702966 4.057545e-05 0.0004441685\n\n\nWe now compute the average neighbor Accident count value for each polygon. We often refer to these values as Spatially Lagged Values.\n\nacc.lag &lt;- lag.listw(rswm_q, boundary_with_accident_count$accident_count)\nacc.lag\n\n [1]   3.375000  42.750000 440.750000  10.800000 141.000000 115.333333\n [7]  12.500000  10.600000 222.500000 400.600000 351.714286 123.000000\n[13]  10.800000  39.600000  30.714286  90.400000  58.375000   5.166667\n[19] 162.428571  94.400000 239.600000 144.857143 299.600000 136.333333\n[25]  84.333333  73.500000 206.400000  41.500000  72.142857  57.222222\n[31]  40.800000 350.000000 116.333333 163.333333  76.333333 203.333333\n[37]  27.833333  60.166667  53.833333 258.000000 119.166667 240.250000\n[43] 157.400000 311.428571  34.333333 241.000000 366.800000 190.666667\n[49] 212.000000 234.857143 324.200000 540.500000 444.500000  86.875000\n[55] 261.750000 626.333333 112.571429 223.857143 115.200000 124.600000\n[61] 120.200000 120.000000 290.428571 149.750000 348.000000 523.000000\n[67] 135.800000 165.500000 291.000000 121.500000 125.333333 140.600000\n[73] 133.250000  67.600000 190.285714 206.000000 138.250000 262.400000\n[79] 390.666667\n\n\nWe can retrieve the Accident count for each by using the code Chunk Below.\n\nnb1 &lt;- wm_q[[1]] #Shows the accident counts for the neighboring districts of region 1\nnb1 &lt;- boundary_with_accident_count$accident_count[nb1]\nnb1\n\n[1]  0  0  0  2  0  1  1 23\n\n\n\nA spatial lag with row-standardized weights means that each observation’s value is influenced by the average values of its neighboring observations. Specifically, the weights are standardized so that the sum of the weights for each observation equals one.\nThis approach ensures that the spatial lag is essentially the weighted average of the neighboring values.\n\nWe can append the spatially lagged Accident values onto the boundary_with_accident_count sf data-frame by using the code chunk shown below.\n\nlag.list &lt;- list(boundary_with_accident_count$ADM2_EN.x, lag.listw(rswm_q, boundary_with_accident_count$accident_count))\nlag.res &lt;- as.data.frame(lag.list)\ncolnames(lag.res) &lt;- c(\"ADM2_EN.x\", \"lag Accident Count\")\nboundary_with_accident_count &lt;- left_join(boundary_with_accident_count,lag.res)\n\nWe can gain further insight into this data-frame by implementing the head() function.\n\nhead(boundary_with_accident_count)\n\nSimple feature collection with 6 features and 22 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 660838.3 ymin: 1517063 xmax: 709544.6 ymax: 1542641\nProjected CRS: WGS 84 / UTM zone 47N\n  Shape_Leng   Shape_Area   ADM2_EN.x ADM2_TH ADM2_PCODE ADM2_REF ADM2ALT1EN\n1 0.08541733 0.0004504685 Phra Nakhon  พระนคร     TH1001     &lt;NA&gt;       &lt;NA&gt;\n2 0.13413177 0.0009501914       Dusit     ดุสิต     TH1002     &lt;NA&gt;       &lt;NA&gt;\n3 0.67634217 0.0198588627   Nong Chok หนองจอก     TH1003     &lt;NA&gt;       &lt;NA&gt;\n4 0.08588647 0.0003369561    Bang Rak   บางรัก     TH1004     &lt;NA&gt;       &lt;NA&gt;\n5 0.30172202 0.0034149298   Bang Khen  บางเขน     TH1005     &lt;NA&gt;       &lt;NA&gt;\n6 0.30869124 0.0023032680   Bang Kapi  บางกะปิ     TH1006     &lt;NA&gt;       &lt;NA&gt;\n  ADM2ALT2EN ADM2ALT1TH ADM2ALT2TH ADM1_EN      ADM1_TH ADM1_PCODE  ADM0_EN\n1       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n2       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n3       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n4       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n5       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n6       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n    ADM0_TH ADM0_PCODE       date    validOn    validTo ADM2_EN.y\n1 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30      &lt;NA&gt;\n2 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30      &lt;NA&gt;\n3 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30 Nong Chok\n4 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30  Bang Rak\n5 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30 Bang Khen\n6 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30 Bang Kapi\n  accident_count lag Accident Count                       geometry\n1              0             3.3750 MULTIPOLYGON (((662263.2 15...\n2              0            42.7500 MULTIPOLYGON (((664304.4 15...\n3             60           440.7500 MULTIPOLYGON (((706774.6 15...\n4              8            10.8000 MULTIPOLYGON (((664040.2 15...\n5            126           141.0000 MULTIPOLYGON (((673966.4 15...\n6             10           115.3333 MULTIPOLYGON (((676080.6 15...\n\n\nWe now plot the observed Accident and Spatial Lag Accidents side by side for comparison.\n\nacc_qtm &lt;- qtm(boundary_with_accident_count, \"accident_count\")\nlag_acc &lt;- qtm(boundary_with_accident_count, \"lag Accident Count\")\ntmap_arrange(acc_qtm, lag_acc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\nThe use of spatial weights are highly useful for a variety of reasons.\n\nThey allow us to better understand and analyze the dependence between neighboring regions.\nThe help us understand how accidents are not isolated incidents and are often a part of bigger spatial patterns. This allows us to make better decisions with regards to policy developments, resource allocation and more in order to reduce the number of accidents.\nThese help us identify clusters and are crucial in identifying ‘spillover’ effects.\n\n\n\n\n\n1.4.3.5 Spatial Window Average\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights.\nTo add the diagonal element to the neighbour list, we use the include.self() function from the spdep package.\n\nwm_qs &lt;- include.self(wm_q)\nwm_qs\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 517 \nPercentage nonzero weights: 8.283929 \nAverage number of links: 6.544304 \n\n\nThere is a difference in the key statistics shown above when compared to wm_q. The average number of links, the number of non-zero links as well as percentage of non-zero weights are all higher for wm_qs.\nWe look at the neighbor list of area [1] using the code chunk below.\n\nwm_qs[[1]]\n\n[1]  1  2  8 13 15 16 18 20 25\n\n\nThis region has 9 neighbors.\nWe now implement the nb2listw() function in order to obtain weights.\n\nwm_qs &lt;- nb2listw(wm_qs)\nwm_qs\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 517 \nPercentage nonzero weights: 8.283929 \nAverage number of links: 6.544304 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 79 6241 79 24.99173 318.4378\n\n\nWe now create the lag variable from our weight structure and accident_count variable.\n\nlag_w_avg_acc &lt;- lag.listw(wm_qs, \n                             boundary_with_accident_count$accident_count)\nlag_w_avg_acc\n\n [1]   3.000000  38.000000 364.600000  10.333333 139.333333 100.285714\n [7]  16.111111   8.833333 191.571429 345.833333 423.500000 125.500000\n[13]   9.000000  46.666667  27.125000  75.333333  55.000000   4.571429\n[19] 198.000000  78.833333 245.166667 127.000000 249.666667 124.714286\n[25]  75.571429  60.000000 174.833333  36.714286  64.125000  66.500000\n[31]  36.166667 377.714286 106.000000 163.714286  86.000000 184.285714\n[37]  28.714286  60.857143  47.000000 268.333333 106.571429 225.000000\n[43] 205.333333 320.750000  33.250000 233.142857 319.000000 269.285714\n[49] 181.000000 218.000000 312.333333 515.800000 457.571429 132.222222\n[55] 228.000000 581.500000 119.625000 202.125000 115.833333 143.500000\n[61] 110.000000 130.285714 270.125000 252.000000 355.400000 356.666667\n[67] 127.166667 224.571429 233.750000 146.200000 114.500000 134.833333\n[73] 112.800000  73.000000 199.875000 187.750000 277.600000 230.333333\n[79] 320.500000\n\n\nWe then proceed to convert the lag variable listwobject into a data-frame by using as.data.frame().\n\nlag.list.wm_qs &lt;- list(boundary_with_accident_count$ADM2_EN.x, lag.listw(wm_qs, boundary_with_accident_count$accident_count))\nlag_wm_qs.res &lt;- as.data.frame(lag.list.wm_qs)\ncolnames(lag_wm_qs.res) &lt;- c(\"ADM2_EN.x\", \"lag_window_avg acc\")\n\n\nNote: The third command line on the code chunk above renames the field names of lag_wm_q1.res object into accident_count and lag_window_avg acc respectively.\n\nWe now append the lag_window_avg acc values onto the boundary_with_accident_count sf data.frame by using left_join() of dplyr package.\n\nboundary_with_accident_count &lt;- left_join(boundary_with_accident_count, lag_wm_qs.res)\n\nTo compare the values of lag accident count and Spatial window average, The kable() function of the Knitr package is used to prepare a table.\n\nboundary_with_accident_count %&gt;%\n  dplyr::select(\"ADM2_EN.x\", \n         \"lag Accident Count\", \n         \"lag_window_avg acc\") %&gt;%\n  kable()\n\n\n\n\n\n\n\n\n\n\nADM2_EN.x\nlag Accident Count\nlag_window_avg acc\ngeometry\n\n\n\n\nPhra Nakhon\n3.375000\n3.000000\nMULTIPOLYGON (((662263.2 15…\n\n\nDusit\n42.750000\n38.000000\nMULTIPOLYGON (((664304.4 15…\n\n\nNong Chok\n440.750000\n364.600000\nMULTIPOLYGON (((706774.6 15…\n\n\nBang Rak\n10.800000\n10.333333\nMULTIPOLYGON (((664040.2 15…\n\n\nBang Khen\n141.000000\n139.333333\nMULTIPOLYGON (((673966.4 15…\n\n\nBang Kapi\n115.333333\n100.285714\nMULTIPOLYGON (((676080.6 15…\n\n\nPathum Wan\n12.500000\n16.111111\nMULTIPOLYGON (((664236.5 15…\n\n\nPom Prap Sattru Phai\n10.600000\n8.833333\nMULTIPOLYGON (((663880.5 15…\n\n\nPhra Khanong\n222.500000\n191.571429\nMULTIPOLYGON (((674748.8 15…\n\n\nMin Buri\n400.600000\n345.833333\nMULTIPOLYGON (((694735.5 15…\n\n\nLat Krabang\n351.714286\n423.500000\nMULTIPOLYGON (((694497.3 15…\n\n\nYan Nawa\n123.000000\n125.500000\nMULTIPOLYGON (((667818.3 15…\n\n\nSamphanthawong\n10.800000\n9.000000\nMULTIPOLYGON (((663592.4 15…\n\n\nPhaya Thai\n39.600000\n46.666667\nMULTIPOLYGON (((667624 1525…\n\n\nThon Buri\n30.714286\n27.125000\nMULTIPOLYGON (((661364.9 15…\n\n\nBangkok Yai\n90.400000\n75.333333\nMULTIPOLYGON (((660991.6 15…\n\n\nHuai Khwang\n58.375000\n55.000000\nMULTIPOLYGON (((671695.6 15…\n\n\nKhlong San\n5.166667\n4.571429\nMULTIPOLYGON (((662113.2 15…\n\n\nTaling Chan\n162.428571\n198.000000\nMULTIPOLYGON (((654587 1526…\n\n\nBangkok Noi\n94.400000\n78.833333\nMULTIPOLYGON (((659654.1 15…\n\n\nBang Khun Thian\n239.600000\n245.166667\nMULTIPOLYGON (((656541 1512…\n\n\nPhasi Charoen\n144.857143\n127.000000\nMULTIPOLYGON (((654370 1519…\n\n\nNong Khaem\n299.600000\n249.666667\nMULTIPOLYGON (((647001.3 15…\n\n\nRat Burana\n136.333333\n124.714286\nMULTIPOLYGON (((661132.1 15…\n\n\nBang Phlat\n84.333333\n75.571429\nMULTIPOLYGON (((663052.9 15…\n\n\nDin Daeng\n73.500000\n60.000000\nMULTIPOLYGON (((670238.2 15…\n\n\nBueng Kum\n206.400000\n174.833333\nMULTIPOLYGON (((678184.5 15…\n\n\nSathon\n41.500000\n36.714286\nMULTIPOLYGON (((667917.7 15…\n\n\nBang Sue\n72.142857\n64.125000\nMULTIPOLYGON (((666275.4 15…\n\n\nChatuchak\n57.222222\n66.500000\nMULTIPOLYGON (((671471.4 15…\n\n\nBang Kho Laem\n40.800000\n36.166667\nMULTIPOLYGON (((664335.2 15…\n\n\nPrawet\n350.000000\n377.714286\nMULTIPOLYGON (((680695.6 15…\n\n\nKhlong Toei\n116.333333\n106.000000\nMULTIPOLYGON (((673075.4 15…\n\n\nSuan Luang\n163.333333\n163.714286\nMULTIPOLYGON (((677751.8 15…\n\n\nChom Thong\n76.333333\n86.000000\nMULTIPOLYGON (((658696.5 15…\n\n\nDon Mueang\n203.333333\n184.285714\nMULTIPOLYGON (((674339.8 15…\n\n\nRatchathewi\n27.833333\n28.714286\nMULTIPOLYGON (((667199.4 15…\n\n\nLat Phrao\n60.166667\n60.857143\nMULTIPOLYGON (((673842.9 15…\n\n\nVadhana\n53.833333\n47.000000\nMULTIPOLYGON (((668704.8 15…\n\n\nBang Khae\n258.000000\n268.333333\nMULTIPOLYGON (((647693 1520…\n\n\nLak Si\n119.166667\n106.571429\nMULTIPOLYGON (((671045.4 15…\n\n\nSai Mai\n240.250000\n225.000000\nMULTIPOLYGON (((679686.2 15…\n\n\nKhan Na Yao\n157.400000\n205.333333\nMULTIPOLYGON (((680806.2 15…\n\n\nSaphan Sung\n311.428571\n320.750000\nMULTIPOLYGON (((685556.9 15…\n\n\nWang Thonglang\n34.333333\n33.250000\nMULTIPOLYGON (((671782.5 15…\n\n\nKhlong Sam Wa\n241.000000\n233.142857\nMULTIPOLYGON (((693668.9 15…\n\n\nBang Na\n366.800000\n319.000000\nMULTIPOLYGON (((675501.8 15…\n\n\nThawi Watthana\n190.666667\n269.285714\nMULTIPOLYGON (((650687.8 15…\n\n\nThung Khru\n212.000000\n181.000000\nMULTIPOLYGON (((660699.8 15…\n\n\nBang Bon\n234.857143\n218.000000\nMULTIPOLYGON (((656343.6 15…\n\n\nMueang Samut Prakan\n324.200000\n312.333333\nMULTIPOLYGON (((673201.8 15…\n\n\nBang Bo\n540.500000\n515.800000\nMULTIPOLYGON (((712294.1 15…\n\n\nBang Phli\n444.500000\n457.571429\nMULTIPOLYGON (((687139.8 15…\n\n\nPhra Pradaeng\n86.875000\n132.222222\nMULTIPOLYGON (((670827.4 15…\n\n\nPhra Samut Chedi\n261.750000\n228.000000\nMULTIPOLYGON (((669191.5 15…\n\n\nBang Sao Thong\n626.333333\n581.500000\nMULTIPOLYGON (((695481.3 15…\n\n\nMueang Nonthaburi\n112.571429\n119.625000\nMULTIPOLYGON (((662112.2 15…\n\n\nBang Kruai\n223.857143\n202.125000\nMULTIPOLYGON (((654095.9 15…\n\n\nBang Yai\n115.200000\n115.833333\nMULTIPOLYGON (((649983.7 15…\n\n\nBang Bua Thong\n124.600000\n143.500000\nMULTIPOLYGON (((649993.4 15…\n\n\nSai Noi\n120.200000\n110.000000\nMULTIPOLYGON (((644817.9 15…\n\n\nPak Kret\n120.000000\n130.285714\nMULTIPOLYGON (((652378.8 15…\n\n\nMueang Pathum Thani\n290.428571\n270.125000\nMULTIPOLYGON (((672162.5 15…\n\n\nKhlong Luang\n149.750000\n252.000000\nMULTIPOLYGON (((689473.3 15…\n\n\nThanyaburi\n348.000000\n355.400000\nMULTIPOLYGON (((706757.7 15…\n\n\nNong Suea\n523.000000\n356.666667\nMULTIPOLYGON (((704086 1575…\n\n\nLat Lum Kaeo\n135.800000\n127.166667\nMULTIPOLYGON (((650538.8 15…\n\n\nLam Luk Ka\n165.500000\n224.571429\nMULTIPOLYGON (((706764.9 15…\n\n\nSam Khok\n291.000000\n233.750000\nMULTIPOLYGON (((665864.3 15…\n\n\nMueang Nakhon Pathom\n121.500000\n146.200000\nMULTIPOLYGON (((602747 1541…\n\n\nKamphaeng Saen\n125.333333\n114.500000\nMULTIPOLYGON (((612428.1 15…\n\n\nNakhon Chai Si\n140.600000\n134.833333\nMULTIPOLYGON (((627397.1 15…\n\n\nDon Tum\n133.250000\n112.800000\nMULTIPOLYGON (((620292.6 15…\n\n\nBang Len\n67.600000\n73.000000\nMULTIPOLYGON (((631987.6 15…\n\n\nSam Phran\n190.285714\n199.875000\nMULTIPOLYGON (((636176.3 15…\n\n\nPhutthamonthon\n206.000000\n187.750000\nMULTIPOLYGON (((637713.4 15…\n\n\nMueang Samut Sakhon\n138.250000\n277.600000\nMULTIPOLYGON (((646615.4 15…\n\n\nKrathum Baen\n262.400000\n230.333333\nMULTIPOLYGON (((641549.1 15…\n\n\nBan Phaeo\n390.666667\n320.500000\nMULTIPOLYGON (((625054.6 15…\n\n\n\n\n\nWe now plot the lag accident count and w_ave_acc maps next to each other for comparison using the qtm() function of the tmap package.\n\nw_avg_acc &lt;- qtm(boundary_with_accident_count, \"lag_window_avg acc\")\ntmap_arrange(lag_acc, w_avg_acc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\nequal &lt;- tm_shape(boundary_with_accident_count) +\n  tm_fill(\"accident_count\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile &lt;- tm_shape(boundary_with_accident_count) +\n  tm_fill(\"accident_count\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-autocorrelation-morans-i-test.",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-autocorrelation-morans-i-test.",
    "title": "Take Home Exercise 1",
    "section": "1.4.4 Spatial Autocorrelation: Morans I test.",
    "text": "1.4.4 Spatial Autocorrelation: Morans I test.\nThe hypotheses for the test are as follows:\n\nH0: Regions with similar number of accidents are randomly distributed.\nH1: Regions with similar number of accidents are not randomly distributed and exhibit spatial clustering.\n\n\nmoran.test(boundary_with_accident_count$accident_count, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  boundary_with_accident_count$accident_count  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 3.7964, p-value = 7.34e-05\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.235764728      -0.012820513       0.004287482 \n\n\nFrom the output above, we can infer the following:\n\nThe p-value (7.34e-05)&lt;0.05, indicating that the observed spatial autocorrelation is statistically significant.\nMoran’s I statistic: The observed value of 0.236 indicates positive spatial autocorrelation, meaning that regions with similar number of accidents are more likely to be located near each other.\n\nSince Moran’s I Statistic is significantly greater than what we would expect in a randomly distributed region. There is significant evidence to reject H0 and conclude that there is indeed spatial clustering with regards to Accidents in the Bangkok Metropolitan Region.\n\n1.4.4.1 Monte Carlo Moran’s I\nWe now implement the moran.mc() function of the spdep package. In this scenario, we will run 1000 simulations.\n\nbperm= moran.mc(boundary_with_accident_count$accident_count, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  boundary_with_accident_count$accident_count \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.23576, observed rank = 999, p-value = 0.001\nalternative hypothesis: greater\n\n\nBased on the above output, p-value (0.001)&lt;0.05, thus we can reject the null hypothesis at a 5% significance level and conclude that there is indeed spatial clustering.\n\n\n1.4.4.2 Visualizing Monte Carlo Moran’s I\nWe can visualize the test statistics obtained from the simulation above by implementing the hist() and abline() functions of R graphics.\n\nSummary StatisticsThe plotggplot method\n\n\nWe first calculate the mean and variance, and obtain the summary statistics.\n\nmean(bperm$res[1:999])\n\n[1] -0.01744349\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004001047\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.19669 -0.06142 -0.02135 -0.01744  0.02088  0.30376 \n\n\n\n\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\n\n\n\n\nFrom the above, we can infer that over half of all simulations indicate a negative value for Moran’s I statistic. Generally, a negative value indicates that dissimilar regions are located next to each other. (i.e: regions with dissimilar number of Accidents are located next to each other)\n\n\nWe can also make use of the ggplot2 R package to produce a plot.\n\ndata &lt;- data.frame(simulated_moran = bperm$res)\n\nggplot(data, aes(x = simulated_moran)) +\n  geom_histogram(binwidth = (max(data$simulated_moran) - min(data$simulated_moran)) / 20, \n                 fill = \"lightblue\", color = \"black\") +\n  geom_vline(xintercept = 0, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"Simulated Moran's I\", \n       y = \"Frequency\",\n       title = \"Histogram of Simulated Moran's I\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.4.4.3 Local Morans I\nWe implement the localmoran() function of spdep compute the local Moran’s I statistic. This function helps us compute li values, given a set of zi values and a listw object providing neighbor weighting information for the polygon associated with the zi values.\nWe compute local Moran’s I of accident_count at the district level.\n\nfips &lt;- order(boundary_with_accident_count$accident_count)\nlocalMI &lt;- localmoran(boundary_with_accident_count$accident_count, rswm_q)\nhead(localMI)\n\n           Ii          E.Ii      Var.Ii       Z.Ii Pr(z != E(Ii))\n1  0.60429563 -0.0079097813 0.070446604  2.3065726    0.021078658\n2  0.45651029 -0.0079097813 0.070446604  1.7497699    0.080158019\n3 -0.65867321 -0.0031893365 0.060342196 -2.6684032    0.007621273\n4  0.54837408 -0.0071586128 0.106462820  1.7025922    0.088644413\n5  0.02048823 -0.0004311934 0.003869271  0.3363063    0.736639872\n6  0.17288609 -0.0069766753 0.085295392  0.6158550    0.537990224\n\n\n\nlocalmoran() function returns a matrix of values whose columns are:\n\nIi: the local Moran’s I statistics\nE.Ii: the expectation of local moran statistic under the randomisation hypothesis\nVar.Ii: the variance of local moran statistic under the randomisation hypothesis\nZ.Ii:the standard deviate of local moran statistic\nPr(): the p-value of local moran statistic\n\n\nWe now use the printCoefmat() to display the content of the local Moran matrix that we created above.\n\nprintCoefmat(data.frame(\n  localMI[fips,], \n  row.names=boundary_with_accident_count$ADM2_EN.x[fips]),\n  check.names=FALSE)\n\n                              Ii        E.Ii      Var.Ii        Z.Ii\nPhra Nakhon           6.0430e-01 -7.9098e-03  7.0447e-02  2.3066e+00\nDusit                 4.5651e-01 -7.9098e-03  7.0447e-02  1.7498e+00\nPom Prap Sattru Phai  5.7718e-01 -7.9098e-03  1.1755e-01  1.7065e+00\nSamphanthawong        5.7643e-01 -7.9098e-03  1.1755e-01  1.7044e+00\nBangkok Yai           2.7767e-01 -7.9098e-03  1.1755e-01  8.3295e-01\nNong Khaem           -5.0752e-01 -7.9098e-03  1.1755e-01 -1.4572e+00\nKhlong San            5.9394e-01 -7.8138e-03  9.5450e-02  1.9477e+00\nBangkok Noi           2.6106e-01 -7.8138e-03  1.1613e-01  7.8898e-01\nThon Buri             4.9558e-01 -7.7185e-03  7.9701e-02  1.7828e+00\nPhasi Charoen         7.2382e-02 -7.7185e-03  7.9701e-02  2.8373e-01\nPhra Khanong         -2.1018e-01 -7.3429e-03  8.9740e-02 -6.7710e-01\nDin Daeng             3.2865e-01 -7.3429e-03  1.3835e-01  9.0331e-01\nVadhana               3.9977e-01 -7.3429e-03  8.9740e-02  1.3590e+00\nBang Rak              5.4837e-01 -7.1586e-03  1.0646e-01  1.7026e+00\nSathon                4.3876e-01 -7.1586e-03  8.7504e-02  1.5074e+00\nBang Sue              3.2934e-01 -7.1586e-03  7.3961e-02  1.2373e+00\nBang Kapi             1.7289e-01 -6.9767e-03  8.5295e-02  6.1586e-01\nBang Kho Laem         4.2715e-01 -6.7082e-03  9.9809e-02  1.3733e+00\nBueng Kum            -1.4140e-01 -6.3583e-03  9.4637e-02 -4.3898e-01\nBang Phlat            2.5840e-01 -5.8512e-03  7.1616e-02  9.8744e-01\nNong Suea            -1.1495e+00 -5.7687e-03  2.2361e-01 -2.4187e+00\nThung Khru           -1.5046e-01 -5.6055e-03  8.3495e-02 -5.0131e-01\nHuai Khwang           3.3009e-01 -5.4446e-03  4.8612e-02  1.5219e+00\nWang Thonglang        3.9902e-01 -5.2861e-03  1.3487e-01  1.1009e+00\nLak Si                1.3769e-01 -5.2077e-03  6.3782e-02  5.6584e-01\nDon Tum               9.4804e-02 -5.2077e-03  9.8330e-02  3.1894e-01\nRatchathewi           4.0649e-01 -4.9761e-03  6.0959e-02  1.6665e+00\nKhlong Toei           1.3206e-01 -4.2420e-03  5.2005e-02  5.9770e-01\nPathum Wan            4.1399e-01 -4.1719e-03  3.7296e-02  2.1653e+00\nBang Kruai           -1.5533e-01 -3.8297e-03  3.9701e-02 -7.6037e-01\nRat Burana            7.0045e-02 -3.5022e-03  4.2967e-02  3.5481e-01\nSai Noi               1.0630e-01 -3.2507e-03  4.8535e-02  4.9727e-01\nNong Chok            -6.5867e-01 -3.1893e-03  6.0342e-02 -2.6684e+00\nPhutthamonthon       -9.9194e-02 -3.1893e-03  3.3083e-02 -5.2782e-01\nSam Khok             -2.9599e-01 -3.0683e-03  7.8458e-02 -1.0458e+00\nLat Phrao             2.3647e-01 -2.8911e-03  3.5491e-02  1.2706e+00\nDon Mueang           -8.3944e-02 -2.6075e-03  3.2019e-02 -4.5455e-01\nKrathum Baen         -2.1123e-01 -2.6075e-03  3.8957e-02 -1.0570e+00\nMin Buri             -4.9826e-01 -2.4982e-03  3.7327e-02 -2.5660e+00\nBang Na              -3.8999e-01 -2.0842e-03  3.1155e-02 -2.1977e+00\nPhaya Thai            2.3471e-01 -1.9866e-03  2.9698e-02  1.3735e+00\nKamphaeng Saen        7.3445e-02 -1.9866e-03  5.0854e-02  3.3450e-01\nLat Lum Kaeo          5.2453e-02 -1.8913e-03  2.8277e-02  3.2317e-01\nPhra Samut Chedi     -1.5870e-01 -1.4915e-03  2.8267e-02 -9.3503e-01\nBang Bon             -1.0360e-01 -1.2133e-03  1.2611e-02 -9.1175e-01\nBang Len              1.4226e-01 -1.2133e-03  1.8152e-02  1.0649e+00\nNakhon Chai Si        3.1698e-02 -9.9768e-04  1.4930e-02  2.6759e-01\nBan Phaeo            -2.8097e-01 -8.6565e-04  2.2184e-02 -1.8806e+00\nBang Yai              5.0958e-02 -6.0283e-04  9.0244e-03  5.4276e-01\nBang Khen             2.0488e-02 -4.3119e-04  3.8693e-03  3.3631e-01\nMueang Pathum Thani  -1.0470e-01 -3.8742e-04  4.0301e-03 -1.6432e+00\nYan Nawa              2.4924e-02 -2.0371e-04  3.0508e-03  4.5494e-01\nChom Thong            4.0971e-02 -1.2158e-04  1.4967e-03  1.0622e+00\nChatuchak             3.5183e-02 -6.0530e-05  4.7609e-04  1.6152e+00\nSai Mai              -6.5785e-04 -4.2214e-08  8.0124e-07 -7.3488e-01\nSuan Luang           -3.8712e-05 -7.6848e-07  9.4613e-06 -1.2336e-02\nMueang Nonthaburi    -5.4655e-03 -6.2488e-06  6.5027e-05 -6.7699e-01\nKhlong Sam Wa         3.7824e-02 -1.3683e-04  1.6844e-03  9.2494e-01\nPak Kret             -2.7988e-02 -2.2332e-04  2.7488e-03 -5.2957e-01\nBang Bua Thong       -6.6869e-02 -1.5866e-03  2.3728e-02 -4.2380e-01\nMueang Nakhon Pathom -7.8933e-02 -1.9026e-03  3.6044e-02 -4.0574e-01\nMueang Samut Prakan   3.2339e-01 -2.2990e-03  3.4358e-02  1.7571e+00\nSam Phran             6.0701e-02 -3.0827e-03  3.1981e-02  3.5667e-01\nBang Khun Thian       1.8656e-01 -3.4537e-03  5.1556e-02  8.3683e-01\nBang Khae             3.3266e-01 -7.0892e-03  1.0544e-01  1.0463e+00\nThanyaburi            9.2497e-01 -1.4248e-02  2.6658e-01  1.8191e+00\nSaphan Sung           7.4410e-01 -1.4378e-02  1.4747e-01  1.9751e+00\nBang Bo               2.1695e+00 -1.8681e-02  3.4795e-01  3.7095e+00\nKhan Na Yao          -4.4722e-02 -2.3052e-02  3.3734e-01 -3.7310e-02\nTaling Chan          -1.2591e-02 -2.3382e-02  2.3763e-01  2.2136e-02\nBang Sao Thong        2.9810e+00 -2.3382e-02  5.8570e-01  3.9257e+00\nPhra Pradaeng        -5.8509e-01 -3.1998e-02  2.7807e-01 -1.0489e+00\nBang Phli             2.3769e+00 -4.0427e-02  4.7760e-01  3.4978e+00\nPrawet                1.6089e+00 -4.2186e-02  4.9747e-01  2.3410e+00\nLam Luk Ka            1.0605e-02 -5.0323e-02  5.8839e-01  7.9431e-02\nKhlong Luang         -1.6589e-01 -7.2197e-02  1.2714e+00 -8.3095e-02\nThawi Watthana        3.4609e-01 -9.7330e-02  1.0817e+00  4.2635e-01\nMueang Samut Sakhon  -4.0011e-01 -1.3165e-01  2.1698e+00 -1.8225e-01\nLat Krabang           3.2578e+00 -1.6980e-01  1.4670e+00  2.8299e+00\n                     Pr.z....E.Ii..\nPhra Nakhon                  0.0211\nDusit                        0.0802\nPom Prap Sattru Phai         0.0879\nSamphanthawong               0.0883\nBangkok Yai                  0.4049\nNong Khaem                   0.1451\nKhlong San                   0.0514\nBangkok Noi                  0.4301\nThon Buri                    0.0746\nPhasi Charoen                0.7766\nPhra Khanong                 0.4983\nDin Daeng                    0.3664\nVadhana                      0.1741\nBang Rak                     0.0886\nSathon                       0.1317\nBang Sue                     0.2160\nBang Kapi                    0.5380\nBang Kho Laem                0.1697\nBueng Kum                    0.6607\nBang Phlat                   0.3234\nNong Suea                    0.0156\nThung Khru                   0.6162\nHuai Khwang                  0.1280\nWang Thonglang               0.2709\nLak Si                       0.5715\nDon Tum                      0.7498\nRatchathewi                  0.0956\nKhlong Toei                  0.5500\nPathum Wan                   0.0304\nBang Kruai                   0.4470\nRat Burana                   0.7227\nSai Noi                      0.6190\nNong Chok                    0.0076\nPhutthamonthon               0.5976\nSam Khok                     0.2957\nLat Phrao                    0.2039\nDon Mueang                   0.6494\nKrathum Baen                 0.2905\nMin Buri                     0.0103\nBang Na                      0.0280\nPhaya Thai                   0.1696\nKamphaeng Saen               0.7380\nLat Lum Kaeo                 0.7466\nPhra Samut Chedi             0.3498\nBang Bon                     0.3619\nBang Len                     0.2869\nNakhon Chai Si               0.7890\nBan Phaeo                    0.0600\nBang Yai                     0.5873\nBang Khen                    0.7366\nMueang Pathum Thani          0.1003\nYan Nawa                     0.6492\nChom Thong                   0.2882\nChatuchak                    0.1063\nSai Mai                      0.4624\nSuan Luang                   0.9902\nMueang Nonthaburi            0.4984\nKhlong Sam Wa                0.3550\nPak Kret                     0.5964\nBang Bua Thong               0.6717\nMueang Nakhon Pathom         0.6849\nMueang Samut Prakan          0.0789\nSam Phran                    0.7213\nBang Khun Thian              0.4027\nBang Khae                    0.2954\nThanyaburi                   0.0689\nSaphan Sung                  0.0483\nBang Bo                      0.0002\nKhan Na Yao                  0.9702\nTaling Chan                  0.9823\nBang Sao Thong               0.0001\nPhra Pradaeng                0.2942\nBang Phli                    0.0005\nPrawet                       0.0192\nLam Luk Ka                   0.9367\nKhlong Luang                 0.9338\nThawi Watthana               0.6698\nMueang Samut Sakhon          0.8554\nLat Krabang                  0.0047\n\n\n\n\n1.4.4.4 Mapping the local Moran’s I\nBefore we map the local Moran’s I map, it is wise to append the local Moran’s data-frame (localMI) onto our SpatialPolygonDataFrame.\n\nbmr.localMI &lt;- cbind(boundary_with_accident_count,localMI) %&gt;%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\nWe now make use of the tmap package and its choropleth mapping functions to plot the local Moran’s I values.\n\ntm_shape(bmr.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\nInterpreting Moran Value:\n\nValues lesser than 0 indicate negative spatial autocorrelation. (i.e: high accident areas are near low accident areas.)\nValue equal to 0 indicates random spatial distribution (No spatial autocorrelation).\nValues greater than 0 indicate spatial autocorrelation.\n\n\n\n\n1.4.4.5 Mapping Local Moran’s I p-values\nThe Choropleth reveals the presence of both positive, as well as negative I values. This indicates that there are varying levels of spatial autocorrelation, however, we must examine the p-values for these I values to check for statistical significance.\nWe use the tmap package to draw a choropleth map of Moran’s I p-values.\n\ntm_shape(bmr.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\nFrom the above we can infer that generally the local moran value ranges from -1 to 1. The biggest stand outs are:\n\nNong Suea, at the top right corner of the above map, seems to be absolutely dissimilar to its neighbors as indicated by its local Moran Value being of the highest magnitude. From our earlier analysis, we infer that this region actually has significantly fewer accidents than its neighbors.\nThe South-East region of the Bangkok Metropolitan Region has very high local Moran Values, indicating that the districts all showcase similar characteristics. They exhibit spatial clustering.\n\n\n\n1.4.4.6 Mapping both local Moran’s I values and p-values\nIn the interest of easier analysis and interpretation, we plot the two maps next to each other.\n\nlocalMI.map &lt;- tm_shape(bmr.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\npvalue.map &lt;- tm_shape(bmr.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#hot-and-cold-spot-areas",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#hot-and-cold-spot-areas",
    "title": "Take Home Exercise 1",
    "section": "1.4.5 Hot and Cold Spot Areas",
    "text": "1.4.5 Hot and Cold Spot Areas\n\n1.4.5.1 Getis and Ord’s G-Statistics\nAn alternative spatial statistic used to detect spatial anomalies is the Getis-Ord G-statistic (Getis and Ord, 1972; Ord and Getis, 1995). This method examines spatial relationships within a defined proximity to identify clusters of high or low values. Statistically significant hotspots are areas where high values are spatially clustered, meaning that not only do these areas have high values, but their neighboring areas also exhibit similarly high values.\nThe analysis involves three key steps:\n\nDeriving the spatial weight matrix: This defines the spatial relationships between areas, specifying which locations are considered neighbors based on proximity.\nComputing the Gi statistic: This step calculates the G-statistic for each location, identifying regions where values are significantly higher or lower than expected.\nMapping the Gi statistics: The results are visualized to reveal spatial patterns of high-value clusters (hotspots) and low-value clusters (cold spots).\n\nThis approach is useful for identifying localized patterns of spatial clustering and detecting significant anomalies in the data.\n\n\n1.4.5.2 Deriving Distance Based Weight Matrix\nWe start by defining a new set of neighbors. While the spatial autocorrelation considered units which shared borders, for Getis-Ord, we will define the neighbors based on distance.\n\nThere are two types of distance-based proximity matrices:\n\nFixed Distance Weight Matrix\nAdaptive Distance Weight Matrix\n\n\nBefore creating our connectivity graph, we need to assign a point to each polygon. This requires more than simply running st_centroid() on the us.bound spatial object. Specifically, we need to extract the coordinates into a separate data frame. We have already done this earlier and stored them under the name coords.\nMapping functions apply a specific operation to each element of a vector and return a vector of the same length. In our case, the input vector will be the geometry column from us.bound, and the function we’ll apply is st_centroid(). We’ll use the map_dbl variation from the purrr package, which is designed to return numeric (double) values.\nTo extract the longitude values, we’ll map the st_centroid() function over the geometry column and use double bracket notation [[]] with 1 to access the first element of each centroid, which corresponds to the longitude.\nFor more detailed information, you can refer to the map documentation here.\n\n1.4.5.2.1 Determine the Cut-off Distance\nTo determine the upper limit for the distance band, we follow these steps:\n\nFind the k-nearest neighbors: Use the knearneigh() function from the spdep package. This function returns a matrix that contains the indices of points corresponding to the k-nearest neighbors for each observation.\nConvert to a neighbors list: Take the k-nearest neighbors object returned by knearneigh() and convert it into a neighbors list (class nb) by using the knn2nb() function. This generates a list of integer vectors, where each vector contains the region numbers corresponding to its neighbors.\nCalculate neighbor distances: Use the nbdists() function from spdep to calculate the distances between neighbors. The function returns the lengths of neighbor relationship edges in the units of the coordinates (e.g., kilometers if the coordinates are geographic).\nFlatten the distance list: The distances returned by nbdists() are stored in a list. Use the unlist() function to remove the list structure and return a single vector of distances.\n\nThis process helps identify the upper limit for a distance band by analyzing the distances between neighboring regions.\n\nk1 &lt;- knn2nb(knearneigh(coords))\nk1dists &lt;- unlist(nbdists(k1, coords, longlat = FALSE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1390    2805    4986    6259    8476   16797 \n\n\nFrom the above output, we can infer that the largest first-nearest neighbor distance is just under 17000M.\nUsing this as the upper threshold gives certainty that all units will have at least one neighbor.\n\n\n1.4.5.2.2 Computing fixed distance weight matrix\nWe implement the dnearneigh() function of the spdep package to compute the distance weight matrix.\n\nwm_d62 &lt;- dnearneigh(coords, 0, 17000, longlat = FALSE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 1766 \nPercentage nonzero weights: 28.29675 \nAverage number of links: 22.35443 \n\n\nAfter this, we implement the nb2listw() function to convert the nb object into spatial weights object.\nOn average, each region has approximately 22.3neighbors.\n\nwm62_lw &lt;- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 1766 \nPercentage nonzero weights: 28.29675 \nAverage number of links: 22.35443 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 19 20 21 22 23 25 26 27 29 31 32 \n 3  5  3  6  1  2  1  2  2  1  1  1  1  1  3  1  1  1  2  1  2  1  1  2  2  1 \n33 34 35 36 37 38 39 40 41 42 \n 1  1  5  1  4  4  8  4  1  2 \n3 least connected regions:\n66 71 79 with 1 link\n2 most connected regions:\n14 37 with 42 links\n\nWeights style: B \nWeights constants summary:\n   n   nn   S0   S1     S2\nB 79 6241 1766 3532 226656\n\n\n\n\n\n1.4.5.3 Computing Gi statistics using Fixed Distance\n\nfips &lt;- order(boundary_with_accident_count$accident_count)\ngi.fixed &lt;- localG(boundary_with_accident_count$accident_count, wm62_lw)\ngi.fixed\n\n [1] -3.35336397 -3.12912595  2.66840322 -3.40300611 -1.55553377 -1.60535680\n [7] -3.49157140 -3.33512452 -2.30441253  1.39585137  2.02857406 -3.14674976\n[13] -3.17369454 -3.11393349 -2.81776564 -2.72683627 -2.88374141 -3.09409303\n[19] -3.12869158 -2.97426998 -1.24486361 -2.45871841 -0.73868252 -3.41408938\n[25] -2.89311199 -3.10698762 -1.21501813 -3.40300611 -3.97875100 -3.49579305\n[31] -3.68769474  0.40369815 -2.86023380 -2.45892382 -2.82195856 -0.92940375\n[37] -3.00458192 -2.79839385 -3.02803442 -2.34863826 -2.70055541 -0.22060572\n[43] -0.64115983  0.20224677 -3.19200023  1.40767563 -2.13429423 -2.10096499\n[49] -2.78620527 -1.47043641  1.55439452  2.25397760  3.05249557 -3.47654632\n[55] -0.01782564  4.36180044 -2.68397915 -2.21092597  0.65770388 -0.78671988\n[61] -0.20919415 -1.51459191 -0.54373150  0.45951200  2.18029716  1.04197980\n[67] -0.32317456  0.39447801  1.04576806 -0.64165535 -0.63894290 -0.13934645\n[73] -0.31893930 -0.81293378 -1.00959192  0.67569728 -0.47712106  2.54803258\n[79]  3.18220373\nattr(,\"internals\")\n               Gi      E(Gi)        V(Gi)       Z(Gi) Pr(z != E(Gi))\n [1,] 0.272139227 0.51282051 0.0051513761 -3.35336397   7.983565e-04\n [2,] 0.288233482 0.51282051 0.0051513761 -3.12912595   1.753271e-03\n [3,] 0.136391769 0.05128205 0.0010173148  2.66840322   7.621273e-03\n [4,] 0.255432270 0.50000000 0.0051650300 -3.40300611   6.664879e-04\n [5,] 0.180171073 0.28205128 0.0042896392 -1.55553377   1.198190e-01\n [6,] 0.333924168 0.44871795 0.0051132094 -1.60535680   1.084153e-01\n [7,] 0.247971563 0.50000000 0.0052102341 -3.49157140   4.801881e-04\n [8,] 0.273448329 0.51282051 0.0051513761 -3.33512452   8.526121e-04\n [9,] 0.296456086 0.46153846 0.0051319328 -2.30441253   2.119950e-02\n[10,] 0.241985442 0.16666667 0.0029115761  1.39585137   1.627593e-01\n[11,] 0.224129353 0.12820513 0.0022360158  2.02857406   4.250169e-02\n[12,] 0.258016812 0.48717949 0.0053035095 -3.14674976   1.650962e-03\n[13,] 0.272139227 0.50000000 0.0051547652 -3.17369454   1.505120e-03\n[14,] 0.313468692 0.53846154 0.0052205800 -3.11393349   1.846111e-03\n[15,] 0.284889094 0.48717949 0.0051539569 -2.81776564   4.835909e-03\n[16,] 0.278838749 0.47435897 0.0051412089 -2.72683627   6.394476e-03\n[17,] 0.292251891 0.50000000 0.0051899304 -2.88374141   3.929813e-03\n[18,] 0.290720062 0.51282051 0.0051526678 -3.09409303   1.974156e-03\n[19,] 0.183188452 0.41025641 0.0052672775 -3.12869158   1.755865e-03\n[20,] 0.261070466 0.47435897 0.0051424981 -2.97426998   2.936866e-03\n[21,] 0.109258240 0.17948718 0.0031826485 -1.24486361   2.131819e-01\n[22,] 0.260782502 0.43589744 0.0050725786 -2.45871841   1.394339e-02\n[23,] 0.198059449 0.24358974 0.0037991399 -0.73868252   4.600998e-01\n[24,] 0.203309875 0.44871795 0.0051668746 -3.41408938   6.399558e-04\n[25,] 0.278947774 0.48717949 0.0051803995 -2.89311199   3.814453e-03\n[26,] 0.302696456 0.52564103 0.0051489035 -3.10698762   1.890043e-03\n[27,] 0.287300486 0.37179487 0.0048360434 -1.21501813   2.243592e-01\n[28,] 0.255432270 0.50000000 0.0051650300 -3.40300611   6.664879e-04\n[29,] 0.214054554 0.50000000 0.0051650300 -3.97875100   6.927825e-05\n[30,] 0.219772515 0.47435897 0.0053037027 -3.49579305   4.726551e-04\n[31,] 0.222076621 0.48717949 0.0051679573 -3.68769474   2.262949e-04\n[32,] 0.348255907 0.32051282 0.0047227618  0.40369815   6.864347e-01\n[33,] 0.268196569 0.47435897 0.0051953627 -2.86023380   4.233288e-03\n[34,] 0.270124805 0.44871795 0.0052752059 -2.45892382   1.393542e-02\n[35,] 0.244120853 0.44871795 0.0052565120 -2.82195856   4.773134e-03\n[36,] 0.139284608 0.19230769 0.0032547762 -0.92940375   3.526799e-01\n[37,] 0.322498456 0.53846154 0.0051664346 -3.00458192   2.659461e-03\n[38,] 0.247349276 0.44871795 0.0051780488 -2.79839385   5.135745e-03\n[39,] 0.282434515 0.50000000 0.0051624800 -3.02803442   2.461500e-03\n[40,] 0.181588505 0.34615385 0.0049095816 -2.34863826   1.884220e-02\n[41,] 0.138865303 0.32051282 0.0045243141 -2.70055541   6.922381e-03\n[42,] 0.179613165 0.19230769 0.0033113077 -0.22060572   8.253994e-01\n[43,] 0.251734311 0.29487179 0.0045266509 -0.64115983   5.214188e-01\n[44,] 0.295476190 0.28205128 0.0044061520  0.20224677   8.397238e-01\n[45,] 0.269990738 0.50000000 0.0051923603 -3.19200023   1.412912e-03\n[46,] 0.228125000 0.15384615 0.0027843582  1.40767563   1.592271e-01\n[47,] 0.246087091 0.39743590 0.0050286269 -2.13429423   3.281870e-02\n[48,] 0.123152307 0.25641026 0.0040229869 -2.10096499   3.564404e-02\n[49,] 0.144135802 0.33333333 0.0046111018 -2.78620527   5.332909e-03\n[50,] 0.174530498 0.26923077 0.0041477249 -1.47043641   1.414436e-01\n[51,] 0.137752297 0.07692308 0.0015314471  1.55439452   1.200903e-01\n[52,] 0.078208290 0.02564103 0.0005439157  2.25397760   2.419758e-02\n[53,] 0.259036145 0.11538462 0.0022146771  3.05249557   2.269471e-03\n[54,] 0.169802258 0.42307692 0.0053074689 -3.47654632   5.079165e-04\n[55,] 0.114558287 0.11538462 0.0021488926 -0.01782564   9.857780e-01\n[56,] 0.193237100 0.05128205 0.0010591808  4.36180044   1.289965e-05\n[57,] 0.205586331 0.39743590 0.0051093231 -2.68397915   7.275164e-03\n[58,] 0.217455164 0.37179487 0.0048731182 -2.21092597   2.704096e-02\n[59,] 0.174321909 0.14102564 0.0025628920  0.65770388   5.107284e-01\n[60,] 0.067540006 0.10256410 0.0019819543 -0.78671988   4.314459e-01\n[61,] 0.032644852 0.03846154 0.0007731295 -0.20919415   8.342967e-01\n[62,] 0.104971080 0.19230769 0.0033250748 -1.51459191   1.298758e-01\n[63,] 0.078550319 0.10256410 0.0019505280 -0.54373150   5.866262e-01\n[64,] 0.036267748 0.02564103 0.0005348167  0.45951200   6.458665e-01\n[65,] 0.100309499 0.03846154 0.0008046729  2.18029716   2.923544e-02\n[66,] 0.029702206 0.01282051 0.0002624904  1.04197980   2.974210e-01\n[67,] 0.052627500 0.06410256 0.0012607702 -0.32317456   7.465630e-01\n[68,] 0.064076731 0.05128205 0.0010519939  0.39447801   6.932282e-01\n[69,] 0.067548747 0.03846154 0.0007736300  1.04576806   2.956681e-01\n[70,] 0.010752688 0.02564103 0.0005383798 -0.64165535   5.210970e-01\n[71,] 0.002402356 0.01282051 0.0002658629 -0.63894290   5.228601e-01\n[72,] 0.046816770 0.05128205 0.0010268471 -0.13934645   8.891764e-01\n[73,] 0.041142416 0.05128205 0.0010107147 -0.31893930   7.497725e-01\n[74,] 0.006984324 0.02564103 0.0005266952 -0.81293378   4.162560e-01\n[75,] 0.018554918 0.05128205 0.0010508100 -1.00959192   3.126908e-01\n[76,] 0.117669813 0.08974359 0.0017081266  0.67569728   4.992329e-01\n[77,] 0.014813596 0.02564103 0.0005149838 -0.47712106   6.332759e-01\n[78,] 0.175209043 0.07692308 0.0014878977  2.54803258   1.083324e-02\n[79,] 0.064849332 0.01282051 0.0002673203  3.18220373   1.461590e-03\nattr(,\"cluster\")\n [1] Low  Low  Low  Low  Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[16] Low  Low  Low  High Low  High Low  Low  Low  Low  Low  Low  Low  Low  Low \n[31] Low  High Low  High Low  Low  Low  Low  Low  High Low  Low  High High Low \n[46] High Low  High Low  Low  High High High High Low  High High Low  Low  High\n[61] Low  High Low  High High Low  Low  High Low  High Low  Low  Low  Low  High\n[76] Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = boundary_with_accident_count$accident_count, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of the localG() function is a vector containing G or G* values, with the following attributes: - \"gstari\": Indicates whether the G* version of the statistic was used (TRUE or FALSE). - \"call\": Stores the function call. - \"class\": Set to \"localG\", identifying the object type.\nThe Gi statistic is represented as a Z-score, where larger values signify stronger clustering. The sign of the value indicates the type of cluster: positive values point to high-value clusters (hotspots), while negative values indicate low-value clusters (cold spots).\nTo merge the Gi values with their corresponding geographic data in the BMR spatial dataframe, use the following code to join the results to the boundary_with_accident_count sf object. This allows for the spatial visualization of clusters within the geographic data.\n\nbmr.gi &lt;- cbind(boundary_with_accident_count, as.matrix(gi.fixed)) %&gt;%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\n\nthe code chunk above actually performs three tasks. First, it convert the output vector (i.e. gi.fixed) into r matrix object by using as.matrix(). Next, cbind() is used to join bmr@data and gi.fixed matrix to produce a new SpatialPolygonDataFrame called bmr.gi. Lastly, the field name of the gi values is renamed to gstat_fixed by using rename().\n\nWe can now map the Gi values derived using the fixed-distance weight matrix.\n\nacc_count &lt;- qtm(boundary_with_accident_count, \"accident_count\")\n\nGimap &lt;-tm_shape(bmr.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(acc_count, Gimap, asp=1, ncol=2)\n\n\n\n\n\n\n\n\nFrom the above plot, we can infer that ‘hot spots’ tend to be neighboring regions and likewise for the cold spots too. We see more high value (hot) clusters in the South East region of the Bangkok Metropolitan Region- Near Samut Prakan. The Central Area, near Bangkok and Nonthaburi showcase more ‘cold spots’.\nDistricts Bang Phli, Bang Sao Thong, Bang Bo, Sinakharin, and Suwinthawong seem to be highly linked to each other based on accidents, all in the South-East region of the Bangkok Metropolitan Region."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "",
    "text": "We now focus on Global Measures of Spatial Autocorrelation (GMSA) with the help of the spdep package. Through this exercise we:\n\ncompute Global Spatial Autocorrelation (GSA) statistics by using appropriate functions of spdep package,\n\nplot Moran scatterplot,\ncompute and plot spatial correlogram using appropriate function of spdep package.\n\nprovide statistically correct interpretation of GSA statistics."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#performing-relational-join",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#performing-relational-join",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.3.1 Performing relational join",
    "text": "5.3.1 Performing relational join\nWe will update the attribute table of Hunan’s SpatialPolygonsDataFrame with the attribute fields of the hunan2012 data-frame. We can do this by using the left_join() function of the dplyr package.\n\nhunan &lt;- left_join(hunan,hunan2012) %&gt;%\n  select(1:4, 7, 15)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#computing-contiguity-spatial-weights",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#computing-contiguity-spatial-weights",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.5.1 Computing Contiguity Spatial Weights",
    "text": "5.5.1 Computing Contiguity Spatial Weights\nBefore computing the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area, the spatial weights are used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\nWe now implement the poly2nb() function of the spdep package to compute contiguity weight matrices for the study area selected.\nUsing this function, we are able to build a ‘neighbors list’ based on regions with contiguous boundaries.\nIn this function, we will pass an argument, ‘queen’, that can be set as either TRUE (default) or FALSE. If the ‘queen’ argument is not explicitly set to FALSE, the function returns a list of first order neighbors using the Queen criteria.\nYou may refer to the spdep package documentation here to learn more about its functions and arguments.\n\nwm_q &lt;- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nFrom the output above, we can infer that there are 88 area units in total in Hunan. The most connected area unit has 11 neighbors. There are two area units with just 1 neighbor, while 24 area units have 5 neighbors."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#row-standardized-weights-matrix",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#row-standardized-weights-matrix",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.5.2 Row-Standardized Weights Matrix",
    "text": "5.5.2 Row-Standardized Weights Matrix\nWe now need to assign weights to each neighboring polygon. We use equal weights (style=“W”), where each neighboring polygon is assigned a weight of 1 divided by the number of neighbors.\nThis means each neighboring county’s weight is calculated as 1/(# of neighbors), and these weights are then used to sum the weighted income values.\nWhile this method is intuitive for summarizing neighbors’ values, it has a drawback: polygons at the edges of the study area may rely on fewer neighbors, potentially skewing the spatial autocorrelation results.\n\nrswm_q &lt;- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\nThe nb2listw() function requires an input of class nb, representing a neighborhood object. The function’s two key arguments are style and zero.policy.\n\nThe style argument defines how the weights are calculated. It can take several values:\n\n\"B\": Binary coding, where weights are either 0 or 1.\n\"W\": Row-standardized, where the sum of weights across all neighbors equals 1.\n\"C\": Globally standardized, where the sum of weights across all neighbors equals the total number of neighbors.\n\"U\": A variation of \"C\", where weights are normalized by the number of neighbors.\n\"S\": A variance-stabilizing scheme proposed by Tiefelsdorf et al. (1999), which adjusts weights based on the number of neighbors.\n\nThe zero.policy argument, when set to TRUE, handles regions with no neighbors by assigning them a weight vector of zero length. This results in a spatial lag value of zero for regions without neighbors, which may or may not be a suitable assumption depending on the context. For such regions, the spatially lagged value is computed as the sum of the products of a zero vector with any numerical vector x, effectively setting the lagged value to zero for those regions."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#marons-i-test",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#marons-i-test",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.6.1 Maron’s I test",
    "text": "5.6.1 Maron’s I test\nThe hypotheses for the test are as follows:\n\nH0: Regions with similar GDP Per Capita are randomly distributed.\nH1: Regions with similar GDP Per Capita are not randomly distributed and exhibit spatial clustering.\n\n\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nFrom the output above, we can infer the following:\n\nThe p-value (1.095e-06)&lt;0.05, indicating that the observed spatial autocorrelation is statistically significant.\nMoran’s I statistic: The observed value of 0.3007 indicates positive spatial autocorrelation, meaning that regions with similar GDP Per Capita are more likely to be located near each other.\n\nSince Moran’s I Statistic is significantly greater than what we would expect in a randomly distributed region. There is significant evidence to reject H0 and conclude that there is indeed spatial clustering with regards to GDP Per Capita in Hunan."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#computing-monte-carlo-morans-i",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#computing-monte-carlo-morans-i",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.6.2 Computing Monte Carlo Moran’s I",
    "text": "5.6.2 Computing Monte Carlo Moran’s I\nWe now implement the moran.mc() function of the spdep package. In this scenario, we will run 1000 simulations.\n\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nBased on the above output, p-value (0.001)&lt;0.05, thus we can reject the null hypothesis at a 5% significance level and conclude that there is indeed spatial clustering."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#visualizing-monte-carlo-morans-i",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#visualizing-monte-carlo-morans-i",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.6.3 Visualizing Monte Carlo Moran’s I",
    "text": "5.6.3 Visualizing Monte Carlo Moran’s I\nWe can visualize the test statistics obtained from the simulation above by implementing the hist() and abline() functions of R graphics.\n\nSummary StatisticsThe Plotggplot2 method\n\n\nWe first calculate the mean and variance, and obtain the summary statistics.\n\nmean(bperm$res[1:999])\n\n[1] -0.01504572\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004371574\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n\n\n\n\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\n\n\n\n\nFrom the above, we can infer that over half of all simulations indicate a negative value for Moran’s I statistic. Generally, a negative value indicates that dissimilar regions are located next to each other. (i.e: regions with dissimilar GDP Per Capita are located next to each other)\n\n\nWe can also use ggplot2 package to plot the above.\n\ndata &lt;- data.frame(simulated_moran = bperm$res)\n\nggplot(data, aes(x = simulated_moran)) +\n  geom_histogram(binwidth = (max(data$simulated_moran) - min(data$simulated_moran)) / 20, \n                 fill = \"lightblue\", color = \"black\") +\n  geom_vline(xintercept = 0, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"Simulated Moran's I\", \n       y = \"Frequency\",\n       title = \"Histogram of Simulated Moran's I\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\nIf Morans I Statistic is = 0, there is Random Spatial Distribution."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#computing-monte-carlo-gearys-c",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#computing-monte-carlo-gearys-c",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.7.1 Computing Monte Carlo Geary’s C",
    "text": "5.7.1 Computing Monte Carlo Geary’s C\nWe implement the the geary.mc() function of the spdep package to conduct 1000 simulations.\n\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nWe can infer that there is sufficient evidence to reject the null hypothesis (as p-value (0.001)&lt;0.05) and conclude that there is indeed Positive Spatial Autocorrelation (as statistic= 0.691.)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#visualizing-monte-carlo-gearys-c",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05a.html#visualizing-monte-carlo-gearys-c",
    "title": "Hands On Exercise 5- Global Measures of Spatial Autocorrelation",
    "section": "5.7.2 Visualizing Monte Carlo Geary’s C",
    "text": "5.7.2 Visualizing Monte Carlo Geary’s C\n\nSummary StatisticsThe plot\n\n\n\nmean(bperm$res[1:999])\n\n[1] 1.003309\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.006955922\n\n\n\nsummary(bperm$res[1:999])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7645  0.9435  1.0044  1.0033  1.0565  1.2883 \n\n\n\n\n\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n\n\n\n\n\n\n\n\nFrom the plot, we infer that out of the 1000 simulations the value of the statistic is distributed approximately normally, however generally values are close to 1 indicating a lack of spatial autocorrelation."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "",
    "text": "Local Measures of Spatial Autocorrelation (LMSA) focus on the spatial relationships between individual observations and their neighboring areas, rather than summarizing these relationships across an entire map. Unlike global summary statistics, LMSA provides localized scores that reveal the spatial structure within the data. Despite this difference, the underlying intuition behind these local metrics is similar to that of global ones. In fact, some global measures can be broken down into their local counterparts. For example, Local Indicators of Spatial Association (LISA) are derived from global measures of spatial autocorrelation.\nIn addition to LISA, another important LMSA is the Getis-Ord Gi-statistic, which offers complementary insights. Both LISA and Getis-Ord’s Gi-statistics help us understand spatial patterns in geographically referenced data, providing valuable tools for localized spatial analysis."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#performing-relational-join",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#performing-relational-join",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.10.1 Performing relational join",
    "text": "5.10.1 Performing relational join\nWe will update the attribute table of Hunan’s SpatialPolygonsDataFrame with the attribute fields of the hunan2012 data-frame. We can do this by using the left_join() function of the dplyr package.\n\nhunan &lt;- left_join(hunan,hunan2012) %&gt;%\n  select(1:4, 7, 15)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#computing-contiguity-spatial-weights",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#computing-contiguity-spatial-weights",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.12.1 Computing Contiguity Spatial Weights",
    "text": "5.12.1 Computing Contiguity Spatial Weights\nBefore computing the local spatial autocorrelation statistics, we need to construct a spatial weights of the study area, the spatial weights are used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\nWe now implement the poly2nb() function of the spdep package to compute contiguity weight matrices for the study area selected.\nUsing this function, we are able to build a ‘neighbors list’ based on regions with contiguous boundaries.\nIn this function, we will pass an argument, ‘queen’, that can be set as either TRUE (default) or FALSE. If the ‘queen’ argument is not explicitly set to FALSE, the function returns a list of first order neighbors using the Queen criteria.\nYou may refer to the spdep package documentation here to learn more about its functions and arguments.\n\nwm_q &lt;- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nFrom the output above, we can infer that there are 88 area units in total in Hunan. The most connected area unit has 11 neighbors. There are two area units with just 1 neighbor, while 24 area units have 5 neighbors."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#row-standardized-weights-matrix",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#row-standardized-weights-matrix",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.12.2 Row-Standardized Weights Matrix",
    "text": "5.12.2 Row-Standardized Weights Matrix\nWe now need to assign weights to each neighboring polygon. We use equal weights (style=“W”), where each neighboring polygon is assigned a weight of 1 divided by the number of neighbors.\nThis means each neighboring county’s weight is calculated as 1/(# of neighbors), and these weights are then used to sum the weighted income values.\nWhile this method is intuitive for summarizing neighbors’ values, it has a drawback: polygons at the edges of the study area may rely on fewer neighbors, potentially skewing the spatial autocorrelation results.\n\nrswm_q &lt;- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\n\nThe nb2listw() function requires an input of class nb, representing a neighborhood object. The function’s two key arguments are style and zero.policy.\n\nThe style argument defines how the weights are calculated. It can take several values:\n\n\"B\": Binary coding, where weights are either 0 or 1.\n\"W\": Row-standardized, where the sum of weights across all neighbors equals 1.\n\"C\": Globally standardized, where the sum of weights across all neighbors equals the total number of neighbors.\n\"U\": A variation of \"C\", where weights are normalized by the number of neighbors.\n\"S\": A variance-stabilizing scheme proposed by Tiefelsdorf et al. (1999), which adjusts weights based on the number of neighbors.\n\nThe zero.policy argument, when set to TRUE, handles regions with no neighbors by assigning them a weight vector of zero length. This results in a spatial lag value of zero for regions without neighbors, which may or may not be a suitable assumption depending on the context. For such regions, the spatially lagged value is computed as the sum of the products of a zero vector with any numerical vector x, effectively setting the lagged value to zero for those regions."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#computing-local-morans-i",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#computing-local-morans-i",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.12.3 Computing local Moran’s I",
    "text": "5.12.3 Computing local Moran’s I\nWe implement the localmoran() function of spdep compute the local Moran’s I statistic. This function helps us compute li values, given a set of zi values and a listw object providing neighbor weighting information for the polygon associated with the zi values.\nWe compute local Moran’s I of GDPPC2012 at the county level.\n\nfips &lt;- order(hunan$County)\nlocalMI &lt;- localmoran(hunan$GDPPC, rswm_q)\nhead(localMI)\n\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n\n\n\nlocalmoran() function returns a matrix of values whose columns are:\n\nIi: the local Moran’s I statistics\nE.Ii: the expectation of local moran statistic under the randomisation hypothesis\nVar.Ii: the variance of local moran statistic under the randomisation hypothesis\nZ.Ii:the standard deviate of local moran statistic\nPr(): the p-value of local moran statistic\n\n\nWe now use the printCoefmat() to display the content of the local Moran matrix that we created.\n\nprintCoefmat(data.frame(\n  localMI[fips,], \n  row.names=hunan$County[fips]),\n  check.names=FALSE)\n\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -7.2467e-02         0.9422\nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791e+00         0.1391\nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -6.6269e-02         0.9472\nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185e+00         0.2230\nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  1.2932e-01         0.8971\nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -7.6828e-02         0.9388\nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590e+00         0.0008\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895e+00         0.1119\nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  6.8299e-01         0.4946\nCili           7.3176e-02 -1.6747e-03  4.7902e-02  3.4200e-01         0.7324\nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297e+00         0.3032\nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159e+00         0.1882\nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338e+00         0.1023\nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  5.1198e-01         0.6087\nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -9.5104e-01         0.3416\nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305e+00         0.3028\nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  7.7931e-01         0.4358\nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  2.6266e-01         0.7928\nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  1.2742e-01         0.8986\nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  4.6294e-01         0.6434\nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -2.5618e-01         0.7978\nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  4.3486e-01         0.6637\nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678e+00         0.2856\nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -4.7503e-02         0.9621\nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  5.4072e-01         0.5887\nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  7.9685e-01         0.4255\nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -5.3633e-01         0.5917\nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204e+00         0.3076\nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  7.1800e-01         0.4728\nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759e+00         0.2396\nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -1.9667e-02         0.9843\nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543e+00         0.1756\nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  4.4972e-01         0.6529\nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  2.3422e-01         0.8148\nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623e+00         0.2451\nLi             1.0225e-03 -2.4048e-07  5.1060e-06  4.5260e-01         0.6508\nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467e+00         0.2952\nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335e+00         0.0329\nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  3.9086e-01         0.6959\nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -1.7676e-01         0.8597\nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  1.3634e-01         0.8916\nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972e+00         0.0052\nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787e+00         0.0376\nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690e+00         0.1710\nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  9.9561e-01         0.3194\nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  7.1663e-01         0.4736\nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715e+00         0.0004\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -1.0988e-01         0.9125\nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274e+00         0.0676\nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  7.5356e-01         0.4511\nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698e+00         0.0000\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  7.6396e-01         0.4449\nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  6.7712e-01         0.4983\nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -7.1814e-01         0.4727\nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  9.7972e-01         0.3272\nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510e+00         0.1468\nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583e+00         0.0631\nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807e+00         0.0928\nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -4.7729e-01         0.6332\nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  6.5174e-02         0.9480\nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  8.5358e-01         0.3933\nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544e+00         0.0637\nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002e+00         0.0357\nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  5.0903e-01         0.6107\nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582e+00         0.2900\nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873e+00         0.0001\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935e+00         0.0283\nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213e+00         0.0000\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092e+00         0.0704\nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539e+00         0.0507\nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  4.2409e-01         0.6715\nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  2.6667e-01         0.7897\nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502e+00         0.1211\nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  1.9289e-01         0.8470\nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -6.8395e-03         0.9945\nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726e+00         0.1699\nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -6.8667e-01         0.4923\nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202e+00         0.2224\nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795e+00         0.1390\nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409e+00         0.2539\nYou            7.8750e-02 -7.2728e-03  1.2116e-01  2.4714e-01         0.8048\nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  6.9181e-03         0.9945\nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121e+00         0.0700\nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  8.6085e-01         0.3893\nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  9.2214e-01         0.3565\nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855e+00         0.2358\nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688e+00         0.0001\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -7.0144e-01         0.4830\n\n\n\n5.12.3.1 Mapping the local Moran’s I\nBefore we map the local Moran’s I map, it is wise to append the local Moran’s data-frame (localMI) onto the Hunan SpatialPolygonDataFrame.\n\nhunan.localMI &lt;- cbind(hunan,localMI) %&gt;%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\n\n5.12.3.2 Mapping Local Moran’s I values\nWe now make use of the tmap package and its choropleth mapping functions to plot the local Moran’s I values.\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n5.12.3.3 Mapping Local Moran’s I p-values.\nThe Choropleth reveals the presence of both positive, as well as negative I values. This indicates that there are varying levels of spatial autocorrelation, however, we must examine the p-values for these I values to check for statistical significance.\nWe use the tmap package to draw a choropleth map of Moran’s I p-values.\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n5.12.3.4 Mapping both local Moran’s I values and p-values.\nIn the interest of easier analysis and interpretation, we plot the two maps next to each other.\n\nlocalMI.map &lt;- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\npvalue.map &lt;- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#plotting-moran-scatterplot",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#plotting-moran-scatterplot",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.12.1 Plotting Moran Scatterplot",
    "text": "5.12.1 Plotting Moran Scatterplot\nThe Moran Scatterplot depicts the relationship between the values of the chosen attribute at each location and the average value of the same attribute at neighboring locations.\nWe will implement the moran.plot() function of the spdep package to create the plot.\n\nnci &lt;- moran.plot(hunan$GDPPC, rswm_q,\n                  labels=as.character(hunan$County), \n                  xlab=\"GDPPC 2012\", \n                  ylab=\"Spatially Lag GDPPC 2012\")\n\n\n\n\n\n\n\n\n\nNotice that the plot is split in 4 quadrants.\nThe top right corner belongs to areas that have high GDPPC and are surrounded by other areas that have the average level of GDPPC."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#plotting-moran-scatterplot-with-standardised-variable",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#plotting-moran-scatterplot-with-standardised-variable",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.12.2 Plotting Moran Scatterplot with Standardised variable",
    "text": "5.12.2 Plotting Moran Scatterplot with Standardised variable\nWe first implement the scale() function to center and scale the variable. Here, centering is done by subtracting the mean (omitting NAs) from the corresponding columns, and scaling is done by dividing the (centered) variable by their standard deviations.\n\nhunan$Z.GDPPC &lt;- scale(hunan$GDPPC) %&gt;% \n  as.vector \n\n\nNote that the as.vector() function is added so that we get a vector as the output. This allows us to map it neatly into our data-frame.\n\nWe can now plot the Moran scatterplot again by using the code chunk below.\n\nnci2 &lt;- moran.plot(hunan$Z.GDPPC, rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab=\"z-GDPPC 2012\", \n                   ylab=\"Spatially Lag z-GDPPC 2012\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#preparing-lisa-map-classes",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#preparing-lisa-map-classes",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.12.3 Preparing LISA map classes",
    "text": "5.12.3 Preparing LISA map classes\nWe now prepare the data in order to facilitate plotting a LISA Cluster Map.\n\nquadrant &lt;- vector(mode=\"numeric\",length=nrow(localMI))\n\nNow, we will derive the spatially lagged variable of interest (i.e: GDPPC) and center the spatially lagged variable around its mean.\n\nhunan$lag_GDPPC &lt;- lag.listw(rswm_q, hunan$GDPPC)\nDV &lt;- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     \n\nNow, we work on centering the local Moran around the mean.\n\nLM_I &lt;- localMI[,1] - mean(localMI[,1])    \n\nWe set the significance level for the Local Moran in the code chunk below.\n\nsignif &lt;- 0.05       \n\nThe following code chunk defines the four categories (low-low (1), low-high (2), high-low (3), high-high (4))\n\nquadrant[DV &lt;0 & LM_I&gt;0] &lt;- 1\nquadrant[DV &gt;0 & LM_I&lt;0] &lt;- 2\nquadrant[DV &lt;0 & LM_I&lt;0] &lt;- 3  \nquadrant[DV &gt;0 & LM_I&gt;0] &lt;- 4      \n\nFinally, we place the non-significant Moran in the category 0.\n\nquadrant[localMI[,5]&gt;signif] &lt;- 0\n\n\nYou can simply write all of this in one code chunk as shown below:\n\nquadrant &lt;- vector(mode=\"numeric\",length=nrow(localMI))\nhunan$lag_GDPPC &lt;- lag.listw(rswm_q, hunan$GDPPC)\nDV &lt;- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     \nLM_I &lt;- localMI[,1]   \nsignif &lt;- 0.05       \nquadrant[DV &lt;0 & LM_I&gt;0] &lt;- 1\nquadrant[DV &gt;0 & LM_I&lt;0] &lt;- 2\nquadrant[DV &lt;0 & LM_I&lt;0] &lt;- 3  \nquadrant[DV &gt;0 & LM_I&gt;0] &lt;- 4    \nquadrant[localMI[,5]&gt;signif] &lt;- 0"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#plotting-lisa-map",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#plotting-lisa-map",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.12.4 Plotting LISA Map",
    "text": "5.12.4 Plotting LISA Map\nWe now use the tmap package to plot the LISA Map.\n\nhunan.localMI$quadrant &lt;- quadrant\ncolors &lt;- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters &lt;- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)\n\n\n\n\n\n\n\n\nIn the interest of easier visualization and interpretation, we plot the GDPPC and their corresponding quadrants next to each other.\n\ngdppc &lt;- qtm(hunan, \"GDPPC\")\n\nhunan.localMI$quadrant &lt;- quadrant\ncolors &lt;- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters &lt;- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap &lt;- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5)\n\ntmap_arrange(gdppc, LISAmap, \n             asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\nFrom the LISA map, we can see that the regions in the top 2 quadrants are next to each others, indicating positive spatial autocorrelation."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#getis-and-ords-g-statistics",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#getis-and-ords-g-statistics",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.13.1 Getis and Ord’s G-Statistics",
    "text": "5.13.1 Getis and Ord’s G-Statistics\nAn alternative spatial statistic used to detect spatial anomalies is the Getis-Ord G-statistic (Getis and Ord, 1972; Ord and Getis, 1995). This method examines spatial relationships within a defined proximity to identify clusters of high or low values. Statistically significant hotspots are areas where high values are spatially clustered, meaning that not only do these areas have high values, but their neighboring areas also exhibit similarly high values.\nThe analysis involves three key steps:\n\nDeriving the spatial weight matrix: This defines the spatial relationships between areas, specifying which locations are considered neighbors based on proximity.\nComputing the Gi statistic: This step calculates the G-statistic for each location, identifying regions where values are significantly higher or lower than expected.\nMapping the Gi statistics: The results are visualized to reveal spatial patterns of high-value clusters (hotspots) and low-value clusters (cold spots).\n\nThis approach is useful for identifying localized patterns of spatial clustering and detecting significant anomalies in the data."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#deriving-distance-based-weight-matrix",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#deriving-distance-based-weight-matrix",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.13.2 Deriving Distance Based Weight Matrix",
    "text": "5.13.2 Deriving Distance Based Weight Matrix\nWe start by defining a new set of neighbors. While the spatial autocorrelation considered units which shared borders, for Getis-Ord, we will define the neighbors based on distance.\n\nThere are two types of distance-based proximity matrices:\n\nFixed Distance Weight Matrix\nAdaptive Distance Weight Matrix\n\n\n\n5.13.2.1 Deriving distance-based weight matrix\nBefore creating our connectivity graph, we need to assign a point to each polygon. This requires more than simply running st_centroid() on the us.bound spatial object. Specifically, we need to extract the coordinates into a separate data frame. To achieve this, we’ll use a mapping function.\nMapping functions apply a specific operation to each element of a vector and return a vector of the same length. In our case, the input vector will be the geometry column from us.bound, and the function we’ll apply is st_centroid(). We’ll use the map_dbl variation from the purrr package, which is designed to return numeric (double) values.\nTo extract the longitude values, we’ll map the st_centroid() function over the geometry column and use double bracket notation [[]] with 1 to access the first element of each centroid, which corresponds to the longitude.\nFor more detailed information, you can refer to the map documentation here.\n\nlongitude &lt;- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nWe do the same for latitude, but with one key difference- we access the second value per centroid with [[2]] instead of [[1]].\n\nlatitude &lt;- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nNow that we have obtained both latitude and longitude, we will put them into the same object using the cbind() function.\n\ncoords &lt;- cbind(longitude, latitude)\n\n\n\n5.13.2.2 Determine the cut-off distance\nTo determine the upper limit for the distance band, we follow these steps:\n\nFind the k-nearest neighbors: Use the knearneigh() function from the spdep package. This function returns a matrix that contains the indices of points corresponding to the k-nearest neighbors for each observation.\nConvert to a neighbors list: Take the k-nearest neighbors object returned by knearneigh() and convert it into a neighbors list (class nb) by using the knn2nb() function. This generates a list of integer vectors, where each vector contains the region numbers corresponding to its neighbors.\nCalculate neighbor distances: Use the nbdists() function from spdep to calculate the distances between neighbors. The function returns the lengths of neighbor relationship edges in the units of the coordinates (e.g., kilometers if the coordinates are geographic).\nFlatten the distance list: The distances returned by nbdists() are stored in a list. Use the unlist() function to remove the list structure and return a single vector of distances.\n\nThis process helps identify the upper limit for a distance band by analyzing the distances between neighboring regions.\n\nk1 &lt;- knn2nb(knearneigh(coords))\nk1dists &lt;- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nFrom the output above, we can infer that the largest first-nearest neighbor distance is 61.79KM- using this as the upper threshold gives certainty that all units will have at least one neighbor.\n\n\n5.13.2.3 Computing fixed distance weight matrix\nWe implement the dnearneigh() function of the spdep package to compute the distance weight matrix.\n\nwm_d62 &lt;- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nAfter this, we implement the nb2listw() function to convert the nb object into spatial weights object.\nOn average, each region has approximately 3.68 neighbors.\n\nwm62_lw &lt;- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#computing-adaptive-distance-weight-matrix",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05b.html#computing-adaptive-distance-weight-matrix",
    "title": "Hands On Exercise 5- Part 2- Local Measures of Spatial Autocorrelation",
    "section": "5.13.3 Computing Adaptive Distance Weight Matrix",
    "text": "5.13.3 Computing Adaptive Distance Weight Matrix\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually urban areas) tend to have more neighbours and the less densely settled areas (usually the rural areas) tend to have lesser neighbours. Having many neighbours smoothes the neighbour relationship across more neighbours.\nIt is possible to control the numbers of neighbours directly using k-nearest neighbours, either by accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.\n\nknn &lt;- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\nAfter this, we implement the nb2list2() function to convert the nb object into a spatial weights object.\n\nknn_lw &lt;- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "",
    "text": "In this hands-on exercise, we will delineate homogeneous regions by using geographically referenced multivariate data.\nThere are two analytical techniques that we will focus on for this:\n\nHierarchical Cluster Analysis\nSpatially Constrained Cluster Analysis"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#importing-the-geospatial-data",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#importing-the-geospatial-data",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.2.1 Importing the Geospatial Data",
    "text": "6.2.1 Importing the Geospatial Data\nWe will first import the Myanmar Township Boundary GIS data-set and its attribute table into our environment. We implement the st_read() function of the sf package for this.\nThe data is in ESRI Shapefile format.\n\nImporting the dataStructure of the data-frameglimpse\n\n\n\nshan_sf &lt;- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %&gt;%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %&gt;%\n  select(c(2:7))\n\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex06\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n\n\nFrom the output above, we infer that shan_sf is a simple-feature data-frame.\n\n\nWe get an overview of the contents of shan_sf by implementing the code chunk below.\n\nshan_sf\n\nSimple feature collection with 55 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE       DT   DT_PCODE        TS  TS_PCODE\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n\n\nWe infer that the data-frame conforms to Hadley Wickham’s Tidy Framework.\n\n\nAfter understanding that it conforms to the tidy framework, we can implement the glimpse() function to reveal the fields and data types.\n\nglimpse(shan_sf)\n\nRows: 55\nColumns: 7\n$ ST       &lt;chr&gt; \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (South)…\n$ ST_PCODE &lt;chr&gt; \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR014\", \"…\n$ DT       &lt;chr&gt; \"Mongmit\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Mongmit\", \"Ta…\n$ DT_PCODE &lt;chr&gt; \"MMR015D008\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", \"MMR0…\n$ TS       &lt;chr&gt; \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"Kalaw…\n$ TS_PCODE &lt;chr&gt; \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR01501…\n$ geometry &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((96.96001 23..., MULTIPOLYGON (((…\n\n\n\n\n\n\nHadley Wickham’s tidy framework refers to a consistent and coherent approach to data science in R. It emphasizes organizing data in a ‘tidy’ format where:\n\nEach variable is a column.\nEach observation is a row.\nEach type of observational unit forms a table.\n\nThis tidy data structure allows for easier manipulation, analysis, and visualization, and is supported by core packages like dplyr (data manipulation), tidyr (data tidying), and ggplot2 (data visualization) within the tidyverse collection."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#importing-the-aspatial-data",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#importing-the-aspatial-data",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.2.2 Importing the Aspatial Data",
    "text": "6.2.2 Importing the Aspatial Data\nWe now import the aspatial data-set using the read_csv() function of the readr package.\n\nImporting the DataSummary of the data-frame\n\n\n\nict &lt;- read_csv (\"data/aspatial/Shan-ICT.csv\")\n\n\n\nWe implement the summary() function to discover the summary statistics of the data-set.\n\nsummary(ict)\n\n District Pcode     District Name      Township Pcode     Township Name     \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n Total households     Radio         Television    Land line phone \n Min.   : 3318    Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711    1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685    Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369    Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471    3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604    Max.   :30176   Max.   :62388   Max.   :6736.0  \n  Mobile phone      Computer      Internet at home\n Min.   :  150   Min.   :  20.0   Min.   :   8.0  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0  \n Median : 3559   Median : 244.0   Median : 316.0  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#deriving-new-variables-using-dplyr",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#deriving-new-variables-using-dplyr",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.2.3 Deriving new variables using dplyr",
    "text": "6.2.3 Deriving new variables using dplyr\nIn our study, the unit of measurement of the values are number of households.\nUsing these values directly will be biased by the underlying numbers such as the total number of households. For example, the townships with relatively higher number of households will also have more households that own a TV.\nIn order to negate the effect of this bias, we derive a new variable, penetration rate, for each ICT variable.\n\nDeriving the new variableSummary Statistics\n\n\n\nict_derived &lt;- ict %&gt;%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %&gt;%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %&gt;%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %&gt;%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %&gt;%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %&gt;%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %&gt;%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n\n\n\n\nsummary(ict_derived)\n\n   DT_PCODE              DT              TS_PCODE              TS           \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n TT_HOUSEHOLDS       RADIO             TV           LLPHONE      \n Min.   : 3318   Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711   1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685   Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369   Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471   3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604   Max.   :30176   Max.   :62388   Max.   :6736.0  \n     MPHONE         COMPUTER         INTERNET         RADIO_PR     \n Min.   :  150   Min.   :  20.0   Min.   :   8.0   Min.   : 21.05  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0   1st Qu.:138.95  \n Median : 3559   Median : 244.0   Median : 316.0   Median :210.95  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2   Mean   :215.68  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5   3rd Qu.:268.07  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0   Max.   :484.52  \n     TV_PR         LLPHONE_PR       MPHONE_PR       COMPUTER_PR    \n Min.   :116.0   Min.   :  2.78   Min.   : 36.42   Min.   : 3.278  \n 1st Qu.:450.2   1st Qu.: 22.84   1st Qu.:190.14   1st Qu.:11.832  \n Median :517.2   Median : 37.59   Median :305.27   Median :18.970  \n Mean   :509.5   Mean   : 51.09   Mean   :314.05   Mean   :24.393  \n 3rd Qu.:606.4   3rd Qu.: 69.72   3rd Qu.:428.43   3rd Qu.:29.897  \n Max.   :842.5   Max.   :181.49   Max.   :735.43   Max.   :92.402  \n  INTERNET_PR     \n Min.   :  1.041  \n 1st Qu.:  8.617  \n Median : 22.829  \n Mean   : 30.644  \n 3rd Qu.: 41.281  \n Max.   :117.985"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#eda-using-statistical-graphics",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#eda-using-statistical-graphics",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.3.1 EDA using statistical graphics",
    "text": "6.3.1 EDA using statistical graphics\nWe now gain a better understanding of the distribution of the variables in the dataset by using appropriate EDA techniques, such as plotting histograms.\n\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\n\n\n\n\n\n\n\nUsing the box-plot allows us the gain a better understanding of the range and to detect the presence of outliers.\n\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n\n\n\n\n\n\n\n\nNow, we plot the distribution of the newly derived variables in ict_derived (penetration rate).\n\nHistogramBoxplot\n\n\n\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n\n\n\n\n\n\n\n\n\n\n\nWe see immediately that the skewness of the data is significantly lesser with our derived variables and there are also fewer outliers.\nWe now proceed to plot a few selected variables for to facilitate visualization.\nWe will first initialize plots as shown in the code chunk below.\n\nradio &lt;- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv &lt;- ggplot(data=ict_derived, \n             aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone &lt;- ggplot(data=ict_derived, \n             aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone &lt;- ggplot(data=ict_derived, \n             aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer &lt;- ggplot(data=ict_derived, \n             aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet &lt;- ggplot(data=ict_derived, \n             aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nNow, we implement the ggarrange() function of the ggpubr package to group these histograms together.\n\nggarrange(radio, tv, llphone, mphone, computer, internet, \n          ncol = 3, \n          nrow = 2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#eda-using-choropleth-maps",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#eda-using-choropleth-maps",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.3.2 EDA using Choropleth Maps",
    "text": "6.3.2 EDA using Choropleth Maps\n\n6.3.2.1 Joining the Geospatial and Aspatial data\nWe combine shan_sf and ict_derived. For this, we use the left_join() function of the dplyr package.\nshan_sf is used as the base data object and ict_derived is used as the join table.\nThe common key, necessary for a relational join, is TS_PCODE. We will then save this as an rds file.\n\nshan_sf &lt;- left_join(shan_sf, \n                     ict_derived, by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n  \n# write_rds(shan_sf, \"chap12/data/rds/shan_sf.rds\")\n\nWe now use the read_rds() function as shown below.\n\nshan_sf &lt;- read_rds(\"data/rds/shan_sf.rds\")\n\n\n\n6.3.2.2 Preparing a Choropleth Map\nTo have a brief overview of the distribution of the Radio Penetration rate of Shan State at the township level, we plot a choropleth map.\nWe implement the qtm() function of the tmap package.\n\nqtm(shan_sf, \"RADIO_PR\")\n\n\n\n\n\n\n\n\nTo account for potential bias in the distribution shown in the choropleth map due to the varying total number of households across townships, we will create two separate choropleth maps. The first map will depict the total number of households (i.e., TT_HOUSEHOLDS.map), while the second will show the total number of households with radios (i.e., RADIO.map). The following code chunk demonstrates this process.\n\nTT_HOUSEHOLDS.map &lt;- tm_shape(shan_sf) + \n  tm_fill(col = \"TT_HOUSEHOLDS\",\n          n = 5,\n          style = \"jenks\", \n          title = \"Total households\") + \n  tm_borders(alpha = 0.5) \n\nRADIO.map &lt;- tm_shape(shan_sf) + \n  tm_fill(col = \"RADIO\",\n          n = 5,\n          style = \"jenks\",\n          title = \"Number Radio \") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,\n             asp=NA, ncol=2)\n\n\n\n\n\n\n\n\nThe choropleth maps above clearly show that townships with a relatively larger number of households are also have a relatively higher radio ownership.\nWe now plot the choropleth maps showing the dsitribution of total number of households and Radio penetration rate.\n\ntm_shape(shan_sf) +\n    tm_polygons(c(\"TT_HOUSEHOLDS\", \"RADIO_PR\"),\n                style=\"jenks\") +\n    tm_facets(sync = TRUE, ncol = 2) +\n  tm_legend(legend.position = c(\"right\", \"bottom\"))+\n  tm_layout(outer.margins=0, asp=0)\n\n\n\n\n\n\n\n\nImmediately we see a difference to the previous maps, showing us the magnitude of the bias."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#extracting-the-target-variables",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#extracting-the-target-variables",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.1 Extracting the target variables",
    "text": "6.5.1 Extracting the target variables\nWe will start off by extracting the necessary variables from shan_sf. Do remember to select only one variable out of the highly correlated variables as determined above. We select COMPUTER_PR.\n\ncluster_vars &lt;- shan_sf %&gt;%\n  st_set_geometry(NULL) %&gt;%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n\n\nWe now change the index to be by township name instead of by row numbers.\n\nrow.names(cluster_vars) &lt;- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n\n               TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit     Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya     Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan     Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\nMabein       Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw         Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\nPekon         Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme     Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n\n\nWe now delete the TS.x field.\n\nshan_ict &lt;- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n\n          RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit   286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya   417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan   484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung  231.6499 541.7189   28.54454  249.4903    13.76255\nMabein    449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw     280.7624 611.6204   42.06478  408.7951    29.63160\nPekon     318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk  387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme   210.9548 601.1773   39.58267  372.4930    30.94709"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#data-standardization",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#data-standardization",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.2 Data Standardization",
    "text": "6.5.2 Data Standardization\nMultiple variables are used in cluster analysis and it is common for these variables to have different value ranges. In order to prevent the results from being skewed towards variables that have larger values, it is necessary to standardize the input variables before conducting clustering analysis. This will ensure that all variables equally contribute to the clustering process.\n\n6.5.2.1 Min-Max Standardization\nWe implement the normalize() function of the heatmaply package to standardize variables by using the Min-Max method.\n\nshan_ict.std &lt;- normalize(shan_ict)\nsummary(shan_ict.std)\n\n    RADIO_PR          TV_PR          LLPHONE_PR       MPHONE_PR     \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.2544   1st Qu.:0.4600   1st Qu.:0.1123   1st Qu.:0.2199  \n Median :0.4097   Median :0.5523   Median :0.1948   Median :0.3846  \n Mean   :0.4199   Mean   :0.5416   Mean   :0.2703   Mean   :0.3972  \n 3rd Qu.:0.5330   3rd Qu.:0.6750   3rd Qu.:0.3746   3rd Qu.:0.5608  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n  COMPUTER_PR     \n Min.   :0.00000  \n 1st Qu.:0.09598  \n Median :0.17607  \n Mean   :0.23692  \n 3rd Qu.:0.29868  \n Max.   :1.00000  \n\n\n\n\n6.5.2.2 Z-score Standardization\nWe implement the scale() function of Base R to standardize variables using the Z-score method.\n\nshan_ict.z &lt;- scale(shan_ict)\ndescribe(shan_ict.z)\n\n            vars  n mean sd median trimmed  mad   min  max range  skew kurtosis\nRADIO_PR       1 55    0  1  -0.04   -0.06 0.94 -1.85 2.55  4.40  0.48    -0.27\nTV_PR          2 55    0  1   0.05    0.04 0.78 -2.47 2.09  4.56 -0.38    -0.23\nLLPHONE_PR     3 55    0  1  -0.33   -0.15 0.68 -1.19 3.20  4.39  1.37     1.49\nMPHONE_PR      4 55    0  1  -0.05   -0.06 1.01 -1.58 2.40  3.98  0.48    -0.34\nCOMPUTER_PR    5 55    0  1  -0.26   -0.18 0.64 -1.03 3.31  4.34  1.80     2.96\n              se\nRADIO_PR    0.13\nTV_PR       0.13\nLLPHONE_PR  0.13\nMPHONE_PR   0.13\nCOMPUTER_PR 0.13\n\n\n\nIn the output above, we notice that the mean and standard deviation of the Z-score standardized clustering variables are 0 and 1 respectively.\n\nZ-score standardization should only be used if we can assume that all variables come from some Normal Distribution."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visualizing-the-standardized-clustering-variables",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visualizing-the-standardized-clustering-variables",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.3 Visualizing the Standardized Clustering Variables",
    "text": "6.5.3 Visualizing the Standardized Clustering Variables\nWe now produce some plots using the ggplot package to gain a better understanding of the distribution of the variables.\n\nHistogramsDensity\n\n\n\nr &lt;- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df &lt;- as.data.frame(shan_ict.std)\ns &lt;- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df &lt;- as.data.frame(shan_ict.z)\nz &lt;- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n\n\n\n\n\n\n\n\n\n\n\nr &lt;- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nshan_ict_s_df &lt;- as.data.frame(shan_ict.std)\ns &lt;- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nshan_ict_z_df &lt;- as.data.frame(shan_ict.z)\nz &lt;- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_density(color=\"black\",\n               fill=\"light blue\") +\n  ggtitle(\"Z-score Standardisation\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n\n\n\n\n\n\n\n\n\n\n\nWe see the effectiveness of standardization by minimizing the range and reducing the impact of bias significantly, making it easier to compare to other variables with different units or scales."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-proximity-matrix",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-proximity-matrix",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.4 Computing Proximity Matrix",
    "text": "6.5.4 Computing Proximity Matrix\nWe implement the dist() function of Base R to compute the proximity matrix.\nDist() supports six distance proximity calculations. The six are as follows:\n\nEuclidean (Default method): Measures the straight-line distance between two points in multi-dimensional space.\nMaximum (Chebyshev): Measures the greatest difference along any one dimension between two points.\nManhattan (City Block): Calculates the sum of absolute differences along each dimension, like navigating a grid.\nCanberra: A weighted version of the Manhattan distance, giving more emphasis to smaller differences.\nBinary: Computes distance based on the number of mismatches between binary variables.\nMinkowski: A generalized distance metric that includes Euclidean (p=2) and Manhattan (p=1) as special cases, depending on the power parameter ( p )."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#calculating-proximity-matrix",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#calculating-proximity-matrix",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "Calculating Proximity Matrix",
    "text": "Calculating Proximity Matrix\nWe calculate the proximity matrix below.\n\nproxmat &lt;- dist(shan_ict, method = 'euclidean')"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#overview",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#overview",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "Overview",
    "text": "Overview\nWe now check the contents of the matrix below.\n\nproxmat\n\n             Mongmit   Pindaya   Ywangan  Pinlaung    Mabein     Kalaw\nPindaya    171.86828                                                  \nYwangan    381.88259 257.31610                                        \nPinlaung    57.46286 208.63519 400.05492                              \nMabein     263.37099 313.45776 529.14689 312.66966                    \nKalaw      160.05997 302.51785 499.53297 181.96406 198.14085          \nPekon       59.61977 117.91580 336.50410  94.61225 282.26877 211.91531\nLawksawk   140.11550 204.32952 432.16535 192.57320 130.36525 140.01101\nNawnghkio   89.07103 180.64047 377.87702 139.27495 204.63154 127.74787\nKyaukme    144.02475 311.01487 505.89191 139.67966 264.88283  79.42225\nMuse       563.01629 704.11252 899.44137 571.58335 453.27410 412.46033\nLaihka     141.87227 298.61288 491.83321 101.10150 345.00222 197.34633\nMongnai    115.86190 258.49346 422.71934  64.52387 358.86053 200.34668\nMawkmai    434.92968 437.99577 397.03752 398.11227 693.24602 562.59200\nKutkai      97.61092 212.81775 360.11861  78.07733 340.55064 204.93018\nMongton    192.67961 283.35574 361.23257 163.42143 425.16902 267.87522\nMongyai    256.72744 287.41816 333.12853 220.56339 516.40426 386.74701\nMongkaing  503.61965 481.71125 364.98429 476.29056 747.17454 625.24500\nLashio     251.29457 398.98167 602.17475 262.51735 231.28227 106.69059\nMongpan    193.32063 335.72896 483.68125 192.78316 301.52942 114.69105\nMatman     401.25041 354.39039 255.22031 382.40610 637.53975 537.63884\nTachileik  529.63213 635.51774 807.44220 555.01039 365.32538 373.64459\nNarphan    406.15714 474.50209 452.95769 371.26895 630.34312 463.53759\nMongkhet   349.45980 391.74783 408.97731 305.86058 610.30557 465.52013\nHsipaw     118.18050 245.98884 388.63147  76.55260 366.42787 212.36711\nMonghsat   214.20854 314.71506 432.98028 160.44703 470.48135 317.96188\nMongmao    242.54541 402.21719 542.85957 217.58854 384.91867 195.18913\nNansang    104.91839 275.44246 472.77637  85.49572 287.92364 124.30500\nLaukkaing  568.27732 726.85355 908.82520 563.81750 520.67373 427.77791\nPangsang   272.67383 428.24958 556.82263 244.47146 418.54016 224.03998\nNamtu      179.62251 225.40822 444.66868 170.04533 366.16094 307.27427\nMonghpyak  177.76325 221.30579 367.44835 222.20020 212.69450 167.08436\nKonkyan    403.39082 500.86933 528.12533 365.44693 613.51206 444.75859\nMongping   265.12574 310.64850 337.94020 229.75261 518.16310 375.64739\nHopong     136.93111 223.06050 352.85844  98.14855 398.00917 264.16294\nNyaungshwe  99.38590 216.52463 407.11649 138.12050 210.21337  95.66782\nHsihseng   131.49728 172.00796 342.91035 111.61846 381.20187 287.11074\nMongla     384.30076 549.42389 728.16301 372.59678 406.09124 260.26411\nHseni      189.37188 337.98982 534.44679 204.47572 213.61240  38.52842\nKunlong    224.12169 355.47066 531.63089 194.76257 396.61508 273.01375\nHopang     281.05362 443.26362 596.19312 265.96924 368.55167 185.14704\nNamhkan    386.02794 543.81859 714.43173 382.78835 379.56035 246.39577\nKengtung   246.45691 385.68322 573.23173 263.48638 219.47071  88.29335\nLangkho    164.26299 323.28133 507.78892 168.44228 253.84371  67.19580\nMonghsu    109.15790 198.35391 340.42789  80.86834 367.19820 237.34578\nTaunggyi   399.84278 503.75471 697.98323 429.54386 226.24011 252.26066\nPangwaun   381.51246 512.13162 580.13146 356.37963 523.44632 338.35194\nKyethi     202.92551 175.54012 287.29358 189.47065 442.07679 360.17247\nLoilen     145.48666 293.61143 469.51621  91.56527 375.06406 217.19877\nManton     430.64070 402.42888 306.16379 405.83081 674.01120 560.16577\nMongyang   309.51302 475.93982 630.71590 286.03834 411.88352 233.56349\nKunhing    173.50424 318.23811 449.67218 141.58836 375.82140 197.63683\nMongyawng  214.21738 332.92193 570.56521 235.55497 193.49994 173.43078\nTangyan    195.92520 208.43740 324.77002 169.50567 448.59948 348.06617\nNamhsan    237.78494 228.41073 286.16305 214.33352 488.33873 385.88676\n               Pekon  Lawksawk Nawnghkio   Kyaukme      Muse    Laihka\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk   157.51129                                                  \nNawnghkio  113.15370  90.82891                                        \nKyaukme    202.12206 186.29066 157.04230                              \nMuse       614.56144 510.13288 533.68806 434.75768                    \nLaihka     182.23667 246.74469 211.88187 128.24979 526.65211          \nMongnai    151.60031 241.71260 182.21245 142.45669 571.97975 100.53457\nMawkmai    416.00669 567.52693 495.15047 512.02846 926.93007 429.96554\nKutkai     114.98048 224.64646 147.44053 170.93318 592.90743 144.67198\nMongton    208.14888 311.07742 225.81118 229.28509 634.71074 212.07320\nMongyai    242.52301 391.26989 319.57938 339.27780 763.91399 264.13364\nMongkaing  480.23965 625.18712 546.69447 586.05094 995.66496 522.96309\nLashio     303.80011 220.75270 230.55346 129.95255 313.15288 238.64533\nMongpan    243.30037 228.54223 172.84425 110.37831 447.49969 210.76951\nMatman     368.25761 515.39711 444.05061 505.52285 929.11283 443.25453\nTachileik  573.39528 441.82621 470.45533 429.15493 221.19950 549.08985\nNarphan    416.84901 523.69580 435.59661 420.30003 770.40234 392.32592\nMongkhet   342.08722 487.41102 414.10280 409.03553 816.44931 324.97428\nHsipaw     145.37542 249.35081 176.09570 163.95741 591.03355 128.42987\nMonghsat   225.64279 352.31496 289.83220 253.25370 663.76026 158.93517\nMongmao    293.70625 314.64777 257.76465 146.09228 451.82530 185.99082\nNansang    160.37607 188.78869 151.13185  60.32773 489.35308  78.78999\nLaukkaing  624.82399 548.83928 552.65554 428.74978 149.26996 507.39700\nPangsang   321.81214 345.91486 287.10769 175.35273 460.24292 214.19291\nNamtu      165.02707 260.95300 257.52713 270.87277 659.16927 185.86794\nMonghpyak  190.93173 142.31691  93.03711 217.64419 539.43485 293.22640\nKonkyan    421.48797 520.31264 439.34272 393.79911 704.86973 351.75354\nMongping   259.68288 396.47081 316.14719 330.28984 744.44948 272.82761\nHopong     138.86577 274.91604 204.88286 218.84211 648.68011 157.48857\nNyaungshwe 139.31874 104.17830  43.26545 126.50414 505.88581 201.71653\nHsihseng   105.30573 257.11202 209.88026 250.27059 677.66886 175.89761\nMongla     441.20998 393.18472 381.40808 241.58966 256.80556 315.93218\nHseni      243.98001 171.50398 164.05304  81.20593 381.30567 204.49010\nKunlong    249.36301 318.30406 285.04608 215.63037 547.24297 122.68682\nHopang     336.38582 321.16462 279.84188 154.91633 377.44407 230.78652\nNamhkan    442.77120 379.41126 367.33575 247.81990 238.67060 342.43665\nKengtung   297.67761 209.38215 208.29647 136.23356 330.08211 258.23950\nLangkho    219.21623 190.30257 156.51662  51.67279 413.64173 160.94435\nMonghsu    113.84636 242.04063 170.09168 200.77712 633.21624 163.28926\nTaunggyi   440.66133 304.96838 344.79200 312.60547 250.81471 425.36916\nPangwaun   423.81347 453.02765 381.67478 308.31407 541.97887 351.78203\nKyethi     162.43575 317.74604 267.21607 328.14177 757.16745 255.83275\nLoilen     181.94596 265.29318 219.26405 146.92675 560.43400  59.69478\nManton     403.82131 551.13000 475.77296 522.86003 941.49778 458.30232\nMongyang   363.58788 363.37684 323.32123 188.59489 389.59919 229.71502\nKunhing    213.46379 278.68953 206.15773 145.00266 533.00162 142.03682\nMongyawng  248.43910 179.07229 220.61209 181.55295 422.37358 211.99976\nTangyan    167.79937 323.14701 269.07880 306.78359 736.93741 224.29176\nNamhsan    207.16559 362.84062 299.74967 347.85944 778.52971 273.79672\n             Mongnai   Mawkmai    Kutkai   Mongton   Mongyai Mongkaing\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai    374.50873                                                  \nKutkai      91.15307 364.95519                                        \nMongton    131.67061 313.35220 107.06341                              \nMongyai    203.23607 178.70499 188.94166 159.79790                    \nMongkaing  456.00842 133.29995 428.96133 365.50032 262.84016          \nLashio     270.86983 638.60773 289.82513 347.11584 466.36472 708.65819\nMongpan    178.09554 509.99632 185.18173 200.31803 346.39710 563.56780\nMatman     376.33870 147.83545 340.86349 303.04574 186.95158 135.51424\nTachileik  563.95232 919.38755 568.99109 608.76740 750.29555 967.14087\nNarphan    329.31700 273.75350 314.27683 215.97925 248.82845 285.65085\nMongkhet   275.76855 115.58388 273.91673 223.22828 104.98924 222.60577\nHsipaw      52.68195 351.34601  51.46282  90.69766 177.33790 423.77868\nMonghsat   125.25968 275.09705 154.32012 150.98053 127.35225 375.60376\nMongmao    188.29603 485.52853 204.69232 206.57001 335.61300 552.31959\nNansang     92.79567 462.41938 130.04549 199.58124 288.55962 542.16609\nLaukkaing  551.56800 882.51110 580.38112 604.66190 732.68347 954.11795\nPangsang   204.25746 484.14757 228.33583 210.77938 343.30638 548.40662\nNamtu      209.35473 427.95451 225.28268 308.71751 278.02761 525.04057\nMonghpyak  253.26470 536.71695 206.61627 258.04282 370.01575 568.21089\nKonkyan    328.82831 339.01411 310.60810 248.25265 287.87384 380.92091\nMongping   202.99615 194.31049 182.75266 119.86993  65.38727 257.18572\nHopong      91.53795 302.84362  73.45899 106.21031 124.62791 379.37916\nNyaungshwe 169.63695 502.99026 152.15482 219.72196 327.13541 557.32112\nHsihseng   142.36728 329.29477 128.21054 194.64317 162.27126 411.59788\nMongla     354.10985 686.88950 388.40984 411.06668 535.28615 761.48327\nHseni      216.81639 582.53670 229.37894 286.75945 408.23212 648.04408\nKunlong    202.92529 446.53763 204.54010 270.02165 299.36066 539.91284\nHopang     243.00945 561.24281 263.31986 273.50305 408.73288 626.17673\nNamhkan    370.05669 706.47792 392.48568 414.53594 550.62819 771.39688\nKengtung   272.28711 632.54638 279.19573 329.38387 460.39706 692.74693\nLangkho    174.67678 531.08019 180.51419 236.70878 358.95672 597.42714\nMonghsu     84.11238 332.07962  62.60859 107.04894 154.86049 400.71816\nTaunggyi   448.55282 810.74692 450.33382 508.40925 635.94105 866.21117\nPangwaun   312.13429 500.68857 321.80465 257.50434 394.07696 536.95736\nKyethi     210.50453 278.85535 184.23422 222.52947 137.79420 352.06533\nLoilen      58.41263 388.73386 131.56529 176.16001 224.79239 482.18190\nManton     391.54062 109.08779 361.82684 310.20581 195.59882  81.75337\nMongyang   260.39387 558.83162 285.33223 295.60023 414.31237 631.91325\nKunhing    110.55197 398.43973 108.84990 114.03609 238.99570 465.03971\nMongyawng  275.77546 620.04321 281.03383 375.22688 445.78964 700.98284\nTangyan    180.37471 262.66006 166.61820 198.88460 109.08506 348.56123\nNamhsan    218.10003 215.19289 191.32762 196.76188  77.35900 288.66231\n              Lashio   Mongpan    Matman Tachileik   Narphan  Mongkhet\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan    172.33279                                                  \nMatman     628.11049 494.81014                                        \nTachileik  311.95286 411.03849 890.12935                              \nNarphan    525.63854 371.13393 312.05193 760.29566                    \nMongkhet   534.44463 412.17123 203.02855 820.50164 217.28718          \nHsipaw     290.86435 179.52054 344.45451 576.18780 295.40170 253.80950\nMonghsat   377.86793 283.30992 313.59911 677.09508 278.21548 167.98445\nMongmao    214.23677 131.59966 501.59903 472.95568 331.42618 375.35820\nNansang    184.47950 144.77393 458.06573 486.77266 398.13308 360.99219\nLaukkaing  334.65738 435.58047 903.72094 325.06329 708.82887 769.06406\nPangsang   236.72516 140.23910 506.29940 481.31907 316.30314 375.58139\nNamtu      365.88437 352.91394 416.65397 659.56458 494.36143 355.99713\nMonghpyak  262.09281 187.85699 470.46845 444.04411 448.40651 462.63265\nKonkyan    485.51312 365.87588 392.40306 730.92980 158.82353 254.24424\nMongping   454.52548 318.47482 201.65224 727.08969 188.64567 113.80917\nHopong     345.31042 239.43845 291.84351 632.45718 294.40441 212.99485\nNyaungshwe 201.58191 137.29734 460.91883 445.81335 427.94086 417.08639\nHsihseng   369.00833 295.87811 304.02806 658.87060 377.52977 256.70338\nMongla     179.95877 253.20001 708.17595 347.33155 531.46949 574.40292\nHseni       79.41836 120.66550 564.64051 354.90063 474.12297 481.88406\nKunlong    295.23103 288.03320 468.27436 595.70536 413.07823 341.68641\nHopang     170.63913 135.62913 573.55355 403.82035 397.85908 451.51070\nNamhkan    173.27153 240.34131 715.42102 295.91660 536.85519 596.19944\nKengtung    59.85893 142.21554 613.01033 295.90429 505.40025 531.35998\nLangkho    115.18145  94.98486 518.86151 402.33622 420.65204 428.08061\nMonghsu    325.71557 216.25326 308.13805 605.02113 311.92379 247.73318\nTaunggyi   195.14541 319.81385 778.45810 150.84117 684.20905 712.80752\nPangwaun   362.45608 232.52209 523.43600 540.60474 264.64997 407.02947\nKyethi     447.10266 358.89620 233.83079 728.87329 374.90376 233.25039\nLoilen     268.92310 207.25000 406.56282 573.75476 354.79137 284.76895\nManton     646.66493 507.96808  59.52318 910.23039 280.26395 181.33894\nMongyang   209.33700 194.93467 585.61776 448.79027 401.39475 445.40621\nKunhing    255.10832 137.85278 403.66587 532.26397 281.62645 292.49814\nMongyawng  172.70139 275.15989 601.80824 432.10118 572.76394 522.91815\nTangyan    429.84475 340.39128 242.78233 719.84066 348.84991 201.49393\nNamhsan    472.04024 364.77086 180.09747 754.03913 316.54695 170.90848\n              Hsipaw  Monghsat   Mongmao   Nansang Laukkaing  Pangsang\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat   121.78922                                                  \nMongmao    185.99483 247.17708                                        \nNansang    120.24428 201.92690 164.99494                              \nLaukkaing  569.06099 626.44910 404.00848 480.60074                    \nPangsang   205.04337 256.37933  57.60801 193.36162 408.04016          \nNamtu      229.44658 231.78673 365.03882 217.61884 664.06286 392.97391\nMonghpyak  237.67919 356.84917 291.88846 227.52638 565.84279 315.11651\nKonkyan    296.74316 268.25060 281.87425 374.70456 635.92043 274.81900\nMongping   168.92101 140.95392 305.57166 287.36626 708.13447 308.33123\nHopong      62.86179 100.45714 244.16253 167.66291 628.48557 261.51075\nNyaungshwe 169.92664 286.37238 230.45003 131.18943 520.24345 257.77823\nHsihseng   136.54610 153.49551 311.98001 193.53779 670.74564 335.52974\nMongla     373.47509 429.00536 216.24705 289.45119 202.55831 217.88123\nHseni      231.48538 331.22632 184.67099 136.45492 391.74585 214.66375\nKunlong    205.10051 202.31862 224.43391 183.01388 521.88657 258.49342\nHopang     248.72536 317.64824  78.29342 196.47091 331.67199  92.57672\nNamhkan    382.79302 455.10875 223.32205 302.89487 196.46063 231.38484\nKengtung   284.08582 383.72138 207.58055 193.67980 351.48520 229.85484\nLangkho    183.05109 279.52329 134.50170  99.39859 410.41270 167.65920\nMonghsu     58.55724 137.24737 242.43599 153.59962 619.01766 260.52971\nTaunggyi   462.31183 562.88102 387.33906 365.04897 345.98041 405.59730\nPangwaun   298.12447 343.53898 187.40057 326.12960 470.63605 157.48757\nKyethi     195.17677 190.50609 377.89657 273.02385 749.99415 396.89963\nLoilen      98.04789 118.65144 190.26490  94.23028 535.57527 207.94433\nManton     359.60008 317.15603 503.79786 476.55544 907.38406 504.75214\nMongyang   267.10497 312.64797  91.06281 218.49285 326.19219 108.37735\nKunhing     90.77517 165.38834 103.91040 128.20940 500.41640 123.18870\nMongyawng  294.70967 364.40429 296.40789 191.11990 454.80044 336.16703\nTangyan    167.69794 144.59626 347.14183 249.70235 722.40954 364.76893\nNamhsan    194.47928 169.56962 371.71448 294.16284 760.45960 385.65526\n               Namtu Monghpyak   Konkyan  Mongping    Hopong Nyaungshwe\nPindaya                                                                \nYwangan                                                                \nPinlaung                                                               \nMabein                                                                 \nKalaw                                                                  \nPekon                                                                  \nLawksawk                                                               \nNawnghkio                                                              \nKyaukme                                                                \nMuse                                                                   \nLaihka                                                                 \nMongnai                                                                \nMawkmai                                                                \nKutkai                                                                 \nMongton                                                                \nMongyai                                                                \nMongkaing                                                              \nLashio                                                                 \nMongpan                                                                \nMatman                                                                 \nTachileik                                                              \nNarphan                                                                \nMongkhet                                                               \nHsipaw                                                                 \nMonghsat                                                               \nMongmao                                                                \nNansang                                                                \nLaukkaing                                                              \nPangsang                                                               \nNamtu                                                                  \nMonghpyak  346.57799                                                   \nKonkyan    478.37690 463.39594                                         \nMongping   321.66441 354.76537 242.02901                               \nHopong     206.82668 267.95563 304.49287 134.00139                     \nNyaungshwe 271.41464 103.97300 432.35040 319.32583 209.32532           \nHsihseng   131.89940 285.37627 383.49700 199.64389  91.65458  225.80242\nMongla     483.49434 408.03397 468.09747 512.61580 432.31105  347.60273\nHseni      327.41448 200.26876 448.84563 395.58453 286.41193  130.86310\nKunlong    233.60474 357.44661 329.11433 309.05385 219.06817  285.13095\nHopang     408.24516 304.26577 348.18522 379.27212 309.77356  247.19891\nNamhkan    506.32466 379.50202 481.59596 523.74815 444.13246  333.32428\nKengtung   385.33554 221.47613 474.82621 442.80821 340.47382  177.75714\nLangkho    305.03473 200.27496 386.95022 343.96455 239.63685  128.26577\nMonghsu    209.64684 232.17823 331.72187 158.90478  43.40665  173.82799\nTaunggyi   518.72748 334.17439 650.56905 621.53039 513.76415  325.09619\nPangwaun   517.03554 381.95144 263.97576 340.37881 346.00673  352.92324\nKyethi     186.90932 328.16234 400.10989 187.43974 136.49038  288.06872\nLoilen     194.24075 296.99681 334.19820 231.99959 124.74445  206.40432\nManton     448.58230 502.20840 366.66876 200.48082 310.58885  488.79874\nMongyang   413.26052 358.17599 329.39338 387.80686 323.35704  294.29500\nKunhing    296.43996 250.74435 253.74202 212.59619 145.15617  189.97131\nMongyawng  262.24331 285.56475 522.38580 455.59190 326.59925  218.12104\nTangyan    178.69483 335.26416 367.46064 161.67411 106.82328  284.14692\nNamhsan    240.95555 352.70492 352.20115 130.23777 132.70541  315.91750\n            Hsihseng    Mongla     Hseni   Kunlong    Hopang   Namhkan\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat                                                              \nMongmao                                                               \nNansang                                                               \nLaukkaing                                                             \nPangsang                                                              \nNamtu                                                                 \nMonghpyak                                                             \nKonkyan                                                               \nMongping                                                              \nHopong                                                                \nNyaungshwe                                                            \nHsihseng                                                              \nMongla     478.66210                                                  \nHseni      312.74375 226.82048                                        \nKunlong    231.85967 346.46200 276.19175                              \nHopang     370.01334 147.02444 162.80878 271.34451                    \nNamhkan    492.09476  77.21355 212.11323 375.73885 146.18632          \nKengtung   370.72441 202.45004  66.12817 317.14187 164.29921 175.63015\nLangkho    276.27441 229.01675  66.66133 224.52741 134.24847 224.40029\nMonghsu     97.82470 424.51868 262.28462 239.89665 301.84458 431.32637\nTaunggyi   528.14240 297.09863 238.19389 471.29032 329.95252 257.29147\nPangwaun   433.06326 319.18643 330.70182 392.45403 206.98364 310.44067\nKyethi      84.04049 556.02500 388.33498 298.55859 440.48114 567.86202\nLoilen     158.84853 338.67408 227.10984 166.53599 242.89326 364.90647\nManton     334.87758 712.51416 584.63341 479.76855 577.52046 721.86149\nMongyang   382.59743 146.66661 210.19929 247.22785  69.25859 167.72448\nKunhing    220.15490 306.47566 206.47448 193.77551 172.96164 314.92119\nMongyawng  309.51462 315.57550 173.86004 240.39800 290.51360 321.21112\nTangyan     70.27241 526.80849 373.07575 268.07983 412.22167 542.64078\nNamhsan    125.74240 564.02740 411.96125 310.40560 440.51555 576.42717\n            Kengtung   Langkho   Monghsu  Taunggyi  Pangwaun    Kyethi\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat                                                              \nMongmao                                                               \nNansang                                                               \nLaukkaing                                                             \nPangsang                                                              \nNamtu                                                                 \nMonghpyak                                                             \nKonkyan                                                               \nMongping                                                              \nHopong                                                                \nNyaungshwe                                                            \nHsihseng                                                              \nMongla                                                                \nHseni                                                                 \nKunlong                                                               \nHopang                                                                \nNamhkan                                                               \nKengtung                                                              \nLangkho    107.16213                                                  \nMonghsu    316.91914 221.84918                                        \nTaunggyi   186.28225 288.27478 486.91951                              \nPangwaun   337.48335 295.38434 343.38498 497.61245                    \nKyethi     444.26274 350.91512 146.61572 599.57407 476.62610          \nLoilen     282.22935 184.10672 131.55208 455.91617 331.69981 232.32965\nManton     631.99123 535.95620 330.76503 803.08034 510.79265 272.03299\nMongyang   217.08047 175.35413 323.95988 374.58247 225.25026 453.86726\nKunhing    245.95083 146.38284 146.78891 429.98509 229.09986 278.95182\nMongyawng  203.87199 186.11584 312.85089 287.73864 475.33116 387.71518\nTangyan    429.95076 332.02048 127.42203 592.65262 447.05580  47.79331\nNamhsan    466.20497 368.20978 153.22576 631.49232 448.58030  68.67929\n              Loilen    Manton  Mongyang   Kunhing Mongyawng   Tangyan\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat                                                              \nMongmao                                                               \nNansang                                                               \nLaukkaing                                                             \nPangsang                                                              \nNamtu                                                                 \nMonghpyak                                                             \nKonkyan                                                               \nMongping                                                              \nHopong                                                                \nNyaungshwe                                                            \nHsihseng                                                              \nMongla                                                                \nHseni                                                                 \nKunlong                                                               \nHopang                                                                \nNamhkan                                                               \nKengtung                                                              \nLangkho                                                               \nMonghsu                                                               \nTaunggyi                                                              \nPangwaun                                                              \nKyethi                                                                \nLoilen                                                                \nManton     419.06087                                                  \nMongyang   246.76592 585.70558                                        \nKunhing    130.39336 410.49230 188.89405                              \nMongyawng  261.75211 629.43339 304.21734 295.35984                    \nTangyan    196.60826 271.82672 421.06366 249.74161 377.52279          \nNamhsan    242.15271 210.48485 450.97869 270.79121 430.02019  63.67613"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-hierarchical-clustering",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-hierarchical-clustering",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.5 Computing Hierarchical Clustering",
    "text": "6.5.5 Computing Hierarchical Clustering\nWe implement the hclust() function of R stats to compute it.\nThis functions employs the agglomeration method to compute the cluster.\nThe following 8 clustering algorithms are supported:\n\nward.D: Minimizes the total variance within clusters, merging pairs of clusters that result in the smallest increase in total variance.\nward.D2: A variant of Ward’s method that uses squared distances, producing slightly different results than ward.D.\nsingle: Uses the minimum distance (or nearest neighbor) between clusters, often leading to elongated, chain-like clusters (also called “connected clustering”).\ncomplete: Uses the maximum distance (or farthest neighbor) between clusters, resulting in more compact clusters.\naverage (UPGMA): Merges clusters based on the average distance between all members of the two clusters, balancing between single and complete linkage.\nmcquitty (WPGMA): A weighted average method where the distance between a new cluster and an existing cluster is based on the average of distances with equal weighting.\nmedian (WPGMC): Merges clusters based on the median distance, which can reduce the impact of outliers.\ncentroid (UPGMC): Uses the centroid of clusters (the mean position of all points) for calculating distances, which may result in reversals where clusters can split again during merging.\n\n\nComputationPlot\n\n\nWe now perform hierarchical cluster analysis using the ward.D method. The hierarchical output is stored in an object of class hclust which describes the tree produced by the clustering process.\n\nhclust_ward &lt;- hclust(proxmat, method = 'ward.D')\n\n\n\nWe now implement the plot() of R graphics to create a tree.\n\nplot(hclust_ward, cex=0.6)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#selecting-the-optimal-clustering-algorithm",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#selecting-the-optimal-clustering-algorithm",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.6 Selecting the optimal clustering algorithm",
    "text": "6.5.6 Selecting the optimal clustering algorithm\nA big challenge when conducting hierarchical clustering is to identify stronger clustering structures.\nThis issue can be solved by using the agnes() function of the cluster package. It functions like hclust(), however, with the agnes() function you can also get the agglomerative coefficient, which measures the amount of clustering structures found.\nWe implement the code chunk below to compute the agglomerative coefficients of all hierarchical clustering algorithms.\n\nm &lt;- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) &lt;- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac &lt;- function(x) {\n  agnes(shan_ict, method = x)$ac\n}\n\nmap_dbl(m, ac)\n\n  average    single  complete      ward \n0.8131144 0.6628705 0.8950702 0.9427730 \n\n\nFrom the output above, we infer that the Ward method does in fact provide the strongest clustering structure out of the 4 selected methods. We proceed to use the Ward’s method in subsequent analysis."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#determining-optimal-clusters",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#determining-optimal-clusters",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.7 Determining Optimal Clusters",
    "text": "6.5.7 Determining Optimal Clusters\nThere are three commonly used methods to determine the optimal clusters, they are:\n\nElbow Method: A technique to determine the optimal number of clusters by plotting the explained variance (within-cluster sum of squares) against the number of clusters, and identifying the “elbow” point where adding more clusters provides diminishing returns in reducing variance.\nAverage Silhouette Method: Evaluates the quality of clustering by measuring how similar each point is to its own cluster compared to other clusters. The optimal number of clusters maximizes the average silhouette width, which reflects well-separated and cohesive clusters.\nGap Statistic Method: Compares the total within-cluster variance for different numbers of clusters to that of a reference dataset with no obvious clustering structure. The optimal number of clusters is where the gap between the observed data and reference data is largest, indicating a meaningful clustering structure.\n\n\n6.5.7.1 Gap Statistic Method\nThe Gap Statistic compares the total within-cluster variation for different values of k with the expected variation under a null reference distribution of the data. The optimal number of clusters is the value of k that maximizes the gap statistic, indicating the largest difference between the observed clustering structure and a random uniform distribution of points. A higher gap statistic suggests a more distinct and meaningful clustering pattern compared to random noise.\nWe implement the clusGap() function of the cluster package.\n\nset.seed(12345)\ngap_stat &lt;- clusGap(shan_ict, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = shan_ict, FUNcluster = hcut, K.max = 10, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --&gt; Number of clusters (method 'firstmax'): 1\n          logW   E.logW       gap     SE.sim\n [1,] 8.407129 8.680794 0.2736651 0.04460994\n [2,] 8.130029 8.350712 0.2206824 0.03880130\n [3,] 7.992265 8.202550 0.2102844 0.03362652\n [4,] 7.862224 8.080655 0.2184311 0.03784781\n [5,] 7.756461 7.978022 0.2215615 0.03897071\n [6,] 7.665594 7.887777 0.2221833 0.03973087\n [7,] 7.590919 7.806333 0.2154145 0.04054939\n [8,] 7.526680 7.731619 0.2049390 0.04198644\n [9,] 7.458024 7.660795 0.2027705 0.04421874\n[10,] 7.377412 7.593858 0.2164465 0.04540947\n\n\n\nNote that the hcut function used in the FUN argument above is from the factoextra package.\n\nWe now visualize the plot by implementing the fviz_gap_stat() function of the factoextra package.\n\nfviz_gap_stat(gap_stat)\n\n\n\n\n\n\n\n\nFrom the above, we infer that the recommended number of clusters to retain is 1. However, it isn’t logical to retain just one. By continuing to examine the graph, we see that the 6-cluster gives the largest gap statistic and should be the next best cluster to pick.\n\nNote: In addition to these commonly used approaches, the NbClust package, published by Charrad et al., 2014, provides 30 indices for determining the relevant number of clusters and proposes to users the best clustering scheme from the different results obtained by varying all combinations of number of clusters, distance measures, and clustering methods."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#interpreting-the-dendrograms",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#interpreting-the-dendrograms",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.8 Interpreting the dendrograms",
    "text": "6.5.8 Interpreting the dendrograms\nIn the above dendrogram, each leaf corresponds to one observation.\nAs we move up the tree, similar observations are grouped into branches, which are fused at a higher height. The height of the fusion, provided on the vertical axis, indicates the (dis)similarity between two observations. The higher the height of the fusion, the less similar the observations are.\n\nNote that conclusions about the proximity of two observations can be drawn only based on the height where the branches containing those two observations first are fused. We cannot use the proximity of two observations along the horizontal axis as a criteria of their similarity.\n\nWe can also plot the dendrogram with a border around the selected clusters by implementing the rect.hclust() function of R stats. The border argument is used to specify the border colors for the rectangles.\n\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visually-driven-hierarchical-clustering-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visually-driven-hierarchical-clustering-analysis",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.7 Visually-driven hierarchical clustering analysis",
    "text": "6.5.7 Visually-driven hierarchical clustering analysis\nWe now implement functions of the heatmaply package to conduct visually driven hierarchical clustering analysis.\nHeatmaply allows us to build both highly interactive cluster heatmaps or static cluster heatmaps.\n\n6.5.7.1 Transforming the data-frame into a matrix\nThough we have a data-frame, the data has to be in matrix form to make a heatmap.\nWe use the code chunk below to transform the shan_ct data-frame into a data matrix. The data.matrix() function is implemented.\n\nshan_ict_mat &lt;- data.matrix(shan_ict)\n\n\n\n6.5.7.2 Plotting an Interactive Cluster Heatmap using heatmaply()\nWe implement the heatmaply() function of the heatmaply package to create an interactive cluster heatmap.\n\nheatmaply(normalize(shan_ict_mat),\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 6,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of Shan State by ICT indicators\",\n          xlab = \"ICT Indicators\",\n          ylab = \"Townships of Shan State\"\n          )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#mapping-the-clusters-formed",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#mapping-the-clusters-formed",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.5.8 Mapping the clusters formed",
    "text": "6.5.8 Mapping the clusters formed\nAs decided earlier, we have retained 6 clusters (k=6).\nThe cutree() function of Base R is used to derive a 6-cluster model.\n\ngroups &lt;- as.factor(cutree(hclust_ward, k=6))\n\nThe above output, groups, is a list object.\nWe now need to append this object onto the shan_sf simple-feature object.\n\nThe code chunk below forms the join in three steps:\n\nthe groups list object will be converted into a matrix\ncbind() is used to append the groups matrix onto shan_sf to produce an output simple feature object called shan_sf_cluster; and\nrename() of the dplyr package is used to rename as.matrix.groups field as CLUSTER.\n\n\n\nshan_sf_cluster &lt;- cbind(shan_sf, as.matrix(groups)) %&gt;%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n\nWe now implement the qtm() function of the tmap package to plot the choropleth map to visualize these clusters.\n\nqtm(shan_sf_cluster, \"CLUSTER\")\n\n\n\n\n\n\n\n\nFrom the above map, we infer that the clusters are relatively fragmented. This is a major limitation of using non-spatial clustering algorithms such as hierarchical clustering analysis."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#converting-into-spatialpolygonsdataframe",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#converting-into-spatialpolygonsdataframe",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.6.1 Converting into SpatialPolygonsDataFrame",
    "text": "6.6.1 Converting into SpatialPolygonsDataFrame\nWe start by converting shan_sf into a SpatialPolygonsDataFrame. This is becausse the SKATER function only supports sp objects.\nWe implement the as_Spatial() function of the sf package to do the conversion.\n\nshan_sp &lt;- as_Spatial(shan_sf)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-neighbor-list",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-neighbor-list",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.6.2 Computing Neighbor List",
    "text": "6.6.2 Computing Neighbor List\nNow, we apply the poly2nb() function of the spdep package to compute the neighbours list from the polygon list.\n\nshan.nb &lt;- poly2nb(shan_sp)\nsummary(shan.nb)\n\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\n\nWe now plot the neighbours list on shan_sp by using the code chunk below.\nSince we now can plot the community area boundaries as well, we plot this graph on top of the map. The first plot command gives the boundaries. This is followed by the plot of the neighbor list object, with coordinates applied to the original SpatialPolygonDataFrame (Shan state township boundaries) to extract the centroids of the polygons. These are used as the nodes for the graph representation. We also set the color to blue and specify add=TRUE to plot the network on top of the boundaries.\n\n# Obtaining coordinates\ncoords &lt;- st_coordinates(\n  st_centroid(st_geometry(shan_sf)))\n\n# Plots\nplot(st_geometry(shan_sf), \n     border=grey(.5))\nplot(shan.nb,\n     coords, \n     col=\"blue\", \n     add=TRUE)\n\n\n\n\n\n\n\n\n\nNote that if you plot the network first and then the boundaries, some of the areas will be clipped. This is because the plotting area is determined by the characteristics of the first plot. In this example, because the boundary map extends further than the graph, we plot it first."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-the-minimum-spanning-tree",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-the-minimum-spanning-tree",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.6.3 Computing the minimum spanning tree",
    "text": "6.6.3 Computing the minimum spanning tree\n\n6.6.3.1 Calculating Edge Costs\nWe now implement the nbcosts() function of the spdep package is used to compute the cost of each edge. It is the distance between the nodes.\nThis function computes this distance by using a data.frame with observations vector in each node.\n\nlcosts &lt;- nbcosts(shan.nb, shan_ict)\n\nFor each observation, this gives the pairwise dissimilarity between its values on the five variables and the values for the neighbouring observations (from the neighbour list).\nThis is basically the notion of a generalised weight for a spatial weights matrix.\nNext, we incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed lcosts as the weights.\nIn order to achieve this, nb2listw() function of the spdep package is used as shown in the code chunk below.\nNote that we specify the style as B to make sure the cost values are not row-standardised.\n\nshan.w &lt;- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(shan.w)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0       S1        S2\nB 55 3025 76267.65 58260785 522016004\n\n\nThe minimum spanning tree is computed by implementing the mstree() function of the spdep package.\n\nObtaining TreeClass of the treeDimensions\n\n\n\nshan.mst &lt;- mstree(shan.w)\n\n\n\n\nclass(shan.mst)\n\n[1] \"mst\"    \"matrix\"\n\n\n\n\n\ndim(shan.mst)\n\n[1] 54  3\n\n\n\n\n\n\nNote that the dimension is 54 and not 55. This is because the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.\n\nWe can now display the content of shan.mst by using the head() function.\n\nhead(shan.mst)\n\n     [,1] [,2]      [,3]\n[1,]   54   48  47.79331\n[2,]   54   17 109.08506\n[3,]   54   45 127.42203\n[4,]   45   52 146.78891\n[5,]   52   13 110.55197\n[6,]   13   28  92.79567\n\n\nThe plot method for the MST includes a way to show the observation numbers of the nodes in addition to the edge.\nAs before, we plot this together with the township boundaries. We can see how the initial neighbor list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.\n\nplot(st_geometry(shan_sf), \n                 border=gray(.5))\nplot.mst(shan.mst, \n         coords, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-spatially-constrained-clusters-using-the-skater-method",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#computing-spatially-constrained-clusters-using-the-skater-method",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.6.5 Computing spatially constrained clusters using the SKATER method",
    "text": "6.6.5 Computing spatially constrained clusters using the SKATER method\nWe implement the skater() function of the spdep package to compute the clusters.\n\nclust6 &lt;- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\n\nThe skater() function takes three mandatory arguments:\n\nThe first two columns of the MST matrix (i.e. not the cost),\nThe data matrix (to update the costs as units are being grouped)\nThe number of cuts.\n\n\n\nNote: It is set to one less than the number of clusters. So, the value specified is not the number of clusters, but the number of cuts in the graph, one less than the number of clusters.\n\n\nThe result of the skater() is an object of class skater. We can examine its contents by using the code chunk below.\n\nstr(clust6)\n\nList of 8\n $ groups      : num [1:55] 3 3 6 3 3 3 3 3 3 3 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:22] 13 48 54 55 45 37 34 16 25 52 ...\n  .. ..$ edge: num [1:21, 1:3] 48 55 54 37 34 16 45 25 13 13 ...\n  .. ..$ ssw : num 3423\n  ..$ :List of 3\n  .. ..$ node: num [1:18] 47 27 53 38 42 15 41 51 43 32 ...\n  .. ..$ edge: num [1:17, 1:3] 53 15 42 38 41 51 15 27 15 43 ...\n  .. ..$ ssw : num 3759\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 2 6 8 1 36 4 10 9 46 5 ...\n  .. ..$ edge: num [1:10, 1:3] 6 1 8 36 4 6 8 10 10 9 ...\n  .. ..$ ssw : num 1458\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 44 20\n  .. ..$ edge: num [1, 1:3] 44 20 95\n  .. ..$ ssw : num 95\n  ..$ :List of 3\n  .. ..$ node: num 23\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 3\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 12613\n $ ssw         : num [1:6] 12613 10977 9962 9540 9123 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n\n\nThe most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary).\nThis is followed by a detailed summary for each of the clusters in the edges.groups list.\nSum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.\nWe can check the cluster assignment by using the conde chunk below.\n\nccs6 &lt;- clust6$groups\nccs6\n\n [1] 3 3 6 3 3 3 3 3 3 3 2 1 1 1 2 1 1 1 2 4 1 2 5 1 1 1 2 1 2 2 1 2 2 1 1 3 1 2\n[39] 2 2 2 2 2 4 1 3 2 1 1 1 2 1 2 1 1\n\n\nWe can find out how many observations are in each cluster by using the table() function.\nWe can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.\n\ntable(ccs6)\n\nccs6\n 1  2  3  4  5  6 \n22 18 11  2  1  1 \n\n\nWe can also plot the pruned tree that shows the 5 clusters on top of the township area, similar to what we did earlier.\n\nplot(st_geometry(shan_sf), \n     border=gray(.5))\nplot(clust6, \n     coords, \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visualizing-the-clusters-in-a-choropleth-map",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visualizing-the-clusters-in-a-choropleth-map",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.6.6 Visualizing the clusters in a Choropleth Map",
    "text": "6.6.6 Visualizing the clusters in a Choropleth Map\n\ngroups_mat &lt;- as.matrix(clust6$groups)\nshan_sf_spatialcluster &lt;- cbind(shan_sf_cluster, as.factor(groups_mat)) %&gt;%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n\n\n\n\n\n\n\n\nTo facilitate comparison, we plot the hierarchical clustering map as well as the spatially constrained hierarchical clustering maps next to one another.\n\nhclust.map &lt;- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map &lt;- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n\n\n\n\n\n\n\n\nWe immediately see the difference between the two methods, in how clusters are fragmented. The spatially constrained cluster is has no fragmentation."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#ward-like-hierarchical-clustering-clustgeo",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#ward-like-hierarchical-clustering-clustgeo",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.7.1 Ward-like Hierarchical Clustering: ClustGeo",
    "text": "6.7.1 Ward-like Hierarchical Clustering: ClustGeo\nClustGeo provides a function called hclustgeo() to perform a typical Ward-like hierarchical clustering just like the hclust() function.\nTo perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.\n\nnongeo_cluster &lt;- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n\n\n\n\n\n\n\n\n\nNote that the dissimilarity matrix must be an object of class dist, i.e. an object obtained with the function dist().\n\n\n6.7.1.1 Mapping the clusters formed\nWe plot the clusters on map using similar steps to what we did earlier.\n\ngroups &lt;- as.factor(cutree(nongeo_cluster, k=6))\n\nshan_sf_ngeo_cluster &lt;- cbind(shan_sf, as.matrix(groups)) %&gt;%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#spatially-constrained-hierarchical-clustering",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#spatially-constrained-hierarchical-clustering",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.7.2 Spatially Constrained Hierarchical Clustering",
    "text": "6.7.2 Spatially Constrained Hierarchical Clustering\nBefore we can perform spatially constrained hierarchical clustering, a spatial distance matrix mustbe derived. For this, we implement the st_distance() function of the sf package.\n\ndist &lt;- st_distance(shan_sf, shan_sf)\ndistmat &lt;- as.dist(dist)\n\n\nNote that the as.dist() function is used to convert the data-frame into a matrix.\n\nWe now implement the choicealpha() function to determine a suitable value for the mixing parameter, alpha.\n\ncr &lt;- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFrom the above, we infer that an alpha value of 0.3 would be suitable.\n\nclustG &lt;- hclustgeo(proxmat, distmat, alpha = 0.3)\n\nNow, we implement the cutree() function to derive the cluster object. This is similar to the steps we used above to plot the maps.\n\ngroups &lt;- as.factor(cutree(clustG, k=6))\n\nshan_sf_Gcluster &lt;- cbind(shan_sf, as.matrix(groups)) %&gt;%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nWe now implement the qtm() function to plot the map of the newly delineated spatially constrained clusters.\n\nqtm(shan_sf_Gcluster, \"CLUSTER\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visualizing-individual-clustering-variable",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#visualizing-individual-clustering-variable",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.8.1 Visualizing individual clustering variable",
    "text": "6.8.1 Visualizing individual clustering variable\nWe implement the code chunk below the reveal the distribution of a variable, such as RADIO_PR, by cluster.\n\nggplot(data = shan_sf_ngeo_cluster,\n       aes(x = CLUSTER, y = RADIO_PR)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nThe boxplot reveals that Cluster 3 displays the highest mean Radio Ownership Per Thousand Households. This is followed by Cluster 2, 1, 4, 6 and 5."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#multivariate-visualization",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#multivariate-visualization",
    "title": "Hands On Exercise 6- Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "6.8.2 Multivariate Visualization",
    "text": "6.8.2 Multivariate Visualization\nPast studies have shown that parallel coordinate plots can be used in order to reveal clustering variables by cluster effectively.\nWe implement the ggparcoord() function of the GGally package for this.\n\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n\n\n\n\n\n\n\n\nThe parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TVs and mobile-phones., while households in Cluster 5 tend to own the lowest of all the five ICTs.\nNote that the scale argument of ggparcoor() provide several methods to scale the clustering variables. They are:\n\nstd: univariately, subtract mean and divide by standard deviation.\nrobust: univariately, subtract median and divide by median absolute deviation.\nuniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.\nglobalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.\ncenter: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.\ncenterObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param\n\nThere is no best scaling method to use. The method selected must be done based on the specific requirements of your analysis.\nFinally, we also compute the summary statistics to complement the plots created above.\nIn the code chunk below, group_by() and summarise() of dplyr are used to derive mean values of the clustering variables.\n\nshan_sf_ngeo_cluster %&gt;% \n  st_set_geometry(NULL) %&gt;%\n  group_by(CLUSTER) %&gt;%\n  summarise(mean_RADIO_PR = mean(RADIO_PR),\n            mean_TV_PR = mean(TV_PR),\n            mean_LLPHONE_PR = mean(LLPHONE_PR),\n            mean_MPHONE_PR = mean(MPHONE_PR),\n            mean_COMPUTER_PR = mean(COMPUTER_PR))\n\n# A tibble: 6 × 6\n  CLUSTER mean_RADIO_PR mean_TV_PR mean_LLPHONE_PR mean_MPHONE_PR\n  &lt;chr&gt;           &lt;dbl&gt;      &lt;dbl&gt;           &lt;dbl&gt;          &lt;dbl&gt;\n1 1               221.        521.            44.2           246.\n2 2               237.        402.            23.9           134.\n3 3               300.        611.            52.2           392.\n4 4               196.        744.            99.0           651.\n5 5               124.        224.            38.0           132.\n6 6                98.6       499.            74.5           468.\n# ℹ 1 more variable: mean_COMPUTER_PR &lt;dbl&gt;"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex6/In-class_Ex6.html",
    "href": "In-class_Ex/In-class_Ex6/In-class_Ex6.html",
    "title": "In Class Exercise 6",
    "section": "",
    "text": "In this in-class exercise, we will reinforce our learning from Hands-on Exercise 6 and conduct Emerging Hot/Cold Spot Analysis.\nFor this exercise we will use Hunan GDPPC data.\n\nEmerging Hot Spot Analysis (EHSA) is a spatio-temporal analysis method for revealing and describing how hot spot and cold spot areas evolve over time. The analysis consist of four main steps:\n\nBuilding a space-time cube,\nCalculating Getis-Ord local Gi* statistic for each bin by using an FDR correction,\nEvaluating these hot and cold spot trends by using Mann-Kendall trend test,\nCategorising each study area location by referring to the resultant trend z-score and p-value for each location with data, and with the hot spot z-score and p-value for each bin."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#deriving-the-spatial-weights",
    "href": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#deriving-the-spatial-weights",
    "title": "In Class Exercise 6",
    "section": "6.3.1 Deriving the Spatial Weights",
    "text": "6.3.1 Deriving the Spatial Weights\nWe implement the below code chunk to identify neighbors and calculate the inverse-distance weights.\n\nGDPPC_nb &lt;- GDPPC_st %&gt;%\n  activate(\"geometry\") %&gt;%\n  mutate(nb = include_self(\n    st_contiguity(geometry)),\n    wt = st_inverse_distance(nb, \n                             geometry, \n                             scale = 1,\n                             alpha = 1),\n    .before = 1) %&gt;%\n  set_nbs(\"nb\") %&gt;%\n  set_wts(\"wt\")\n\n\n\nactivate() of dplyr package is used to activate the geometry context\nmutate() of dplyr package is used to create two new columns nb and wt.\nThen we will activate the data context again and copy over the nb and wt columns to each time-slice using set_nbs() and set_wts()\n\nrow order is very important so do not rearrange the observations after using set_nbs() or set_wts()."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#computing-gi",
    "href": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#computing-gi",
    "title": "In Class Exercise 6",
    "section": "6.3.2 Computing Gi",
    "text": "6.3.2 Computing Gi\nWe can use these new columns to manually calculate the local Gi for each location. We do this by grouping by Year and using the local_gstar_perm() function of the sfdep package. After this, we use the unnest() function to unnest the gi_star column of the newly created gi_starts data.frame.\n\ngi_stars &lt;- GDPPC_nb %&gt;% \n  group_by(Year) %&gt;% \n  mutate(gi_star = local_gstar_perm(\n    GDPPC, nb, wt)) %&gt;% \n  tidyr::unnest(gi_star)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#mann-kendall-test",
    "href": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#mann-kendall-test",
    "title": "In Class Exercise 6",
    "section": "6.3.3 Mann-Kendall Test",
    "text": "6.3.3 Mann-Kendall Test\nWe the above Gi calculations, we can now conduct the Mann-Kendall test to evaluate each location for a trend.\nIn the code chunk below, we use Changsha,\n\ncbg &lt;- gi_stars %&gt;% \n  ungroup() %&gt;% \n  filter(County == \"Changsha\") %&gt;% \n  select(County, Year, gi_star)\n\nWe can now produce a plot by using the ggplot package.\n\nggplot(data = cbg, \n       aes(x = Year, \n           y = gi_star)) +\n  geom_line() +\n  theme_light()\n\n\n\n\n\n\n\n\nAlternatively, we can also create an interactive plot using the ggplotly() function of the plotly package.\n\np &lt;- ggplot(data = cbg, \n       aes(x = Year, \n           y = gi_star)) +\n  geom_line() +\n  theme_light()\n\nggplotly(p)\n\n\n\n\n\n\n6.3.3.1 Mann-Kendall Test Report\nA Monotonic series or function is one that only increases (or decreases) and never changes direction. So long as the function either stays flat or continues to increase, it is monotonic.\n\nH0: No monotic trend.\nH1: Monotonic trend is present\n\n\nTau ranges between -1 and 1 where:\n\n-1 is a perfectly decreasing series.\n1 is a perfectly increasing series.\n\n\nWe implement the below code chunk to obtain the required report.\n\ncbg %&gt;%\n  summarise(mk = list(\n    unclass(\n      Kendall::MannKendall(gi_star)))) %&gt;% \n  tidyr::unnest_wider(mk)\n\n# A tibble: 1 × 5\n    tau      sl     S     D  varS\n  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 0.485 0.00742    66  136.  589.\n\n\n\nNote that slin the output above is the p-value in this situation.\n\nFrom the above output, we can infer that there is a slight upward but insignificant trend.\n\n\n6.3.3.2 Mann-Kendall Test Data-Frame\nWe can perform the above steps for every location by using the group_by() function of the dplyr package.\n\nehsa &lt;- gi_stars %&gt;%\n  group_by(County) %&gt;%\n  summarise(mk = list(\n    unclass(\n      Kendall::MannKendall(gi_star)))) %&gt;%\n  tidyr::unnest_wider(mk)\nhead(ehsa)\n\n# A tibble: 6 × 6\n  County        tau        sl     S     D  varS\n  &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Anhua      0.191  0.303        26  136.  589.\n2 Anren     -0.294  0.108       -40  136.  589.\n3 Anxiang    0      1             0  136.  589.\n4 Baojing   -0.691  0.000128    -94  136.  589.\n5 Chaling   -0.0882 0.650       -12  136.  589.\n6 Changning -0.750  0.0000318  -102  136.  589.\n\n\nWe can sort the data-frame to highlight emerging hot/cold spots by implementing the below code chunk.\n\nemerging &lt;- ehsa %&gt;% \n  arrange(sl, abs(tau)) %&gt;% \n  slice(1:10)\nhead(emerging)\n\n# A tibble: 6 × 6\n  County        tau         sl     S     D  varS\n  &lt;chr&gt;       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Shuangfeng  0.868 0.00000143   118  136.  589.\n2 Xiangtan    0.868 0.00000143   118  136.  589.\n3 Xiangxiang  0.868 0.00000143   118  136.  589.\n4 Chengbu    -0.824 0.00000482  -112  136.  589.\n5 Dongan     -0.824 0.00000482  -112  136.  589.\n6 Wugang     -0.809 0.00000712  -110  136.  589."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#visualizing-the-distribution-of-ehsa-classes",
    "href": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#visualizing-the-distribution-of-ehsa-classes",
    "title": "In Class Exercise 6",
    "section": "6.4.1 Visualizing the distribution of EHSA Classes",
    "text": "6.4.1 Visualizing the distribution of EHSA Classes\nWe now implement various ggplot2 functions to reveal the distributions of EHSA classes as a bar chart.\n\nggplot(data = ehsa,\n       aes(x = classification)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nThe figure above shows that the ‘sporadic coldspot’ class has a high number of county’s."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#visualizing-ehsa",
    "href": "In-class_Ex/In-class_Ex6/In-class_Ex6.html#visualizing-ehsa",
    "title": "In Class Exercise 6",
    "section": "6.4.2 Visualizing EHSA",
    "text": "6.4.2 Visualizing EHSA\nBefore we can proceed with visualization, we need to join both hunan and ehsa together by using the code chunk below.\n\nhunan_ehsa &lt;- hunan %&gt;%\n  left_join(ehsa,\n            by = join_by(County == location))\n\nWe can now implement functions of the tmap package to produce a visualization for the above.\n\nehsa_sig &lt;- hunan_ehsa  %&gt;%\n  filter(p_value &lt; 0.05)\ntmap_mode(\"plot\")\ntm_shape(hunan_ehsa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(ehsa_sig) +\n  tm_fill(\"classification\") + \n  tm_borders(alpha = 0.4)\n\n\n\n\n\n\n\n\nWe can further look at this in greater detail by each location as well if required."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html",
    "title": "Take Home Exercise 2- Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics",
    "section": "",
    "text": "Tourism is one of Thailand’s largest industries, accounting for some 20% of the gross domestic product (GDP). In 2019, Thailand earned 90 billion US$ from domestic and international tourism, but the COVID-19 pandemic caused revenues to crash to 24 billion US$ in 2020.\nThe figure below shows the total revenue for the tourism sector from January 2019 until Feb 2023. The figure reveals that the revenue for the industry have been recovering gradually since September 2021.\n\nHowever, it is important to note that the tourism economy of Thailand is not evenly distributed- not all provinces make a lot of revenue.\nThe figure below reveals that the tourism economy of Thailand is carried by five provinces, namely Bangkok, Phuket, Chiang Mai, Sukhothai and Phetchaburi."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html#importing-the-data",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html#importing-the-data",
    "title": "Take Home Exercise 2- Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics",
    "section": "2.1 Importing the data",
    "text": "2.1 Importing the data\n\n2.1.1 Importing the aspatial data\nWe will now import the aspatial data by implementing the read_csv() function of the readr package as shown in the code chunk below.\n\ntourists=read_csv('data/aspatial/thailand_domestic_tourism_2019_2023.csv')\n# Summing the 'value' based on 'province_eng' and 'variable'\nsummed_data &lt;- tourists %&gt;%\n  group_by(province_eng, variable) %&gt;%\n  summarize(total_value = sum(value, na.rm = TRUE))\n\n# View the result\nhead(summed_data)\n\n# A tibble: 6 × 3\n# Groups:   province_eng [1]\n  province_eng  variable            total_value\n  &lt;chr&gt;         &lt;chr&gt;                     &lt;dbl&gt;\n1 Amnat Charoen net_profit_all           1075. \n2 Amnat Charoen net_profit_foreign         37.8\n3 Amnat Charoen net_profit_thai          1037. \n4 Amnat Charoen no_tourist_all         841477  \n5 Amnat Charoen no_tourist_foreign      12878  \n6 Amnat Charoen no_tourist_occupied    259406  \n\n\n\n\n2.1.2 Importing the geospatial data\nWe now import the geospatial data using the st_read() function of the sf package.\n\nprovince=st_read(dsn = \"data/geospatial\", \n                 layer = \"tha_admbnda_adm1_rtsd_20220121\")%&gt;%\n  select(1:5, 17)\n\nReading layer `tha_admbnda_adm1_rtsd_20220121' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\Take-home_Ex\\Take-home_Ex2\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 77 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n\n\n\n\n2.1.3 Performing relational join\nWe will now join the aspatial and geospatial data by using the left_join() function of the package as showing in the code chunk below.\n\npro_tourism=left_join(summed_data, province, by= c(\"province_eng\"=\"ADM1_EN\"))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html#visualizing-regional-indicators",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html#visualizing-regional-indicators",
    "title": "Take Home Exercise 2- Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics",
    "section": "2.3.1 Visualizing regional indicators",
    "text": "2.3.1 Visualizing regional indicators\nAfter successfully completing the relational join, we can now plot a choropleth map to visualize the tourism in each province in Thailand using various functions of the tmap package.\n\n2.3.1.1 Number of tourists\nWe first take a look at the number of tourists, both foreign and domestic, across all provinces in Thailand.\n\nNumber of Foreign TouristsNumber of Domestic Tourists\n\n\n\ntourist_foreign=pro_tourism%&gt;%\n  filter(variable=='no_tourist_foreign')%&gt;%\n  filter(!st_is_empty(geometry))\nprofit_foreigners=st_as_sf(tourist_foreign)\n\ntourist_foreign=st_as_sf(tourist_foreign)\n\n\n# Create the interactive basemap\nbasemap01 &lt;- tm_shape(tourist_foreign) +\n  tm_polygons(col = \"total_value\", palette = \"Blues\") +\n  tm_text(\"province_eng\", size = 0.5)\n\n# Display the interactive map\nbasemap01\n\n\n\n\n\n\n\n\n\n\n\ntourist_domestic=pro_tourism%&gt;%\n  filter(variable=='no_tourist_foreign')%&gt;%\n  filter(!st_is_empty(geometry))\nprofit_foreigners=st_as_sf(tourist_domestic)\n\ntourist_domestic=st_as_sf(tourist_domestic)\n\n\n# Create the interactive basemap\nbasemap02 &lt;- tm_shape(tourist_domestic) +\n  tm_polygons(col = \"total_value\", palette = \"Blues\") +\n  tm_text(\"province_eng\", size = 0.5)\n\n# Display the interactive map\nbasemap02\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.1.2 Revenue\nWe now take a look at the revenue generated by foreign and domestic tourists in Thailand\n\nRevenue generated by ForeignersRevenue generated by Domestic Tourists\n\n\n\nprofit_foreigners=pro_tourism%&gt;%\n  filter(variable=='net_profit_foreign')%&gt;%\n  filter(!st_is_empty(geometry))\nprofit_foreigners=st_as_sf(profit_foreigners)\n  \n\n\n# Create the interactive basemap\nbasemap &lt;- tm_shape(profit_foreigners) +\n  tm_polygons(col = \"total_value\", palette = \"Blues\", style= 'jenks') +\n  tm_text(\"province_eng\", size = 0.5)\n\n# Display the interactive map\nbasemap\n\n\n\n\n\n\n\n\n\n\n\nprofit_domestic=pro_tourism%&gt;%\n  filter(variable=='net_profit_thai')%&gt;%\n  filter(!st_is_empty(geometry))\nprofit_foreigners=st_as_sf(profit_domestic)\n\nprofit_domestic=st_as_sf(profit_domestic)\n\n\n# Create the interactive basemap\nbasemap2 &lt;- tm_shape(profit_domestic) +\n  tm_polygons(col = \"total_value\", palette = \"Blues\", style='jenks') +\n  tm_text(\"province_eng\", size = 0.5)\n\n# Display the interactive map\nbasemap2\n\n\n\n\n\n\n\n\n\n\n\nBangkok seems to be the most lucrative province for both foreign and domestic tourists.\n\nbasemap &lt;- tm_shape(profit_domestic) +\n  tm_polygons() +\n  tm_text(\"province_eng\", size=0.5)\n\ngdppc &lt;- qtm(profit_domestic, \"total_value\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html#spatial-weights",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex02.html#spatial-weights",
    "title": "Take Home Exercise 2- Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics",
    "section": "2.4.1 Spatial Weights",
    "text": "2.4.1 Spatial Weights\n\n2.4.1.1 Computing Contiguity Spatial Weights\nWe use the poly2nb() function as shown in the code chunk below. Using this, we are able to compute a Queen contiguity weight matrix.\n\n# Rook contiguity\nwm_r &lt;- poly2nb(profit_foreigners, queen=FALSE)\nwrite_rds(wm_r, 'data/rds/wm_r_pro_foreign')\n\n# Queen Contiguity\nwm_q &lt;- poly2nb(profit_foreigners, queen=TRUE)\nwrite_rds(wm_q, 'data/rds/wm_q_pro_foreign')\n\n\nRook ContiguityQueen Contiguity\n\n\n\nwm_r_pro_foreign=read_rds(\"data/rds/wm_r_pro_foreign\")\nsummary(wm_r_pro_foreign)\n\nNeighbour list object:\nNumber of regions: 69 \nNumber of nonzero links: 284 \nPercentage nonzero weights: 5.965133 \nAverage number of links: 4.115942 \n1 region with no links:\n42\n2 disjoint connected subgraphs\nLink number distribution:\n\n 0  1  2  3  4  5  6  7  9 \n 1  2  7 17 15 11 12  3  1 \n2 least connected regions:\n46 63 with 1 link\n1 most connected region:\n61 with 9 links\n\n\n\n\n\nwm_q_pro_foreign=read_rds(\"data/rds/wm_q_pro_foreign\")\nsummary(wm_q_pro_foreign)\n\nNeighbour list object:\nNumber of regions: 69 \nNumber of nonzero links: 284 \nPercentage nonzero weights: 5.965133 \nAverage number of links: 4.115942 \n1 region with no links:\n42\n2 disjoint connected subgraphs\nLink number distribution:\n\n 0  1  2  3  4  5  6  7  9 \n 1  2  7 17 15 11 12  3  1 \n2 least connected regions:\n46 63 with 1 link\n1 most connected region:\n61 with 9 links\n\n\n\n\n\n\nwm_r_pro_foreign=read_rds(\"data/rds/wm_r_pro_foreign\")\nsummary(wm_r_pro_foreign)\n\nNeighbour list object:\nNumber of regions: 69 \nNumber of nonzero links: 284 \nPercentage nonzero weights: 5.965133 \nAverage number of links: 4.115942 \n1 region with no links:\n42\n2 disjoint connected subgraphs\nLink number distribution:\n\n 0  1  2  3  4  5  6  7  9 \n 1  2  7 17 15 11 12  3  1 \n2 least connected regions:\n46 63 with 1 link\n1 most connected region:\n61 with 9 links\n\n\n\n\n2.4.1.2 Visualizing Contiguity Spatial Weights\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons in this situation, so we need to ensure that our points are in order to produce our connectivity graphs.\nUsually, the method of choice will be polygon centroids. We calculate using the sf package before moving onto the graphs. Getting latitude and longitude of the Polygon Centroids.\nWe need points to associate with each polygon before we can make our connectivity graph. It won’t be as simple as applying the st_centroid() function of the sf sf object: us.bound. We need the coordinates in a separate data-frame for this to work.\nTo do this, we will use a mapping function which will apply a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of us.bound.\nThe function that we implement in this situation will be st_centroid().\nWe will be using the map_dbl variation of map from the purrr package.\n\nLongitude & Latitude of Foreign TravellersLongitude and Latitude of Domestic Travellers\n\n\nWe start by extracting the longitude and latitude values for foreign travellers.\n\nlongitude_profit_foreign= map_dbl(profit_foreigners$geometry, ~st_centroid(.x)[[1]])\nlatitude_profit_foreign= map_dbl(profit_foreigners$geometry, ~st_centroid(.x)[[2]])\n\nNow that we have the latitude and longitude values, we can use the cbind() function to put the longitude and latitude values into the same object, coords.\n\ncoords_profit_foreign &lt;- cbind(longitude_profit_foreign, latitude_profit_foreign)\n\nWe use the head() function to verify if coords is in the correct format.\n\nhead(coords_profit_foreign)\n\n     longitude_profit_foreign latitude_profit_foreign\n[1,]                 104.7414                15.89261\n[2,]                 100.3485                14.62354\n[3,]                 100.6235                13.77183\n[4,]                 103.7109                18.14879\n[5,]                 101.4254                13.60649\n[6,]                 101.8194                16.03212\n\n\n\n\n\nlongitude_profit_domestic\n\n\nlatitude_profit_domestic=\n\nWe now create the coords object.\n\ncoords_profit_domestic\n\n\n\n\nWe can now visualize it using the plot() function as shown in the following code chunks.\n\nProfits from foreign travellersProfits from domestic travellers\n\n\n\nplot(profit_foreigners$geometry, border=\"lightgrey\")\nplot(wm_r_pro_foreign, coords_profit_foreign, pch = 19, cex = 0.6, add = TRUE, col = \"purple\")\n\n\n\n\n\n\n\n\n\n\n\nplot(profit_domestic$geometry, border=\"lightgrey\")\nplot(wm_r_pro_domestic, coords_profit_domestic, pch = 19, cex = 0.6, add = TRUE, col = \"purple\")\n\n\n\n\n\n\n2.4.1.3 Computing Distance Based Neighbors\nIn order to derive distance-based weight matrices, we will implement the dnearneigh() function of the spdep package.\nThis function identifies neighbors of region points by Euclidean Distance with a distance band with lower d1 and upper d2 bounds controlled by the bounds= argument.\nIf un-projected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid.\n\n2.4.1.3.1 Determining cut-off distance\nWe must first determine the upper limit for the distance band by using the steps shown below:\n\nFind k Nearest Neighbours: Use knearneigh() from the spdep package to get a matrix of indices for the k nearest neighbours of each point.\nConvert to Neighbours List: Convert the knn object returned by knearneigh() into a neighbours list of class nb using knn2nb(). This list contains integer vectors with neighbour region number IDs.\nCalculate Edge Lengths: Use nbdists() from spdep to return the lengths of neighbour relationship edges. The function returns distances in the units of the coordinates if projected, otherwise in kilometers.\nFlatten the List: Remove the list structure of the returned object using unlist()\n\n\nProfits from foreign travellersProfits from domestic travellers\n\n\n\n#coords &lt;- coordinates(hunan)\nk1_pro_foreign &lt;- knn2nb(knearneigh(coords_profit_foreign))\nk1dists_pro_foreign &lt;- unlist(nbdists(k1_pro_foreign, coords_profit_foreign, longlat = TRUE))\nsummary(k1dists_pro_foreign)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  21.55   52.52   69.06   66.79   77.42  124.72 \n\n\nFrom the output above, we can infer that the largest first nearest neighbor distance is just under 125KM. Using this value, 125KM, as the upper threshold gives certainty that all units will have at least one neighbor.\n\n\n\n\n\n\n\n\n2.4.1.3.2 Computing Distance Based Weight Matrix\nWe now implement the dnearneigh() function to compute the distance weight matrix.\n\nwm_d62_pro_foreign &lt;- dnearneigh(coords_profit_foreign, 0, 125, longlat = TRUE)\nwm_d62_pro_foreign\n\nNeighbour list object:\nNumber of regions: 69 \nNumber of nonzero links: 368 \nPercentage nonzero weights: 7.729469 \nAverage number of links: 5.333333 \n2 disjoint connected subgraphs\n\n\n\nFrom the output above, we infer that there are 69 distinct regions, as we identified earlier. There are 368 connections between regions where the distance is within the threshold that we have set. 7.73% of all possible region pairs have a connection. On average, each region is connected to approximately 5.3 other regions.\n\nWe now use the combination of table() and card() functions from the spdep package to display the structure of the weight matrix.\n\ntable(profit_foreigners$province_eng, card(wm_d62_pro_foreign))\n\n                          \n                           1 2 3 4 5 6 7 8 9 10 11 12 13 14\n  Amnat Charoen            0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Ang Thong                0 0 0 0 0 0 0 0 0  0  0  0  1  0\n  Bangkok                  0 0 0 0 0 0 0 0 0  0  0  0  1  0\n  Bueng Kan                0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Chachoengsao             0 0 0 0 0 0 0 0 1  0  0  0  0  0\n  Chaiyaphum               0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Chanthaburi              0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Chiang Mai               0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Chiang Rai               1 0 0 0 0 0 0 0 0  0  0  0  0  0\n  Chumphon                 1 0 0 0 0 0 0 0 0  0  0  0  0  0\n  Kalasin                  0 0 0 0 0 0 0 1 0  0  0  0  0  0\n  Kamphaeng Phet           0 0 0 0 1 0 0 0 0  0  0  0  0  0\n  Kanchanaburi             0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Khon Kaen                0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Krabi                    0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Lampang                  0 0 0 0 0 1 0 0 0  0  0  0  0  0\n  Lamphun                  0 0 0 0 1 0 0 0 0  0  0  0  0  0\n  Loei                     1 0 0 0 0 0 0 0 0  0  0  0  0  0\n  Mae Hong Son             0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Maha Sarakham            0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Mukdahan                 0 0 0 0 0 1 0 0 0  0  0  0  0  0\n  Nakhon Nayok             0 0 0 0 0 0 0 0 0  1  0  0  0  0\n  Nakhon Pathom            0 0 0 0 0 0 0 0 0  0  0  0  1  0\n  Nakhon Phanom            0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Nakhon Ratchasima        0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Nakhon Sawan             0 0 0 0 0 1 0 0 0  0  0  0  0  0\n  Nakhon Si Thammarat      0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Nan                      0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Narathiwat               0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Nong Khai                0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Nonthaburi               0 0 0 0 0 0 0 0 0  0  0  0  0  1\n  Pathum Thani             0 0 0 0 0 0 0 0 0  0  0  0  1  0\n  Pattani                  0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Phatthalung              0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Phayao                   0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Phetchabun               0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Phetchaburi              0 0 0 0 1 0 0 0 0  0  0  0  0  0\n  Phichit                  0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Phitsanulok              0 0 0 1 0 0 0 0 0  0  0  0  0  0\n  Phra Nakhon Si Ayutthaya 0 0 0 0 0 0 0 0 0  0  0  1  0  0\n  Phrae                    0 0 0 0 0 1 0 0 0  0  0  0  0  0\n  Phuket                   1 0 0 0 0 0 0 0 0  0  0  0  0  0\n  Prachuap Khiri Khan      1 0 0 0 0 0 0 0 0  0  0  0  0  0\n  Ranong                   0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Ratchaburi               0 0 0 0 0 0 0 1 0  0  0  0  0  0\n  Rayong                   0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Roi Et                   0 0 0 0 0 1 0 0 0  0  0  0  0  0\n  Sa Kaeo                  0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Sakon Nakhon             0 0 0 0 0 1 0 0 0  0  0  0  0  0\n  Samut Prakan             0 0 0 0 0 0 0 0 0  0  0  0  1  0\n  Samut Sakhon             0 0 0 0 0 0 0 0 0  0  1  0  0  0\n  Samut Songkhram          0 0 0 0 0 0 0 0 1  0  0  0  0  0\n  Saraburi                 0 0 0 0 0 0 0 0 0  0  1  0  0  0\n  Satun                    0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Sing Buri                0 0 0 0 0 0 0 0 0  1  0  0  0  0\n  Songkhla                 0 0 0 0 1 0 0 0 0  0  0  0  0  0\n  Sukhothai                0 0 0 0 0 0 1 0 0  0  0  0  0  0\n  Suphan Buri              0 0 0 0 0 0 0 0 0  0  0  0  1  0\n  Surat Thani              0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Surin                    1 0 0 0 0 0 0 0 0  0  0  0  0  0\n  Tak                      0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Trang                    0 0 0 0 1 0 0 0 0  0  0  0  0  0\n  Trat                     1 0 0 0 0 0 0 0 0  0  0  0  0  0\n  Ubon Ratchathani         0 1 0 0 0 0 0 0 0  0  0  0  0  0\n  Udon Thani               0 0 0 0 1 0 0 0 0  0  0  0  0  0\n  Uthai Thani              0 0 0 0 0 1 0 0 0  0  0  0  0  0\n  Uttaradit                0 0 0 0 1 0 0 0 0  0  0  0  0  0\n  Yala                     0 0 1 0 0 0 0 0 0  0  0  0  0  0\n  Yasothon                 0 0 0 0 1 0 0 0 0  0  0  0  0  0\n\n\nNext, we implement the n.comp.nb() function to identify the number of connected components in a neighbor list object of class nb.\n\nNote: A connected component is a subset of regions where each region is reachable from any other region within the same subset. The function returns an object that includes the number of connected components (nc) and a vector indicating the component membership for each region.\n\n\nn_comp_pro_foreign &lt;- n.comp.nb(wm_d62_pro_foreign)\nn_comp_pro_foreign$nc\n\n[1] 2\n\n\n\ntable(n_comp_pro_foreign$comp.id)\n\n\n 1  2 \n56 13 \n\n\n\n\n2.4.1.3.3 Plotting fixed distance weight matrix\nWe now plot the distance weight matrix using the plot() function.\n\nplot(profit_foreigners$geometry, border=\"lightgrey\")\nplot(wm_d62_pro_foreign, coords_profit_foreign, add=TRUE)\nplot(k1_pro_foreign, coords_profit_foreign, add=TRUE, col=\"purple\", length=0.08)\n\n\n\n\n\n\n\n\nAs identified earlier, we see two distinct groups. The upper 56 and the bottom 13.\n\npar(mfrow=c(1,2))\nplot(profit_foreigners$geometry, border=\"lightgrey\", main=\"1st nearest neighbours\")\nplot(k1_pro_foreign, coords_profit_foreign, add=TRUE, col=\"red\", length=0.08)\nplot(profit_foreigners$geometry, border=\"lightgrey\", main=\"Distance link\")\nplot(wm_d62_pro_foreign, coords_profit_foreign, add=TRUE, pch = 19, cex = 0.6)\n\n\n\n\n\n\n\n\n\n\n\n2.4.1.4 Weights based on Inversed Distance Weighting (IDW)\nWe first compute the distances between areas by implementing the nbdists() function of the spdep package.\n\ndist_pro_foreign &lt;- nbdists(wm_r_pro_foreign, coords_profit_foreign, longlat = TRUE)\nids_pro_foreign &lt;- lapply(dist_pro_foreign, function(x) 1/(x))\nids_pro_foreign\n\n[[1]]\n[1] 0.01283122 0.01137165 0.02317374\n\n[[2]]\n[1] 0.02756509 0.03127482 0.02029286\n\n[[3]]\n[1] 0.01128043 0.01701948 0.03322088 0.03024035 0.04641391 0.02007407\n\n[[4]]\n[1] 0.008785487 0.010451301 0.011784417\n\n[[5]]\n[1] 0.011280434 0.009026604 0.013713812 0.010525478 0.010089340 0.012920254\n\n[[6]]\n[1] 0.010963897 0.008134706 0.013026280\n\n[[7]]\n[1] 0.009026604 0.013102472 0.009765844 0.013223766\n\n[[8]]\n[1] 0.005984037 0.010253006 0.012763865 0.013589149 0.004349372\n\n[[9]]\n[1] 0.005984037 0.005799456 0.013165076\n\n[[10]]\n[1] 0.005327427 0.017306975 0.007000767\n\n[[11]]\n[1] 0.008769672 0.011775171 0.010437208 0.012343675 0.011493123 0.008361253\n\n[[12]]\n[1] 0.010254426 0.011527636 0.007714179 0.009533663 0.011111643\n\n[[13]]\n[1] 0.007385957 0.007716901 0.010982604 0.004211749 0.010358229\n\n[[14]]\n[1] 0.010963897 0.008769672 0.006691737 0.012916807 0.005943019 0.006514320\n[7] 0.008588872\n\n[[15]]\n[1] 0.01132654 0.00997081 0.01085922\n\n[[16]]\n[1] 0.010253006 0.005799456 0.015806184 0.008104541 0.016638036 0.008359249\n[7] 0.005157708\n\n[[17]]\n[1] 0.012763865 0.015806184 0.006403244\n\n[[18]]\n[1] 0.006691737 0.007140588 0.007375029 0.007976693 0.007671985\n\n[[19]]\n[1] 0.013589149 0.004073493\n\n[[20]]\n[1] 0.011775171 0.012916807 0.014293885 0.007462094\n\n[[21]]\n[1] 0.012831217 0.010437208 0.010934747 0.009660859 0.008504967 0.013119927\n\n[[22]]\n[1] 0.013713812 0.007685469 0.018047546 0.020717010\n\n[[23]]\n[1] 0.017019481 0.007385957 0.031941419 0.015333035 0.014028638 0.024413177\n[7] 0.012579923\n\n[[24]]\n[1] 0.008785487 0.010934747 0.015545066\n\n[[25]]\n[1] 0.008134706 0.005943019 0.007685469 0.007605151 0.008117703\n\n[[26]]\n[1] 0.010254426 0.007982010 0.014915995 0.011395871 0.005405036 0.012326369\n\n[[27]]\n[1] 0.011326537 0.009956219 0.005544296 0.009359481 0.010554311\n\n[[28]]\n[1] 0.012495409 0.009206376 0.007880812\n\n[[29]]\n[1] 0.01359979 0.01841909\n\n[[30]]\n[1] 0.010451301 0.007140588 0.008232097 0.017483864\n\n[[31]]\n[1] 0.03322088 0.03194142 0.02860548 0.02049667\n\n[[32]]\n[1] 0.03024035 0.01052548 0.01804755 0.02860548 0.02835278 0.01391843\n\n[[33]]\n[1] 0.01359979 0.01090219 0.01634790\n\n[[34]]\n[1] 0.009956219 0.013192981 0.012040582 0.019039684\n\n[[35]]\n[1] 0.013165076 0.008104541 0.012495409 0.008669969\n\n[[36]]\n[1] 0.013026280 0.006514320 0.007375029 0.007982010 0.011614531 0.009899588\n\n[[37]]\n[1] 0.009013905 0.015334899 0.016262271\n\n[[38]]\n[1] 0.01152764 0.01491600 0.01161453 0.01209489\n\n[[39]]\n[1] 0.007714179 0.007976693 0.009899588 0.012094889 0.010632695 0.011816759\n\n[[40]]\n[1] 0.02756509 0.01533303 0.02049667 0.02835278 0.01630089 0.01339948\n\n[[41]]\n[1] 0.016638036 0.009206376 0.008669969 0.009069811 0.014433186\n\n[[42]]\nnumeric(0)\n\n[[43]]\n[1] 0.005327427 0.009013905\n\n[[44]]\n[1] 0.01730698 0.00908563\n\n[[45]]\n[1] 0.007716901 0.014028638 0.015334899 0.014563573 0.023042875\n\n[[46]]\n[1] 0.01310247\n\n[[47]]\n[1] 0.012343675 0.014293885 0.009660859 0.008645806 0.017784128\n\n[[48]]\n[1] 0.010089340 0.009765844 0.007605151\n\n[[49]]\n[1] 0.011784417 0.011493123 0.008504967 0.015545066 0.008232097 0.009781624\n\n[[50]]\n[1] 0.04641391 0.01292025\n\n[[51]]\n[1] 0.02007407 0.02441318 0.01456357 0.02941852\n\n[[52]]\n[1] 0.01626227 0.02304288 0.02941852\n\n[[53]]\n[1] 0.020717010 0.008117703 0.013918429 0.016300886\n\n[[54]]\n[1] 0.01319298 0.01448029 0.01168217\n\n[[55]]\n[1] 0.03127482 0.01139587 0.01688512\n\n[[56]]\n[1] 0.005544296 0.010902192 0.012040582 0.014480293 0.008955556\n\n[[57]]\n[1] 0.009533663 0.008359249 0.010632695 0.009069811 0.008697288 0.009934394\n\n[[58]]\n[1] 0.02029286 0.01098260 0.01257992 0.01339948 0.01688512 0.01076819\n\n[[59]]\n[1] 0.007000767 0.009970810 0.009359481 0.009085630\n\n[[60]]\n[1] 0.007462094 0.008645806\n\n[[61]]\n[1] 0.004349372 0.011111643 0.004211749 0.005157708 0.006403244 0.004073493\n[7] 0.005405036 0.008697288 0.005949594\n\n[[62]]\n[1] 0.01085922 0.01055431 0.01903968 0.01168217\n\n[[63]]\n[1] 0.01322377\n\n[[64]]\n[1] 0.011371651 0.008739397\n\n[[65]]\n[1] 0.008361253 0.008588872 0.007671985 0.017483864 0.009781624\n\n[[66]]\n[1] 0.010358229 0.012326369 0.010768191 0.005949594\n\n[[67]]\n[1] 0.007880812 0.011816759 0.014433186 0.009934394\n\n[[68]]\n[1] 0.018419095 0.016347902 0.008955556\n\n[[69]]\n[1] 0.023173744 0.013119927 0.017784128 0.008739397\n\n\n\n\n2.4.1.5 Row-Standardized Weights Matrix\nWe now need to assign weights to each neighboring polygon. We use equal weights (style=“W”), where each neighboring polygon is assigned a weight of 1 divided by the number of neighbors.\nThis means each neighboring county’s weight is calculated as 1/(# of neighbors), and these weights are then used to sum the weighted income values.\nWhile this method is intuitive for summarizing neighbors’ values, it has a drawback: polygons at the edges of the study area may rely on fewer neighbors, potentially skewing the spatial autocorrelation results.\n\nNote: For simplicity, we’ll use the style=“W” option in this example, but be aware that more robust options, such as style=“B”, are available.\n\n\nrswm_r_pro_foreign &lt;- nb2listw(wm_r_pro_foreign, style=\"W\", zero.policy = TRUE)\nrswm_r_pro_foreign\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 69 \nNumber of nonzero links: 284 \nPercentage nonzero weights: 5.965133 \nAverage number of links: 4.115942 \n1 region with no links:\n42\n2 disjoint connected subgraphs\n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 68 4624 68 36.26116 284.0635\n\n\nSetting the argument zero.policy to TRUE allows for lists of non-neighbors. This should be used with caution as users may not be aware of missing neighbors in their data however setting zero,policy to FALSE would return an error.\nThe code chunk below is implemented to check the weights of the first polygons three neighbors type:\n\nrswm_r_pro_foreign$weights[10]\n\n[[1]]\n[1] 0.3333333 0.3333333 0.3333333\n\n\n\nEach neighbor is assigned a 0.33 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.125 before being tallied.\n\nUsing the same method, we derive a row standardized distance weight matrix by using the code chunk below.\n\nrswm_ids_pro_foreign &lt;- nb2listw(wm_r_pro_foreign, glist=ids_pro_foreign, style=\"B\", zero.policy=TRUE)\nrswm_ids_pro_foreign\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 69 \nNumber of nonzero links: 284 \nPercentage nonzero weights: 5.965133 \nAverage number of links: 4.115942 \n1 region with no links:\n42\n2 disjoint connected subgraphs\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1        S2\nB 68 4624 3.603816 0.1156751 0.9708891\n\n\n\n\n2.4.1.6 Application of Spatial Weight Matrix\nWe now create four different spatial lagged variables:\n\nspatial lag with row-standardized weights\nspatial lag as a sum of neighbouring values\nspatial window average\nspatial window sum\n\n\n2.4.1.6.1 Spatial Lag With Row-Standardized Weights\nWe now compute the average neighbor profit value for each polygon. We often refer to these values as Spatially Lagged Values.\n\npro_foreign.lag &lt;- lag.listw(rswm_r_pro_foreign, profit_foreigners$total_value)\npro_foreign.lag\n\n [1]   8515.193  17968.737   9786.125   8146.420 134596.605  38955.723\n [7]  30027.315  25849.308  69950.727  49495.860  14466.082  12682.008\n[13]  12285.500  17722.284  32856.583  45153.527  74359.923  24181.276\n[19] 105254.185  13518.028   3746.675  23303.505 127335.297   5904.817\n[25]  18962.564   9199.730  41815.892   5435.180   3151.225  11707.842\n[31] 199104.537 139465.317  23475.267  34077.745  27604.423  16031.888\n[37]  38026.663  15162.938   9194.675  11038.343   7792.872      0.000\n[43]  46017.585  31137.765  36364.686  20841.120   4422.484  30034.113\n[49]   9350.865 377986.320 193862.645  30662.133  28195.245  29101.100\n[55]  10132.620  13507.610  11402.520  22217.052  32074.963   3159.425\n[61]  35931.461  33712.050  20841.120   1412.345  14707.668  30176.722\n[67]  11022.135  22918.337   7102.637\n\n\nWe can append the spatially lagged profit values onto our profit_foreigners sf data-frame by using the code chunk shown below.\n\nlag.list_pro_foreign &lt;- list(profit_foreigners$province_eng, lag.listw(rswm_r_pro_foreign, profit_foreigners$total_value))\nlag.res_pro_foreign &lt;- as.data.frame(lag.list_pro_foreign)\ncolnames(lag.res_pro_foreign) &lt;- c(\"province_eng\", \"lag Profit\")\nprofit_foreigners &lt;- left_join(profit_foreigners,lag.res_pro_foreign)\n\nWe now plot the actual profit and spatial lag profits side by side to facilitate comparison.\n\npro_foreign &lt;- qtm(profit_foreigners, \"total_value\")\nlag_pro_foreign &lt;- qtm(profit_foreigners, \"lag Profit\")\ntmap_arrange(pro_foreign, lag_pro_foreign, asp=1, ncol=2)\n\n\n\n\n\n\n\n\nWe see a difference in the surrounding regions of Bangkok as well as Mae Hong Son, all of which are in a higher band as compared to the non-spatially lagged values.\n\n\n2.4.1.6.2 Spatial Lag as a sum of neighboring values\nWe can calculate spatial lag as a sum of neighboring values by assigning binary weights. For this, we must apply a function that will assign binary weights to our neighbors list. We then use the glist argument in the nb2listw function to explicitly assign these weights.\nWe first apply a function that assigns a value of 1 per neighbor. This is done with help of lapply(), which helps manipulate the neighbors structure. It basically applies a function across each value in the neighbors structure.\n\nb_weights &lt;- lapply(wm_r_pro_foreign, function(x) 0*x + 1)\nb_weights2 &lt;- nb2listw(wm_r_pro_foreign, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2"
  }
]