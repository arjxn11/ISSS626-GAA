[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS626-GAA",
    "section": "",
    "text": "Introduction\nWelcome to my journey through ISSS626 Geospatial Analytics. This website contains my coursework that were completed through this course.\n\n\n\nAbout\nMy name is Arjun Singh and I am a student at Singapore Management University pursuing a Masters degree in Analytics. This website documents my journey of learning Geospatial Analytics under the guidance of Professor Tin Seong Kam.\nIf you have any inquiries, feel free to reach out to me at arjun.singh.2023@smu.edu.sg\n“It is a rough road that leads to the heights of greatness.”- Seneca"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html",
    "title": "Take Home Exercise 1",
    "section": "",
    "text": "According to the World Health Organisation (WHO), road traffic accidents cause approximately 1.19 million deaths annually and result in between 20 and 50 million people with being down with non-fatal injuries. Over half of all road traffic deaths occur among vulnerable road users, such as pedestrians, cyclists and motorcyclists.\nRoad traffic injuries are the leading cause of death for children and young adults aged 5–29 while two-thirds of road traffic fatalities occur among people of working age (18–59 years). 9 in 10 fatalities on the roads occur in low and middle-income countries, even though these countries have only around 60% of the world’s vehicles.\nIn addition to the human suffering caused by road traffic injuries, they also inflict a heavy economic burden on victims and their families, both through treatment costs for the injured and through loss of productivity of those killed or disabled. More broadly, road traffic injuries have a serious impact on national economies, costing countries 3% of their annual GDP.\nThailand’s roads are the deadliest in Southeast Asia and among the worst in the world, according to the World Health Organisation. About 20,000 people die in road accidents each year, or about 56 deaths a day (WHO).\nBetween 2014 and 2021, Thailand experienced a notable increase in accidents. Specifically, 19% of all accidents in Thailand occurred on the national highways, which constituted the primary public thoroughfares connecting various regions, provinces, districts, and significant locations within a comprehensive network.\nWithin the broader context of accidents across the country, there existed a considerable 66% likelihood of encountering accident-prone zones, often termed ‘black spots,’ distributed as follows: 66% on straight road segments, 13% at curves, 6% at median points of cross-shaped intersections, 5% at T-shaped intersections and Y-shaped intersections, 3% at cross-shaped intersections, 2% on bridges, and 2% on steep slopes, respectively."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#aspatial-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#aspatial-data",
    "title": "Take Home Exercise 1",
    "section": "1.2.1 Aspatial Data",
    "text": "1.2.1 Aspatial Data\nWe first import in the data-frame contained data of all accidents in the Bangkok Metropolitan Region. For this, we implement the read_rds() function as shown in the code chunk below.\n\nrdacc_sf=read_rds(\"data/rds/acc_sf\")%&gt;% \n  mutate(hourofday= hour(incident_datetime))%&gt;%\n  mutate(traffic_period = case_when(\n    # Define peak hours: 7-9 AM and 4-7 PM (16-19 in 24-hour format)\n    hourofday &gt;= 7 & hourofday &lt;= 9 ~ \"Peak\",\n    hourofday &gt;= 16 & hourofday &lt;= 19 ~ \"Peak\",\n    TRUE ~ \"Off-Peak\"  # Everything else is off-peak\n  ))\nst_crs(rdacc_sf)\n\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#geospatial-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#geospatial-data",
    "title": "Take Home Exercise 1",
    "section": "1.2.2 Geospatial Data",
    "text": "1.2.2 Geospatial Data\nWe import the OpenStreetMap export of Thailand into our environment using the st_read() function.\n\nroad_sf &lt;- st_read(dsn = \"data/rawdata\", layer=\"hotosm_tha_roads_lines_shp\")\n\n\nIt is important to note the details shown in the output above. Most important takeaway from the above output is that there is no CRS information. This information is crucial as it informs our data preparation steps. We must ensure that the right CRS information is set in order to carry out analysis.\n\nBelow, we import the boundary data. map_sf is the boundary data at the province level (ADM1), while map2_sf is the boundary data at the district level (ADM2). We will be using both over the course of our analysis.\n\nmap_sf &lt;- st_read(dsn = \"data/rawdata\", layer=\"tha_admbnda_adm1_rtsd_20220121\")\n\nReading layer `tha_admbnda_adm1_rtsd_20220121' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\Take-home_Ex\\Take-home_Ex1\\data\\rawdata' \n  using driver `ESRI Shapefile'\nSimple feature collection with 77 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n\n\n\nmap2_sf &lt;- st_read(dsn = \"data/rawdata\", layer=\"tha_admbnda_adm2_rtsd_20220121\")\n\nReading layer `tha_admbnda_adm2_rtsd_20220121' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\Take-home_Ex\\Take-home_Ex1\\data\\rawdata' \n  using driver `ESRI Shapefile'\nSimple feature collection with 928 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n\n\nAfter importing the boundary data, we notice immediately that the EPSG code isn’t accurate. The EPSG code of Thailand is 32647 while the data-frame has an EPSG code of 4326.\nWe use the st_transform() function to convert the EPSG code to the correct value of 32647.\n\nmap_sf=st_transform(map_sf,crs = 32647)\nmap2_sf=st_transform(map2_sf,crs = 32647)\n\nGiven that the OSM data-frame has no CRS information, we will first initialize it to WGS84 using the default EPSG code of 4326 by using the st_set_crs() function of the sf package.\n\nroad_sf=st_set_crs(road_sf, 4326)\n\nWe will then implement the st_crs() function to verify if the boundary data has the accurate CRS information after we transformed it above.\n\nst_crs(map_sf)\n\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Navigation and medium accuracy spatial referencing.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#data-preparation-and-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#data-preparation-and-wrangling",
    "title": "Take Home Exercise 1",
    "section": "1.2.3 Data Preparation and Wrangling",
    "text": "1.2.3 Data Preparation and Wrangling\nGiven our area of interest is the Bangkok Metropolitan Region, we create a list of all provinces in this area in order to facilitate filtering for our analysis.\n\nbmr_province=c(\"Bangkok\", \"Samut Prakan\", \"Samut Sakhon\", \"Nonthaburi\", \"Nakhon Pathom\", \"Pathum Thani\")\n\nBelow, we implement the filter() function in order to filter the boundary data, at the province and district level, as well as the accident data, down to our region of interest- the Bangkok Metropolitan Region.\n\nbmr_boundary=map_sf %&gt;% \n  filter(ADM1_EN %in% bmr_province)\nbmr_boundary2=map2_sf %&gt;% \n  filter(ADM1_EN %in% bmr_province)\nbmr_accsf=rdacc_sf %&gt;% \n  filter(province_en %in% bmr_province)\n\n\nst_bbox(bmr_boundary)\n\n     xmin      ymin      xmax      ymax \n 587893.5 1484413.7  712440.5 1579076.3 \n\n\nWe now implement the st_crs() function in order to transform the EPSG code of the road_sf data-frame from 4326 to 32647. This allows us to have the accurate geometry values to facilitate future spatial joins, as well as analysis.\n\n# If road_sf was originally in EPSG:4326, reproject it properly\nroad_sf &lt;- st_transform(road_sf, crs = 32647)\n\nAfter ensuring that the CRS values are consistent, we can proceed with implementing the st_intersection() function and join the two data-frames based on their geometries.\nThe st_intersection() function is applied at the province level below.\n\nbmr_roads=st_intersection(map2_sf, road_sf)\n\nAs earlier, we will save this as an RDS file in order to improve computational efficiency.\n\nwrite_rds(bmr_roads, \"data/rds/bmrroads\")\n\n\nbmr_roads=read_rds(\"data/rds/bmrroads\")\n\nBelow, the st_intersection() function is applied at the district level and saved as an RDS file.\n\nbmr_districts=st_intersection(map2_sf, bmr_roads)\nwrite_rds(\"data/rds/bmr_districts_roads\")\n\n\nbmr_districts=read_rds(\"data/rds/bmr_districts_roads\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#converting-the-kde-output-into-a-grid-object",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#converting-the-kde-output-into-a-grid-object",
    "title": "Take Home Exercise 1",
    "section": "Converting the KDE output into a grid object",
    "text": "Converting the KDE output into a grid object\n\nGridded raster\nWe convert the gridded kernel density objects into RasterLayer object by using raster() of the raster package.\n\nkde_bmracc_bw_raster &lt;- raster(kde_bmracc.bw)\n\nThe CRS above is NA, so we now set the CRS to EPSG 32647 of Thailand.\nAfter that, we can implement the plot() function to plot the same.\n\nprojection(kde_bmracc_bw_raster) &lt;- CRS(\"+init=EPSG:32647\")\nplot(kde_bmracc_bw_raster)\n\n\n\n\n\n\n\n\nFrom the above, we infer that the south-east region of Bangkok Metropolitan Region, Samut Prakan Province, specifically has a few hotspots, we want to further analyze the cause of this, so we filter down our data.\n\nsmt_prk_bndry=bmr_boundary%&gt;%filter(ADM1_EN=='Samut Prakan')\nqtm(smt_prk_bndry)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-weights",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-weights",
    "title": "Take Home Exercise 1",
    "section": "1.4.3 Spatial Weights",
    "text": "1.4.3 Spatial Weights\nWe now create a data-frame, boundary_with_accident_count, in order to assign Spatial Weights and carry out further analysis.\nWe start off by conducting a spatial join with the help of the st_join() function of the sf package to join bmr_accsf, accident data of the Bangkok Metropolitan Region.\nWe then use the left_join() function of the dplyr package to join this with the boundary data in order to facilitate analysis.\nWe then save it as an RDS file.\n\naccidents_with_districts &lt;- st_join(bmr_accsf, bmr_boundary2, join = st_intersects)\n# Group by adm2_en and count the number of accidents per district\naccident_counts_by_adm2 &lt;- accidents_with_districts %&gt;%\n  group_by(ADM2_EN) %&gt;%\n  summarise(accident_count = n())\n\n# Perform a left join with the boundary data\nboundary_with_accident_count &lt;- bmr_boundary2 %&gt;%\n  st_join(accident_counts_by_adm2, by = \"ADM2_EN\")\nboundary_with_accident_count &lt;- boundary_with_accident_count %&gt;%\n  mutate(accident_count = ifelse(is.na(accident_count), 0, accident_count))\nwrite_rds(boundary_with_accident_count, \"data/rds/boundary_with_acc_count\")\n\n\nboundary_with_accident_count=read_rds(\"data/rds/boundary_with_acc_count\")\n\nAfter successfully completing the relational join, we can now plot a choropleth map to visualize the number of accidents in the Bangkok Metropolitan Region using various functions of the tmap package\n\nbasemap &lt;- tm_shape(boundary_with_accident_count) +\n  tm_polygons() +\n  tm_text(\"ADM2_EN.x\", size=0.5)\ngdppc &lt;- qtm(boundary_with_accident_count, \"accident_count\")\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\nThe above map reinforces our earlier finding that the Eastern/South-Eastern region of the Bangkok Metropolitan Region have the most accidents. One district in the bottom left, part of the Samut Sakhon province, also has a high volume of accidents.\n\n1.4.3.1 Computing Contiguity Spatial Weights\nWe now implement the poly2nb() function of the spdep package to compute contiguity weight matrices for the study area selected.\nUsing this function, we are able to build a ‘neighbors list’ based on regions with contiguous boundaries.\nIn this function, we will pass an argument, ‘queen’, that can be set as either TRUE (default) or FALSE. If the ‘queen’ argument is not explicitly set to FALSE, the function returns a list of first order neighbors using the Queen criteria.\nYou may refer to the spdep package documentation here to learn more about its functions and arguments.\n\n1.4.3.1.1 Computing (QUEEN) contiguity based neighbors\nThe poly2nb() function is implemented as shown in the code chunk below. Using this, we are able to compute a Queen contiguity weight matrix.\n\nwm_q &lt;- poly2nb(boundary_with_accident_count, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 1  5 10 24 20 12  6  1 \n1 least connected region:\n66 with 2 links\n1 most connected region:\n30 with 9 links\n\n\nThe most connected area has 9 neighbors. In general, most districts have approximately 5 to 6 neighbors.\n\n\n1.4.3.1.2 Computing (ROOK) contiguity based neighbors\nFor this, we will set the queen argument of the poly2nb() function to false.\n\nwm_r &lt;- poly2nb(boundary_with_accident_count, queen=FALSE) \nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 422 \nPercentage nonzero weights: 6.761737 \nAverage number of links: 5.341772 \nLink number distribution:\n\n 2  3  4  5  6  7  8 \n 1  5 16 20 22 11  4 \n1 least connected region:\n66 with 2 links\n4 most connected regions:\n1 5 17 54 with 8 links\n\n\nThe most connected area has 8 neighbors. In general, most districts have approximately 5 to 6 neighbors.\n\n\n\n1.4.3.2 Visualizing contiguity weights\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons in this situation, so we need to ensure that our points are in order to produce our connectivity graphs.\nUsually, the method of choice will be polygon centroids. We calculate using the sf package before moving onto the graphs. Getting latitude and longitude of the Polygon Centroids.\nWe need points to associate with each polygon before we can make our connectivity graph. It won’t be as simple as applying the st_centroid() function of the sf sf object: us.bound. We need the coordinates in a separate data-frame for this to work.\nTo do this, we will use a mapping function which will apply a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of us.bound.\nThe function that we implement in this situation will be st_centroid().\nWe will be using the map_dbl variation of map from the purrr package.\n\n1.4.3.2.1 Obtaining Coordinate values\n\nLongitudeLatitudeCoords\n\n\n\nlongitude &lt;- map_dbl(boundary_with_accident_count$geometry, ~st_centroid(.x)[[1]])\n\n\n\n\nlatitude &lt;- map_dbl(boundary_with_accident_count$geometry, ~st_centroid(.x)[[2]])\n\n\n\nNow that we have the latitude and longitude values, we can use the cbind() function to put the longitude and latitude values into the same object, coords.\n\ncoords &lt;- cbind(longitude, latitude)\n\n\nhead(coords)\n\n     longitude latitude\n[1,]  661951.4  1521172\n[2,]  664121.1  1523923\n[3,]  700735.2  1532207\n[4,]  664808.5  1518057\n[5,]  676193.5  1533602\n[6,]  677305.1  1522820\n\n\n\n\n\nWe can now plot the contiguity weights side by side for comparison.\n\npar(mfrow=c(1,2))\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"purple\")\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"darkgreen\")\n\n\n\n\n\n\n\n\n\n\nQueen Contiguity creates more connections as seen above, as it considers both shared vertices AND edges. This results in a more dense network.\nRook Contiguity results in fewer connections as it only considers shared borders as opposed to Queen Contiguity. This results in a simpler network.\n\n\nWe often use these in order to proceed with Spatial Autocorrelation Analysis to understand the neighbors taken into consideration amongst other factors.\n\n\n\n1.4.3.3 Adaptive Distance Weight Matrix\nOne of the characteristics of fixed distance weight matrices is that the more densely settled areas (usually urban areas) tend to have more neighbors and the less densely settled areas (usually rural areas) tend to have lesser neighbors.\nHaving many neighbors smoothens the neighbor relationship across more neighbors.\nIt is possible to control the numbers of neighbors directly using k-nearest neighbors by either accepting asymmetric neighbors or imposing symmetry\n\nknn6 &lt;- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 474 \nPercentage nonzero weights: 7.594937 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nWe immediately see a difference when comparing the above output to wm_q and wm_r. The number of non-zero links is higher.\nWe can create the plot for the same using the plot() function.\n\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\n\n\n\n1.4.3.4 Row standardized weights matrix\n\n1.4.3.4.1 Weights Based on Inversed Distance Weighting (IDW)\nWe first compute the distances between areas by implementing the nbdists() function of the spdep package.\n\ndist &lt;- nbdists(wm_q, coords, longlat = FALSE)\nids &lt;- lapply(dist, function(x) 1/(x))\nids\n\n[[1]]\n[1] 0.0002854535 0.0006582134 0.0004566217 0.0002167536 0.0003080119\n[6] 0.0002757322 0.0003371576 0.0002806965\n\n[[2]]\n[1] 0.0002854535 0.0002055287 0.0003012437 0.0003439200 0.0003703229\n[6] 0.0002193608 0.0001383976 0.0002982074\n\n[[3]]\n[1] 8.230456e-05 7.194802e-05 7.691011e-05 6.386761e-05\n\n[[4]]\n[1] 0.0005397094 0.0003348823 0.0004742967 0.0004145926 0.0006228750\n\n[[5]]\n[1] 1.466707e-04 1.197978e-04 1.317261e-04 1.901079e-04 1.449448e-04\n[6] 2.005737e-04 1.397857e-04 8.481219e-05\n\n[[6]]\n[1] 0.0001622765 0.0002212846 0.0002009303 0.0001431074 0.0001781389\n[6] 0.0002901167\n\n[[7]]\n[1] 0.0002055287 0.0005397094 0.0003428497 0.0003432013 0.0003504051\n[6] 0.0002113326 0.0005031250 0.0001878859\n\n[[8]]\n[1] 0.0006582134 0.0003012437 0.0003348823 0.0003428497 0.0007193454\n\n[[9]]\n[1] 0.0001452881 0.0001919620 0.0002478517 0.0001846853 0.0003608347\n[6] 0.0001275280\n\n[[10]]\n[1] 8.230456e-05 1.204212e-04 1.185473e-04 1.177461e-04 1.338999e-04\n\n[[11]]\n[1] 7.194802e-05 1.204212e-04 7.412539e-05 8.957108e-05 5.200876e-05\n[6] 6.530843e-05 8.333031e-05\n\n[[12]]\n[1] 0.0002120327 0.0003601503 0.0003033661 0.0002204848 0.0002299417\n\n[[13]]\n[1] 0.0004566217 0.0004742967 0.0003432013 0.0007193454 0.0005352046\n\n[[14]]\n[1] 0.0003439200 0.0004723701 0.0002181006 0.0001852359 0.0003556913\n\n[[15]]\n[1] 0.0002167536 0.0004178016 0.0005004725 0.0002059056 0.0002024628\n[6] 0.0002988328 0.0002534194\n\n[[16]]\n[1] 0.0003080119 0.0004178016 0.0001666057 0.0003222415 0.0002506523\n\n[[17]]\n[1] 0.0001622765 0.0004355978 0.0001468778 0.0001493430 0.0002022661\n[6] 0.0001455745 0.0002525101 0.0003209334\n\n[[18]]\n[1] 0.0002757322 0.0004145926 0.0005352046 0.0005004725 0.0003077165\n[6] 0.0003335152\n\n[[19]]\n[1] 0.0001666057 0.0002462888 0.0001860044 0.0001509068 0.0001330087\n[6] 0.0001378191 0.0002092546\n\n[[20]]\n[1] 0.0003371576 0.0003222415 0.0002462888 0.0001834292 0.0002732088\n\n[[21]]\n[1] 8.969997e-05 1.203769e-04 1.245294e-04 9.569804e-05 4.958860e-05\n\n[[22]]\n[1] 0.0002059056 0.0002506523 0.0001860044 0.0001834292 0.0002152303\n[6] 0.0001971194 0.0001095917\n\n[[23]]\n[1] 2.053579e-04 1.119769e-04 1.692192e-04 6.579843e-05 1.036058e-04\n\n[[24]]\n[1] 0.0002120327 0.0002024628 0.0003529966 0.0002347366 0.0001982741\n[6] 0.0001621175\n\n[[25]]\n[1] 0.0002806965 0.0003703229 0.0001509068 0.0002732088 0.0001935337\n[6] 0.0001208318\n\n[[26]]\n[1] 0.0004723701 0.0004355978 0.0001754699 0.0003013611\n\n[[27]]\n[1] 0.0001466707 0.0002212846 0.0002022599 0.0003179325 0.0001494025\n\n[[28]]\n[1] 0.0006228750 0.0003504051 0.0003601503 0.0003077165 0.0003330968\n[6] 0.0002241661\n\n[[29]]\n[1] 2.193608e-04 2.181006e-04 1.935337e-04 2.480081e-04 1.269610e-04\n[6] 1.731795e-04 8.705329e-05\n\n[[30]]\n[1] 0.0001383976 0.0001197978 0.0001852359 0.0001468778 0.0001754699\n[6] 0.0002480081 0.0002134931 0.0001692547 0.0001150417\n\n[[31]]\n[1] 0.0003033661 0.0002988328 0.0003335152 0.0003529966 0.0003330968\n\n[[32]]\n[1] 1.452881e-04 7.412539e-05 1.648225e-04 1.385556e-04 1.384360e-04\n[6] 9.877756e-05\n\n[[33]]\n[1] 0.0002113326 0.0001919620 0.0002204848 0.0002241661 0.0004631083\n[6] 0.0001381990\n\n[[34]]\n[1] 0.0002009303 0.0002478517 0.0001493430 0.0001648225 0.0002087434\n[6] 0.0001252900\n\n[[35]]\n[1] 2.534194e-04 8.969997e-05 2.152303e-04 2.347366e-04 1.338459e-04\n[6] 1.190158e-04\n\n[[36]]\n[1] 1.317261e-04 1.741388e-04 1.477787e-04 9.360890e-05 1.023839e-04\n[6] 4.522313e-05\n\n[[37]]\n[1] 0.0002982074 0.0005031250 0.0003556913 0.0002022661 0.0003013611\n[6] 0.0001760696\n\n[[38]]\n[1] 0.0001901079 0.0001431074 0.0001455745 0.0002022599 0.0002134931\n[6] 0.0001969405\n\n[[39]]\n[1] 0.0001878859 0.0001846853 0.0002525101 0.0004631083 0.0002087434\n[6] 0.0001760696\n\n[[40]]\n[1] 0.0001330087 0.0001971194 0.0002053579 0.0001396487 0.0001509543\n\n[[41]]\n[1] 0.0001449448 0.0001269610 0.0001692547 0.0001741388 0.0001155726\n[6] 0.0001062678\n\n[[42]]\n[1] 2.005737e-04 1.477787e-04 1.006357e-04 5.914874e-05\n\n[[43]]\n[1] 0.0001397857 0.0001185473 0.0003179325 0.0001503042 0.0001120205\n\n[[44]]\n[1] 1.781389e-04 1.177461e-04 8.957108e-05 1.494025e-04 1.385556e-04\n[6] 1.252900e-04 1.503042e-04\n\n[[45]]\n[1] 0.0002901167 0.0003209334 0.0001969405\n\n[[46]]\n[1] 7.691011e-05 8.481219e-05 1.338999e-04 1.006357e-04 1.120205e-04\n[6] 7.834800e-05\n\n[[47]]\n[1] 3.608347e-04 1.384360e-04 8.847607e-05 7.825942e-05 1.380165e-04\n\n[[48]]\n[1] 1.378191e-04 1.119769e-04 1.396487e-04 1.390484e-04 5.812114e-05\n[6] 9.420908e-05\n\n[[49]]\n[1] 0.0001203769 0.0001982741 0.0001338459 0.0001460302 0.0001218403\n\n[[50]]\n[1] 1.245294e-04 1.095917e-04 1.692192e-04 1.190158e-04 1.509543e-04\n[6] 4.881437e-05 7.827893e-05\n\n[[51]]\n[1] 8.847607e-05 4.260505e-05 9.775096e-05 7.211651e-05 6.976002e-05\n\n[[52]]\n[1] 5.200876e-05 4.260505e-05 6.461671e-05 1.208164e-04\n\n[[53]]\n[1] 6.530843e-05 9.877756e-05 7.825942e-05 9.775096e-05 6.461671e-05\n[6] 1.098016e-04\n\n[[54]]\n[1] 1.275280e-04 2.299417e-04 1.621175e-04 1.381990e-04 1.380165e-04\n[6] 1.460302e-04 7.211651e-05 8.749710e-05\n\n[[55]]\n[1] 9.569804e-05 1.218403e-04 6.976002e-05 8.749710e-05\n\n[[56]]\n[1] 8.333031e-05 1.208164e-04 1.098016e-04\n\n[[57]]\n[1] 0.0001731795 0.0001150417 0.0001155726 0.0001121332 0.0000764271\n[6] 0.0000755279 0.0001320269\n\n[[58]]\n[1] 2.092546e-04 1.208318e-04 8.705329e-05 1.390484e-04 1.121332e-04\n[6] 1.356813e-04 6.810787e-05\n\n[[59]]\n[1] 7.642710e-05 1.356813e-04 1.153320e-04 5.588948e-05 1.070876e-04\n\n[[60]]\n[1] 7.552790e-05 1.153320e-04 8.048614e-05 9.201600e-05 7.698649e-05\n\n[[61]]\n[1] 5.588948e-05 8.048614e-05 8.676092e-05 7.105006e-05 5.108714e-05\n\n[[62]]\n[1] 9.360890e-05 1.062678e-04 1.320269e-04 9.201600e-05 1.156307e-04\n[6] 6.087272e-05\n\n[[63]]\n[1] 1.023839e-04 1.156307e-04 5.287764e-05 4.047452e-05 6.619029e-05\n[6] 3.620195e-05 9.994772e-05\n\n[[64]]\n[1] 5.287764e-05 8.616137e-05 5.274538e-05 6.005288e-05\n\n[[65]]\n[1] 4.047452e-05 8.616137e-05 5.965942e-05 1.524056e-04\n\n[[66]]\n[1] 5.274538e-05 5.965942e-05\n\n[[67]]\n[1] 7.698649e-05 8.676092e-05 6.087272e-05 6.619029e-05 7.655740e-05\n\n[[68]]\n[1] 6.386761e-05 4.522313e-05 5.914874e-05 7.834800e-05 3.620195e-05\n[6] 1.524056e-04\n\n[[69]]\n[1] 9.994772e-05 6.005288e-05 7.655740e-05\n\n[[70]]\n[1] 4.117989e-05 5.885227e-05 6.155251e-05 4.225974e-05\n\n[[71]]\n[1] 4.117989e-05 5.953357e-05 4.110606e-05\n\n[[72]]\n[1] 5.885227e-05 5.899804e-05 4.000195e-05 8.692110e-05 8.457300e-05\n\n[[73]]\n[1] 6.155251e-05 5.953357e-05 5.899804e-05 6.741263e-05\n\n[[74]]\n[1] 7.105006e-05 4.110606e-05 4.000195e-05 6.741263e-05 3.789103e-05\n\n[[75]]\n[1] 6.579843e-05 5.812114e-05 4.225974e-05 8.692110e-05 7.172077e-05\n[6] 1.056880e-04 5.465069e-05\n\n[[76]]\n[1] 9.420908e-05 6.810787e-05 1.070876e-04 5.108714e-05 8.457300e-05\n[6] 3.789103e-05 7.172077e-05\n\n[[77]]\n[1] 4.958860e-05 4.881437e-05 7.004105e-05 6.324110e-05\n\n[[78]]\n[1] 1.036058e-04 7.827893e-05 1.056880e-04 7.004105e-05 5.420721e-05\n\n[[79]]\n[1] 5.465069e-05 6.324110e-05 5.420721e-05\n\n\nWe now need to assign weights to each neighboring polygon. We use equal weights (style=“W”), where each neighboring polygon is assigned a weight of 1 divided by the number of neighbors.\nThis means each neighboring county’s weight is calculated as 1/(# of neighbors), and these weights are then used to sum the weighted income values.\nWhile this method is intuitive for summarizing neighbors’ values, it has a drawback: polygons at the edges of the study area may rely on fewer neighbors, potentially skewing the spatial autocorrelation results.\n\n\nNote on style argument\n\n\nNote: For simplicity, we’ll use the style=“W” option in this example, but be aware that more robust options, such as style=“B”, are available.\n\n\n\nrswm_q &lt;- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0      S1       S2\nW 79 6241 79 29.8143 321.0615\n\n\nSetting the argument zero.policy to TRUE allows for lists of non-neighbors. This should be used with caution as users may not be aware of missing neighbors in their data however setting zero,policy to FALSE would return an error.\nThe code chunk below is implemented to check the weights of the first polygons eight neighbors type:\n\nrswm_q$weights[10]\n\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n\nUsing the same method, we derive a row standardized distance weight matrix by using the code chunk below.\n\nrswm_ids &lt;- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \n\nWeights style: B \nWeights constants summary:\n   n   nn         S0           S1           S2\nB 79 6241 0.07702966 4.057545e-05 0.0004441685\n\n\nWe now compute the average neighbor Accident count value for each polygon. We often refer to these values as Spatially Lagged Values.\n\nacc.lag &lt;- lag.listw(rswm_q, boundary_with_accident_count$accident_count)\nacc.lag\n\n [1]   3.375000  42.750000 440.750000  10.800000 141.000000 115.333333\n [7]  12.500000  10.600000 222.500000 400.600000 351.714286 123.000000\n[13]  10.800000  39.600000  30.714286  90.400000  58.375000   5.166667\n[19] 162.428571  94.400000 239.600000 144.857143 299.600000 136.333333\n[25]  84.333333  73.500000 206.400000  41.500000  72.142857  57.222222\n[31]  40.800000 350.000000 116.333333 163.333333  76.333333 203.333333\n[37]  27.833333  60.166667  53.833333 258.000000 119.166667 240.250000\n[43] 157.400000 311.428571  34.333333 241.000000 366.800000 190.666667\n[49] 212.000000 234.857143 324.200000 540.500000 444.500000  86.875000\n[55] 261.750000 626.333333 112.571429 223.857143 115.200000 124.600000\n[61] 120.200000 120.000000 290.428571 149.750000 348.000000 523.000000\n[67] 135.800000 165.500000 291.000000 121.500000 125.333333 140.600000\n[73] 133.250000  67.600000 190.285714 206.000000 138.250000 262.400000\n[79] 390.666667\n\n\nWe can retrieve the Accident count for each by using the code Chunk Below.\n\nnb1 &lt;- wm_q[[1]] #Shows the accident counts for the neighboring districts of region 1\nnb1 &lt;- boundary_with_accident_count$accident_count[nb1]\nnb1\n\n[1]  0  0  0  2  0  1  1 23\n\n\n\nA spatial lag with row-standardized weights means that each observation’s value is influenced by the average values of its neighboring observations. Specifically, the weights are standardized so that the sum of the weights for each observation equals one.\nThis approach ensures that the spatial lag is essentially the weighted average of the neighboring values.\n\nWe can append the spatially lagged Accident values onto the boundary_with_accident_count sf data-frame by using the code chunk shown below.\n\nlag.list &lt;- list(boundary_with_accident_count$ADM2_EN.x, lag.listw(rswm_q, boundary_with_accident_count$accident_count))\nlag.res &lt;- as.data.frame(lag.list)\ncolnames(lag.res) &lt;- c(\"ADM2_EN.x\", \"lag Accident Count\")\nboundary_with_accident_count &lt;- left_join(boundary_with_accident_count,lag.res)\n\nWe can gain further insight into this data-frame by implementing the head() function.\n\nhead(boundary_with_accident_count)\n\nSimple feature collection with 6 features and 22 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 660838.3 ymin: 1517063 xmax: 709544.6 ymax: 1542641\nProjected CRS: WGS 84 / UTM zone 47N\n  Shape_Leng   Shape_Area   ADM2_EN.x ADM2_TH ADM2_PCODE ADM2_REF ADM2ALT1EN\n1 0.08541733 0.0004504685 Phra Nakhon  พระนคร     TH1001     &lt;NA&gt;       &lt;NA&gt;\n2 0.13413177 0.0009501914       Dusit     ดุสิต     TH1002     &lt;NA&gt;       &lt;NA&gt;\n3 0.67634217 0.0198588627   Nong Chok หนองจอก     TH1003     &lt;NA&gt;       &lt;NA&gt;\n4 0.08588647 0.0003369561    Bang Rak   บางรัก     TH1004     &lt;NA&gt;       &lt;NA&gt;\n5 0.30172202 0.0034149298   Bang Khen  บางเขน     TH1005     &lt;NA&gt;       &lt;NA&gt;\n6 0.30869124 0.0023032680   Bang Kapi  บางกะปิ     TH1006     &lt;NA&gt;       &lt;NA&gt;\n  ADM2ALT2EN ADM2ALT1TH ADM2ALT2TH ADM1_EN      ADM1_TH ADM1_PCODE  ADM0_EN\n1       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n2       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n3       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n4       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n5       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n6       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt; Bangkok กรุงเทพมหานคร       TH10 Thailand\n    ADM0_TH ADM0_PCODE       date    validOn    validTo ADM2_EN.y\n1 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30      &lt;NA&gt;\n2 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30      &lt;NA&gt;\n3 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30 Nong Chok\n4 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30  Bang Rak\n5 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30 Bang Khen\n6 ประเทศไทย         TH 2019-02-18 2022-01-22 -001-11-30 Bang Kapi\n  accident_count lag Accident Count                       geometry\n1              0             3.3750 MULTIPOLYGON (((662263.2 15...\n2              0            42.7500 MULTIPOLYGON (((664304.4 15...\n3             60           440.7500 MULTIPOLYGON (((706774.6 15...\n4              8            10.8000 MULTIPOLYGON (((664040.2 15...\n5            126           141.0000 MULTIPOLYGON (((673966.4 15...\n6             10           115.3333 MULTIPOLYGON (((676080.6 15...\n\n\nWe now plot the observed Accident and Spatial Lag Accidents side by side for comparison.\n\nacc_qtm &lt;- qtm(boundary_with_accident_count, \"accident_count\")\nlag_acc &lt;- qtm(boundary_with_accident_count, \"lag Accident Count\")\ntmap_arrange(acc_qtm, lag_acc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\nThe use of spatial weights are highly useful for a variety of reasons.\n\nThey allow us to better understand and analyze the dependence between neighboring regions.\nThe help us understand how accidents are not isolated incidents and are often a part of bigger spatial patterns. This allows us to make better decisions with regards to policy developments, resource allocation and more in order to reduce the number of accidents.\nThese help us identify clusters and are crucial in identifying ‘spillover’ effects.\n\n\n\n\n\n1.4.3.5 Spatial Window Average\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights.\nTo add the diagonal element to the neighbour list, we use the include.self() function from the spdep package.\n\nwm_qs &lt;- include.self(wm_q)\nwm_qs\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 517 \nPercentage nonzero weights: 8.283929 \nAverage number of links: 6.544304 \n\n\nThere is a difference in the key statistics shown above when compared to wm_q. The average number of links, the number of non-zero links as well as percentage of non-zero weights are all higher for wm_qs.\nWe look at the neighbor list of area [1] using the code chunk below.\n\nwm_qs[[1]]\n\n[1]  1  2  8 13 15 16 18 20 25\n\n\nThis region has 9 neighbors.\nWe now implement the nb2listw() function in order to obtain weights.\n\nwm_qs &lt;- nb2listw(wm_qs)\nwm_qs\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 517 \nPercentage nonzero weights: 8.283929 \nAverage number of links: 6.544304 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 79 6241 79 24.99173 318.4378\n\n\nWe now create the lag variable from our weight structure and accident_count variable.\n\nlag_w_avg_acc &lt;- lag.listw(wm_qs, \n                             boundary_with_accident_count$accident_count)\nlag_w_avg_acc\n\n [1]   3.000000  38.000000 364.600000  10.333333 139.333333 100.285714\n [7]  16.111111   8.833333 191.571429 345.833333 423.500000 125.500000\n[13]   9.000000  46.666667  27.125000  75.333333  55.000000   4.571429\n[19] 198.000000  78.833333 245.166667 127.000000 249.666667 124.714286\n[25]  75.571429  60.000000 174.833333  36.714286  64.125000  66.500000\n[31]  36.166667 377.714286 106.000000 163.714286  86.000000 184.285714\n[37]  28.714286  60.857143  47.000000 268.333333 106.571429 225.000000\n[43] 205.333333 320.750000  33.250000 233.142857 319.000000 269.285714\n[49] 181.000000 218.000000 312.333333 515.800000 457.571429 132.222222\n[55] 228.000000 581.500000 119.625000 202.125000 115.833333 143.500000\n[61] 110.000000 130.285714 270.125000 252.000000 355.400000 356.666667\n[67] 127.166667 224.571429 233.750000 146.200000 114.500000 134.833333\n[73] 112.800000  73.000000 199.875000 187.750000 277.600000 230.333333\n[79] 320.500000\n\n\nWe then proceed to convert the lag variable listwobject into a data-frame by using as.data.frame().\n\nlag.list.wm_qs &lt;- list(boundary_with_accident_count$ADM2_EN.x, lag.listw(wm_qs, boundary_with_accident_count$accident_count))\nlag_wm_qs.res &lt;- as.data.frame(lag.list.wm_qs)\ncolnames(lag_wm_qs.res) &lt;- c(\"ADM2_EN.x\", \"lag_window_avg acc\")\n\n\nNote: The third command line on the code chunk above renames the field names of lag_wm_q1.res object into accident_count and lag_window_avg acc respectively.\n\nWe now append the lag_window_avg acc values onto the boundary_with_accident_count sf data.frame by using left_join() of dplyr package.\n\nboundary_with_accident_count &lt;- left_join(boundary_with_accident_count, lag_wm_qs.res)\n\nTo compare the values of lag accident count and Spatial window average, The kable() function of the Knitr package is used to prepare a table.\n\nboundary_with_accident_count %&gt;%\n  dplyr::select(\"ADM2_EN.x\", \n         \"lag Accident Count\", \n         \"lag_window_avg acc\") %&gt;%\n  kable()\n\n\n\n\n\n\n\n\n\n\nADM2_EN.x\nlag Accident Count\nlag_window_avg acc\ngeometry\n\n\n\n\nPhra Nakhon\n3.375000\n3.000000\nMULTIPOLYGON (((662263.2 15…\n\n\nDusit\n42.750000\n38.000000\nMULTIPOLYGON (((664304.4 15…\n\n\nNong Chok\n440.750000\n364.600000\nMULTIPOLYGON (((706774.6 15…\n\n\nBang Rak\n10.800000\n10.333333\nMULTIPOLYGON (((664040.2 15…\n\n\nBang Khen\n141.000000\n139.333333\nMULTIPOLYGON (((673966.4 15…\n\n\nBang Kapi\n115.333333\n100.285714\nMULTIPOLYGON (((676080.6 15…\n\n\nPathum Wan\n12.500000\n16.111111\nMULTIPOLYGON (((664236.5 15…\n\n\nPom Prap Sattru Phai\n10.600000\n8.833333\nMULTIPOLYGON (((663880.5 15…\n\n\nPhra Khanong\n222.500000\n191.571429\nMULTIPOLYGON (((674748.8 15…\n\n\nMin Buri\n400.600000\n345.833333\nMULTIPOLYGON (((694735.5 15…\n\n\nLat Krabang\n351.714286\n423.500000\nMULTIPOLYGON (((694497.3 15…\n\n\nYan Nawa\n123.000000\n125.500000\nMULTIPOLYGON (((667818.3 15…\n\n\nSamphanthawong\n10.800000\n9.000000\nMULTIPOLYGON (((663592.4 15…\n\n\nPhaya Thai\n39.600000\n46.666667\nMULTIPOLYGON (((667624 1525…\n\n\nThon Buri\n30.714286\n27.125000\nMULTIPOLYGON (((661364.9 15…\n\n\nBangkok Yai\n90.400000\n75.333333\nMULTIPOLYGON (((660991.6 15…\n\n\nHuai Khwang\n58.375000\n55.000000\nMULTIPOLYGON (((671695.6 15…\n\n\nKhlong San\n5.166667\n4.571429\nMULTIPOLYGON (((662113.2 15…\n\n\nTaling Chan\n162.428571\n198.000000\nMULTIPOLYGON (((654587 1526…\n\n\nBangkok Noi\n94.400000\n78.833333\nMULTIPOLYGON (((659654.1 15…\n\n\nBang Khun Thian\n239.600000\n245.166667\nMULTIPOLYGON (((656541 1512…\n\n\nPhasi Charoen\n144.857143\n127.000000\nMULTIPOLYGON (((654370 1519…\n\n\nNong Khaem\n299.600000\n249.666667\nMULTIPOLYGON (((647001.3 15…\n\n\nRat Burana\n136.333333\n124.714286\nMULTIPOLYGON (((661132.1 15…\n\n\nBang Phlat\n84.333333\n75.571429\nMULTIPOLYGON (((663052.9 15…\n\n\nDin Daeng\n73.500000\n60.000000\nMULTIPOLYGON (((670238.2 15…\n\n\nBueng Kum\n206.400000\n174.833333\nMULTIPOLYGON (((678184.5 15…\n\n\nSathon\n41.500000\n36.714286\nMULTIPOLYGON (((667917.7 15…\n\n\nBang Sue\n72.142857\n64.125000\nMULTIPOLYGON (((666275.4 15…\n\n\nChatuchak\n57.222222\n66.500000\nMULTIPOLYGON (((671471.4 15…\n\n\nBang Kho Laem\n40.800000\n36.166667\nMULTIPOLYGON (((664335.2 15…\n\n\nPrawet\n350.000000\n377.714286\nMULTIPOLYGON (((680695.6 15…\n\n\nKhlong Toei\n116.333333\n106.000000\nMULTIPOLYGON (((673075.4 15…\n\n\nSuan Luang\n163.333333\n163.714286\nMULTIPOLYGON (((677751.8 15…\n\n\nChom Thong\n76.333333\n86.000000\nMULTIPOLYGON (((658696.5 15…\n\n\nDon Mueang\n203.333333\n184.285714\nMULTIPOLYGON (((674339.8 15…\n\n\nRatchathewi\n27.833333\n28.714286\nMULTIPOLYGON (((667199.4 15…\n\n\nLat Phrao\n60.166667\n60.857143\nMULTIPOLYGON (((673842.9 15…\n\n\nVadhana\n53.833333\n47.000000\nMULTIPOLYGON (((668704.8 15…\n\n\nBang Khae\n258.000000\n268.333333\nMULTIPOLYGON (((647693 1520…\n\n\nLak Si\n119.166667\n106.571429\nMULTIPOLYGON (((671045.4 15…\n\n\nSai Mai\n240.250000\n225.000000\nMULTIPOLYGON (((679686.2 15…\n\n\nKhan Na Yao\n157.400000\n205.333333\nMULTIPOLYGON (((680806.2 15…\n\n\nSaphan Sung\n311.428571\n320.750000\nMULTIPOLYGON (((685556.9 15…\n\n\nWang Thonglang\n34.333333\n33.250000\nMULTIPOLYGON (((671782.5 15…\n\n\nKhlong Sam Wa\n241.000000\n233.142857\nMULTIPOLYGON (((693668.9 15…\n\n\nBang Na\n366.800000\n319.000000\nMULTIPOLYGON (((675501.8 15…\n\n\nThawi Watthana\n190.666667\n269.285714\nMULTIPOLYGON (((650687.8 15…\n\n\nThung Khru\n212.000000\n181.000000\nMULTIPOLYGON (((660699.8 15…\n\n\nBang Bon\n234.857143\n218.000000\nMULTIPOLYGON (((656343.6 15…\n\n\nMueang Samut Prakan\n324.200000\n312.333333\nMULTIPOLYGON (((673201.8 15…\n\n\nBang Bo\n540.500000\n515.800000\nMULTIPOLYGON (((712294.1 15…\n\n\nBang Phli\n444.500000\n457.571429\nMULTIPOLYGON (((687139.8 15…\n\n\nPhra Pradaeng\n86.875000\n132.222222\nMULTIPOLYGON (((670827.4 15…\n\n\nPhra Samut Chedi\n261.750000\n228.000000\nMULTIPOLYGON (((669191.5 15…\n\n\nBang Sao Thong\n626.333333\n581.500000\nMULTIPOLYGON (((695481.3 15…\n\n\nMueang Nonthaburi\n112.571429\n119.625000\nMULTIPOLYGON (((662112.2 15…\n\n\nBang Kruai\n223.857143\n202.125000\nMULTIPOLYGON (((654095.9 15…\n\n\nBang Yai\n115.200000\n115.833333\nMULTIPOLYGON (((649983.7 15…\n\n\nBang Bua Thong\n124.600000\n143.500000\nMULTIPOLYGON (((649993.4 15…\n\n\nSai Noi\n120.200000\n110.000000\nMULTIPOLYGON (((644817.9 15…\n\n\nPak Kret\n120.000000\n130.285714\nMULTIPOLYGON (((652378.8 15…\n\n\nMueang Pathum Thani\n290.428571\n270.125000\nMULTIPOLYGON (((672162.5 15…\n\n\nKhlong Luang\n149.750000\n252.000000\nMULTIPOLYGON (((689473.3 15…\n\n\nThanyaburi\n348.000000\n355.400000\nMULTIPOLYGON (((706757.7 15…\n\n\nNong Suea\n523.000000\n356.666667\nMULTIPOLYGON (((704086 1575…\n\n\nLat Lum Kaeo\n135.800000\n127.166667\nMULTIPOLYGON (((650538.8 15…\n\n\nLam Luk Ka\n165.500000\n224.571429\nMULTIPOLYGON (((706764.9 15…\n\n\nSam Khok\n291.000000\n233.750000\nMULTIPOLYGON (((665864.3 15…\n\n\nMueang Nakhon Pathom\n121.500000\n146.200000\nMULTIPOLYGON (((602747 1541…\n\n\nKamphaeng Saen\n125.333333\n114.500000\nMULTIPOLYGON (((612428.1 15…\n\n\nNakhon Chai Si\n140.600000\n134.833333\nMULTIPOLYGON (((627397.1 15…\n\n\nDon Tum\n133.250000\n112.800000\nMULTIPOLYGON (((620292.6 15…\n\n\nBang Len\n67.600000\n73.000000\nMULTIPOLYGON (((631987.6 15…\n\n\nSam Phran\n190.285714\n199.875000\nMULTIPOLYGON (((636176.3 15…\n\n\nPhutthamonthon\n206.000000\n187.750000\nMULTIPOLYGON (((637713.4 15…\n\n\nMueang Samut Sakhon\n138.250000\n277.600000\nMULTIPOLYGON (((646615.4 15…\n\n\nKrathum Baen\n262.400000\n230.333333\nMULTIPOLYGON (((641549.1 15…\n\n\nBan Phaeo\n390.666667\n320.500000\nMULTIPOLYGON (((625054.6 15…\n\n\n\n\n\nWe now plot the lag accident count and w_ave_acc maps next to each other for comparison using the qtm() function of the tmap package.\n\nw_avg_acc &lt;- qtm(boundary_with_accident_count, \"lag_window_avg acc\")\ntmap_arrange(lag_acc, w_avg_acc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\nequal &lt;- tm_shape(boundary_with_accident_count) +\n  tm_fill(\"accident_count\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile &lt;- tm_shape(boundary_with_accident_count) +\n  tm_fill(\"accident_count\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#computing-contiguity-spatial-weights",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#computing-contiguity-spatial-weights",
    "title": "Take Home Exercise 1",
    "section": "Computing Contiguity Spatial Weights",
    "text": "Computing Contiguity Spatial Weights\nWe now implement the poly2nb() function of the spdep package to compute contiguity weight matrices for the study area selected.\nUsing this function, we are able to build a ‘neighbors list’ based on regions with contiguous boundaries.\nIn this function, we will pass an argument, ‘queen’, that can be set as either TRUE (default) or FALSE. If the ‘queen’ argument is not explicitly set to FALSE, the function returns a list of first order neighbors using the Queen criteria.\nYou may refer to the spdep package documentation here to learn more about its functions and arguments.\n\nComputing (QUEEN) contiguity based neighbors\nThe poly2nb() function is implemented as shown in the code chunk below. Using this, we are able to compute a Queen contiguity weight matrix.\n\nwm_q &lt;- poly2nb(boundary_with_accident_count, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 1  5 10 24 20 12  6  1 \n1 least connected region:\n66 with 2 links\n1 most connected region:\n30 with 9 links\n\n\n\n\nComputing (ROOK) contiguity based neighbors\nFor this, we will set the queen argument of the poly2nb() function to false.\n\nwm_r &lt;- poly2nb(boundary_with_accident_count, queen=FALSE) \nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 422 \nPercentage nonzero weights: 6.761737 \nAverage number of links: 5.341772 \nLink number distribution:\n\n 2  3  4  5  6  7  8 \n 1  5 16 20 22 11  4 \n1 least connected region:\n66 with 2 links\n4 most connected regions:\n1 5 17 54 with 8 links\n\n\nThe most connected area has 9 neighbors. In general, most districts have approximately 5 to 6 neighbors.\n\n\nVisualizing contiguity weights\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons in this situation, so we need to ensure that our points are in order to produce our connectivity graphs.\nUsually, the method of choice will be polygon centroids. We calculate using the sf package before moving onto the graphs. Getting latitude and longitude of the Polygon Centroids.\nWe need points to associate with each polygon before we can make our connectivity graph. It won’t be as simple as applying the st_centroid() function of the sf sf object: us.bound. We need the coordinates in a separate data-frame for this to work.\nTo do this, we will use a mapping function which will apply a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of us.bound.\nThe function that we implement in this situation will be st_centroid().\nWe will be using the map_dbl variation of map from the purrr package.\n\nObtaining Coordinate values\n\nLongitudeLatitudeCoords\n\n\n\nlongitude &lt;- map_dbl(boundary_with_accident_count$geometry, ~st_centroid(.x)[[1]])\n\n\n\n\nlatitude &lt;- map_dbl(boundary_with_accident_count$geometry, ~st_centroid(.x)[[2]])\n\n\n\nNow that we have the latitude and longitude values, we can use the cbind() function to put the longitude and latitude values into the same object, coords.\n\ncoords &lt;- cbind(longitude, latitude)\n\n\nhead(coords)\n\n     longitude latitude\n[1,]  661951.4  1521172\n[2,]  664121.1  1523923\n[3,]  700735.2  1532207\n[4,]  664808.5  1518057\n[5,]  676193.5  1533602\n[6,]  677305.1  1522820\n\n\n\n\n\nWe can now plot the contiguity weights side by side for comparison.\n\npar(mfrow=c(1,2))\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\", main=\"Queen Contiguity\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"purple\")\nplot(boundary_with_accident_count$geometry, border=\"lightgrey\", main=\"Rook Contiguity\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"purple\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#weights-based-on-inversed-distance-weighting-idw",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#weights-based-on-inversed-distance-weighting-idw",
    "title": "Take Home Exercise 1",
    "section": "Weights Based on Inversed Distance Weighting (IDW)",
    "text": "Weights Based on Inversed Distance Weighting (IDW)\nWe first compute the distances between areas by implementing the nbdists() function of the spdep package.\n\ndist &lt;- nbdists(wm_q, coords, longlat = FALSE)\nids &lt;- lapply(dist, function(x) 1/(x))\nids\n\n[[1]]\n[1] 0.0002854535 0.0006582134 0.0004566217 0.0002167536 0.0003080119\n[6] 0.0002757322 0.0003371576 0.0002806965\n\n[[2]]\n[1] 0.0002854535 0.0002055287 0.0003012437 0.0003439200 0.0003703229\n[6] 0.0002193608 0.0001383976 0.0002982074\n\n[[3]]\n[1] 8.230456e-05 7.194802e-05 7.691011e-05 6.386761e-05\n\n[[4]]\n[1] 0.0005397094 0.0003348823 0.0004742967 0.0004145926 0.0006228750\n\n[[5]]\n[1] 1.466707e-04 1.197978e-04 1.317261e-04 1.901079e-04 1.449448e-04\n[6] 2.005737e-04 1.397857e-04 8.481219e-05\n\n[[6]]\n[1] 0.0001622765 0.0002212846 0.0002009303 0.0001431074 0.0001781389\n[6] 0.0002901167\n\n[[7]]\n[1] 0.0002055287 0.0005397094 0.0003428497 0.0003432013 0.0003504051\n[6] 0.0002113326 0.0005031250 0.0001878859\n\n[[8]]\n[1] 0.0006582134 0.0003012437 0.0003348823 0.0003428497 0.0007193454\n\n[[9]]\n[1] 0.0001452881 0.0001919620 0.0002478517 0.0001846853 0.0003608347\n[6] 0.0001275280\n\n[[10]]\n[1] 8.230456e-05 1.204212e-04 1.185473e-04 1.177461e-04 1.338999e-04\n\n[[11]]\n[1] 7.194802e-05 1.204212e-04 7.412539e-05 8.957108e-05 5.200876e-05\n[6] 6.530843e-05 8.333031e-05\n\n[[12]]\n[1] 0.0002120327 0.0003601503 0.0003033661 0.0002204848 0.0002299417\n\n[[13]]\n[1] 0.0004566217 0.0004742967 0.0003432013 0.0007193454 0.0005352046\n\n[[14]]\n[1] 0.0003439200 0.0004723701 0.0002181006 0.0001852359 0.0003556913\n\n[[15]]\n[1] 0.0002167536 0.0004178016 0.0005004725 0.0002059056 0.0002024628\n[6] 0.0002988328 0.0002534194\n\n[[16]]\n[1] 0.0003080119 0.0004178016 0.0001666057 0.0003222415 0.0002506523\n\n[[17]]\n[1] 0.0001622765 0.0004355978 0.0001468778 0.0001493430 0.0002022661\n[6] 0.0001455745 0.0002525101 0.0003209334\n\n[[18]]\n[1] 0.0002757322 0.0004145926 0.0005352046 0.0005004725 0.0003077165\n[6] 0.0003335152\n\n[[19]]\n[1] 0.0001666057 0.0002462888 0.0001860044 0.0001509068 0.0001330087\n[6] 0.0001378191 0.0002092546\n\n[[20]]\n[1] 0.0003371576 0.0003222415 0.0002462888 0.0001834292 0.0002732088\n\n[[21]]\n[1] 8.969997e-05 1.203769e-04 1.245294e-04 9.569804e-05 4.958860e-05\n\n[[22]]\n[1] 0.0002059056 0.0002506523 0.0001860044 0.0001834292 0.0002152303\n[6] 0.0001971194 0.0001095917\n\n[[23]]\n[1] 2.053579e-04 1.119769e-04 1.692192e-04 6.579843e-05 1.036058e-04\n\n[[24]]\n[1] 0.0002120327 0.0002024628 0.0003529966 0.0002347366 0.0001982741\n[6] 0.0001621175\n\n[[25]]\n[1] 0.0002806965 0.0003703229 0.0001509068 0.0002732088 0.0001935337\n[6] 0.0001208318\n\n[[26]]\n[1] 0.0004723701 0.0004355978 0.0001754699 0.0003013611\n\n[[27]]\n[1] 0.0001466707 0.0002212846 0.0002022599 0.0003179325 0.0001494025\n\n[[28]]\n[1] 0.0006228750 0.0003504051 0.0003601503 0.0003077165 0.0003330968\n[6] 0.0002241661\n\n[[29]]\n[1] 2.193608e-04 2.181006e-04 1.935337e-04 2.480081e-04 1.269610e-04\n[6] 1.731795e-04 8.705329e-05\n\n[[30]]\n[1] 0.0001383976 0.0001197978 0.0001852359 0.0001468778 0.0001754699\n[6] 0.0002480081 0.0002134931 0.0001692547 0.0001150417\n\n[[31]]\n[1] 0.0003033661 0.0002988328 0.0003335152 0.0003529966 0.0003330968\n\n[[32]]\n[1] 1.452881e-04 7.412539e-05 1.648225e-04 1.385556e-04 1.384360e-04\n[6] 9.877756e-05\n\n[[33]]\n[1] 0.0002113326 0.0001919620 0.0002204848 0.0002241661 0.0004631083\n[6] 0.0001381990\n\n[[34]]\n[1] 0.0002009303 0.0002478517 0.0001493430 0.0001648225 0.0002087434\n[6] 0.0001252900\n\n[[35]]\n[1] 2.534194e-04 8.969997e-05 2.152303e-04 2.347366e-04 1.338459e-04\n[6] 1.190158e-04\n\n[[36]]\n[1] 1.317261e-04 1.741388e-04 1.477787e-04 9.360890e-05 1.023839e-04\n[6] 4.522313e-05\n\n[[37]]\n[1] 0.0002982074 0.0005031250 0.0003556913 0.0002022661 0.0003013611\n[6] 0.0001760696\n\n[[38]]\n[1] 0.0001901079 0.0001431074 0.0001455745 0.0002022599 0.0002134931\n[6] 0.0001969405\n\n[[39]]\n[1] 0.0001878859 0.0001846853 0.0002525101 0.0004631083 0.0002087434\n[6] 0.0001760696\n\n[[40]]\n[1] 0.0001330087 0.0001971194 0.0002053579 0.0001396487 0.0001509543\n\n[[41]]\n[1] 0.0001449448 0.0001269610 0.0001692547 0.0001741388 0.0001155726\n[6] 0.0001062678\n\n[[42]]\n[1] 2.005737e-04 1.477787e-04 1.006357e-04 5.914874e-05\n\n[[43]]\n[1] 0.0001397857 0.0001185473 0.0003179325 0.0001503042 0.0001120205\n\n[[44]]\n[1] 1.781389e-04 1.177461e-04 8.957108e-05 1.494025e-04 1.385556e-04\n[6] 1.252900e-04 1.503042e-04\n\n[[45]]\n[1] 0.0002901167 0.0003209334 0.0001969405\n\n[[46]]\n[1] 7.691011e-05 8.481219e-05 1.338999e-04 1.006357e-04 1.120205e-04\n[6] 7.834800e-05\n\n[[47]]\n[1] 3.608347e-04 1.384360e-04 8.847607e-05 7.825942e-05 1.380165e-04\n\n[[48]]\n[1] 1.378191e-04 1.119769e-04 1.396487e-04 1.390484e-04 5.812114e-05\n[6] 9.420908e-05\n\n[[49]]\n[1] 0.0001203769 0.0001982741 0.0001338459 0.0001460302 0.0001218403\n\n[[50]]\n[1] 1.245294e-04 1.095917e-04 1.692192e-04 1.190158e-04 1.509543e-04\n[6] 4.881437e-05 7.827893e-05\n\n[[51]]\n[1] 8.847607e-05 4.260505e-05 9.775096e-05 7.211651e-05 6.976002e-05\n\n[[52]]\n[1] 5.200876e-05 4.260505e-05 6.461671e-05 1.208164e-04\n\n[[53]]\n[1] 6.530843e-05 9.877756e-05 7.825942e-05 9.775096e-05 6.461671e-05\n[6] 1.098016e-04\n\n[[54]]\n[1] 1.275280e-04 2.299417e-04 1.621175e-04 1.381990e-04 1.380165e-04\n[6] 1.460302e-04 7.211651e-05 8.749710e-05\n\n[[55]]\n[1] 9.569804e-05 1.218403e-04 6.976002e-05 8.749710e-05\n\n[[56]]\n[1] 8.333031e-05 1.208164e-04 1.098016e-04\n\n[[57]]\n[1] 0.0001731795 0.0001150417 0.0001155726 0.0001121332 0.0000764271\n[6] 0.0000755279 0.0001320269\n\n[[58]]\n[1] 2.092546e-04 1.208318e-04 8.705329e-05 1.390484e-04 1.121332e-04\n[6] 1.356813e-04 6.810787e-05\n\n[[59]]\n[1] 7.642710e-05 1.356813e-04 1.153320e-04 5.588948e-05 1.070876e-04\n\n[[60]]\n[1] 7.552790e-05 1.153320e-04 8.048614e-05 9.201600e-05 7.698649e-05\n\n[[61]]\n[1] 5.588948e-05 8.048614e-05 8.676092e-05 7.105006e-05 5.108714e-05\n\n[[62]]\n[1] 9.360890e-05 1.062678e-04 1.320269e-04 9.201600e-05 1.156307e-04\n[6] 6.087272e-05\n\n[[63]]\n[1] 1.023839e-04 1.156307e-04 5.287764e-05 4.047452e-05 6.619029e-05\n[6] 3.620195e-05 9.994772e-05\n\n[[64]]\n[1] 5.287764e-05 8.616137e-05 5.274538e-05 6.005288e-05\n\n[[65]]\n[1] 4.047452e-05 8.616137e-05 5.965942e-05 1.524056e-04\n\n[[66]]\n[1] 5.274538e-05 5.965942e-05\n\n[[67]]\n[1] 7.698649e-05 8.676092e-05 6.087272e-05 6.619029e-05 7.655740e-05\n\n[[68]]\n[1] 6.386761e-05 4.522313e-05 5.914874e-05 7.834800e-05 3.620195e-05\n[6] 1.524056e-04\n\n[[69]]\n[1] 9.994772e-05 6.005288e-05 7.655740e-05\n\n[[70]]\n[1] 4.117989e-05 5.885227e-05 6.155251e-05 4.225974e-05\n\n[[71]]\n[1] 4.117989e-05 5.953357e-05 4.110606e-05\n\n[[72]]\n[1] 5.885227e-05 5.899804e-05 4.000195e-05 8.692110e-05 8.457300e-05\n\n[[73]]\n[1] 6.155251e-05 5.953357e-05 5.899804e-05 6.741263e-05\n\n[[74]]\n[1] 7.105006e-05 4.110606e-05 4.000195e-05 6.741263e-05 3.789103e-05\n\n[[75]]\n[1] 6.579843e-05 5.812114e-05 4.225974e-05 8.692110e-05 7.172077e-05\n[6] 1.056880e-04 5.465069e-05\n\n[[76]]\n[1] 9.420908e-05 6.810787e-05 1.070876e-04 5.108714e-05 8.457300e-05\n[6] 3.789103e-05 7.172077e-05\n\n[[77]]\n[1] 4.958860e-05 4.881437e-05 7.004105e-05 6.324110e-05\n\n[[78]]\n[1] 1.036058e-04 7.827893e-05 1.056880e-04 7.004105e-05 5.420721e-05\n\n[[79]]\n[1] 5.465069e-05 6.324110e-05 5.420721e-05\n\n\nWe now need to assign weights to each neighboring polygon. We use equal weights (style=“W”), where each neighboring polygon is assigned a weight of 1 divided by the number of neighbors.\nThis means each neighboring county’s weight is calculated as 1/(# of neighbors), and these weights are then used to sum the weighted income values.\nWhile this method is intuitive for summarizing neighbors’ values, it has a drawback: polygons at the edges of the study area may rely on fewer neighbors, potentially skewing the spatial autocorrelation results.\n\n\nNote on style argument\n\n\nNote: For simplicity, we’ll use the style=“W” option in this example, but be aware that more robust options, such as style=“B”, are available.\n\n\n\nrswm_q &lt;- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0      S1       S2\nW 79 6241 79 29.8143 321.0615\n\n\nSetting the argument zero.policy to TRUE allows for lists of non-neighbors. This should be used with caution as users may not be aware of missing neighbors in their data however setting zero,policy to FALSE would return an error.\nThe code chunk below is implemented to check the weights of the first polygons eight neighbors type:\n\nrswm_q$weights[10]\n\n[[1]]\n[1] 0.2 0.2 0.2 0.2 0.2\n\n\nUsing the same method, we derive a row standardized distance weight matrix by using the code chunk below.\n\nrswm_ids &lt;- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 438 \nPercentage nonzero weights: 7.018106 \nAverage number of links: 5.544304 \n\nWeights style: B \nWeights constants summary:\n   n   nn         S0           S1           S2\nB 79 6241 0.07702966 4.057545e-05 0.0004441685\n\n\n\nacc.lag &lt;- lag.listw(rswm_q, boundary_with_accident_count$accident_count)\nacc.lag\n\n [1]   3.375000  42.750000 440.750000  10.800000 141.000000 115.333333\n [7]  12.500000  10.600000 222.500000 400.600000 351.714286 123.000000\n[13]  10.800000  39.600000  30.714286  90.400000  58.375000   5.166667\n[19] 162.428571  94.400000 239.600000 144.857143 299.600000 136.333333\n[25]  84.333333  73.500000 206.400000  41.500000  72.142857  57.222222\n[31]  40.800000 350.000000 116.333333 163.333333  76.333333 203.333333\n[37]  27.833333  60.166667  53.833333 258.000000 119.166667 240.250000\n[43] 157.400000 311.428571  34.333333 241.000000 366.800000 190.666667\n[49] 212.000000 234.857143 324.200000 540.500000 444.500000  86.875000\n[55] 261.750000 626.333333 112.571429 223.857143 115.200000 124.600000\n[61] 120.200000 120.000000 290.428571 149.750000 348.000000 523.000000\n[67] 135.800000 165.500000 291.000000 121.500000 125.333333 140.600000\n[73] 133.250000  67.600000 190.285714 206.000000 138.250000 262.400000\n[79] 390.666667\n\n\n\nnb1 &lt;- wm_q[[1]]\nnb1 &lt;- boundary_with_accident_count$accident_count[nb1]\nnb1\n\n[1]  0  0  0  2  0  1  1 23\n\n\n\nlag.list &lt;- list(boundary_with_accident_count$ADM2_EN.x, lag.listw(rswm_q, boundary_with_accident_count$accident_count))\nlag.res &lt;- as.data.frame(lag.list)\ncolnames(lag.res) &lt;- c(\"ADM2_EN.x\", \"lag Accident Count\")\nboundary_with_accident_count &lt;- left_join(boundary_with_accident_count,lag.res)\n\n\nacc_qtm &lt;- qtm(boundary_with_accident_count, \"accident_count\")\nlag_acc &lt;- qtm(boundary_with_accident_count, \"lag Accident Count\")\ntmap_arrange(acc_qtm, lag_acc, asp=1, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-window-average",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-window-average",
    "title": "Take Home Exercise 1",
    "section": "Spatial Window Average",
    "text": "Spatial Window Average\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights.\nTo add the diagonal element to the neighbour list, we use the include.self() function from the spdep package.\n\nwm_qs &lt;- include.self(wm_q)\nwm_qs\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 517 \nPercentage nonzero weights: 8.283929 \nAverage number of links: 6.544304 \n\n\nThere is a difference in the key statistics shown above when compared to wm_q. The average number of links, the number of non-zero links as well as percentage of non-zero weights are all higher for wm_qs.\nWe look at the neighbor list of area [1] using the code chunk below.\n\nwm_qs[[1]]\n\n[1]  1  2  8 13 15 16 18 20 25\n\n\nThis region has 9 neighbors.\nWe now implement the nb2listw() function in order to obtain weights.\n\nwm_qs &lt;- nb2listw(wm_qs)\nwm_qs\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 517 \nPercentage nonzero weights: 8.283929 \nAverage number of links: 6.544304 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 79 6241 79 24.99173 318.4378\n\n\nWe now create the lag variable from our weight structure and accident_count variable.\n\nlag_w_avg_acc &lt;- lag.listw(wm_qs, \n                             boundary_with_accident_count$accident_count)\nlag_w_avg_acc\n\n [1]   3.000000  38.000000 364.600000  10.333333 139.333333 100.285714\n [7]  16.111111   8.833333 191.571429 345.833333 423.500000 125.500000\n[13]   9.000000  46.666667  27.125000  75.333333  55.000000   4.571429\n[19] 198.000000  78.833333 245.166667 127.000000 249.666667 124.714286\n[25]  75.571429  60.000000 174.833333  36.714286  64.125000  66.500000\n[31]  36.166667 377.714286 106.000000 163.714286  86.000000 184.285714\n[37]  28.714286  60.857143  47.000000 268.333333 106.571429 225.000000\n[43] 205.333333 320.750000  33.250000 233.142857 319.000000 269.285714\n[49] 181.000000 218.000000 312.333333 515.800000 457.571429 132.222222\n[55] 228.000000 581.500000 119.625000 202.125000 115.833333 143.500000\n[61] 110.000000 130.285714 270.125000 252.000000 355.400000 356.666667\n[67] 127.166667 224.571429 233.750000 146.200000 114.500000 134.833333\n[73] 112.800000  73.000000 199.875000 187.750000 277.600000 230.333333\n[79] 320.500000\n\n\nWe then proceed to convert the lag variable listwobject into a data-frame by using as.data.frame().\n\nlag.list.wm_qs &lt;- list(boundary_with_accident_count$ADM2_EN.x, lag.listw(wm_qs, boundary_with_accident_count$accident_count))\nlag_wm_qs.res &lt;- as.data.frame(lag.list.wm_qs)\ncolnames(lag_wm_qs.res) &lt;- c(\"ADM2_EN.x\", \"lag_window_avg acc\")\n\n\nNote: The third command line on the code chunk above renames the field names of lag_wm_q1.res object into accident_count and lag_window_avg acc respectively.\n\nWe now append the lag_window_avg acc values onto the boundary_with_accident_count sf data.frame by using left_join() of dplyr package.\n\nboundary_with_accident_count &lt;- left_join(boundary_with_accident_count, lag_wm_qs.res)\n\nTo compare the values of lag accident count and Spatial window average, The kable() function of the Knitr package is used to prepare a table.\n\nboundary_with_accident_count %&gt;%\n  dplyr::select(\"ADM2_EN.x\", \n         \"lag Accident Count\", \n         \"lag_window_avg acc\") %&gt;%\n  kable()\n\n\n\n\n\n\n\n\n\n\nADM2_EN.x\nlag Accident Count\nlag_window_avg acc\ngeometry\n\n\n\n\nPhra Nakhon\n3.375000\n3.000000\nMULTIPOLYGON (((662263.2 15…\n\n\nDusit\n42.750000\n38.000000\nMULTIPOLYGON (((664304.4 15…\n\n\nNong Chok\n440.750000\n364.600000\nMULTIPOLYGON (((706774.6 15…\n\n\nBang Rak\n10.800000\n10.333333\nMULTIPOLYGON (((664040.2 15…\n\n\nBang Khen\n141.000000\n139.333333\nMULTIPOLYGON (((673966.4 15…\n\n\nBang Kapi\n115.333333\n100.285714\nMULTIPOLYGON (((676080.6 15…\n\n\nPathum Wan\n12.500000\n16.111111\nMULTIPOLYGON (((664236.5 15…\n\n\nPom Prap Sattru Phai\n10.600000\n8.833333\nMULTIPOLYGON (((663880.5 15…\n\n\nPhra Khanong\n222.500000\n191.571429\nMULTIPOLYGON (((674748.8 15…\n\n\nMin Buri\n400.600000\n345.833333\nMULTIPOLYGON (((694735.5 15…\n\n\nLat Krabang\n351.714286\n423.500000\nMULTIPOLYGON (((694497.3 15…\n\n\nYan Nawa\n123.000000\n125.500000\nMULTIPOLYGON (((667818.3 15…\n\n\nSamphanthawong\n10.800000\n9.000000\nMULTIPOLYGON (((663592.4 15…\n\n\nPhaya Thai\n39.600000\n46.666667\nMULTIPOLYGON (((667624 1525…\n\n\nThon Buri\n30.714286\n27.125000\nMULTIPOLYGON (((661364.9 15…\n\n\nBangkok Yai\n90.400000\n75.333333\nMULTIPOLYGON (((660991.6 15…\n\n\nHuai Khwang\n58.375000\n55.000000\nMULTIPOLYGON (((671695.6 15…\n\n\nKhlong San\n5.166667\n4.571429\nMULTIPOLYGON (((662113.2 15…\n\n\nTaling Chan\n162.428571\n198.000000\nMULTIPOLYGON (((654587 1526…\n\n\nBangkok Noi\n94.400000\n78.833333\nMULTIPOLYGON (((659654.1 15…\n\n\nBang Khun Thian\n239.600000\n245.166667\nMULTIPOLYGON (((656541 1512…\n\n\nPhasi Charoen\n144.857143\n127.000000\nMULTIPOLYGON (((654370 1519…\n\n\nNong Khaem\n299.600000\n249.666667\nMULTIPOLYGON (((647001.3 15…\n\n\nRat Burana\n136.333333\n124.714286\nMULTIPOLYGON (((661132.1 15…\n\n\nBang Phlat\n84.333333\n75.571429\nMULTIPOLYGON (((663052.9 15…\n\n\nDin Daeng\n73.500000\n60.000000\nMULTIPOLYGON (((670238.2 15…\n\n\nBueng Kum\n206.400000\n174.833333\nMULTIPOLYGON (((678184.5 15…\n\n\nSathon\n41.500000\n36.714286\nMULTIPOLYGON (((667917.7 15…\n\n\nBang Sue\n72.142857\n64.125000\nMULTIPOLYGON (((666275.4 15…\n\n\nChatuchak\n57.222222\n66.500000\nMULTIPOLYGON (((671471.4 15…\n\n\nBang Kho Laem\n40.800000\n36.166667\nMULTIPOLYGON (((664335.2 15…\n\n\nPrawet\n350.000000\n377.714286\nMULTIPOLYGON (((680695.6 15…\n\n\nKhlong Toei\n116.333333\n106.000000\nMULTIPOLYGON (((673075.4 15…\n\n\nSuan Luang\n163.333333\n163.714286\nMULTIPOLYGON (((677751.8 15…\n\n\nChom Thong\n76.333333\n86.000000\nMULTIPOLYGON (((658696.5 15…\n\n\nDon Mueang\n203.333333\n184.285714\nMULTIPOLYGON (((674339.8 15…\n\n\nRatchathewi\n27.833333\n28.714286\nMULTIPOLYGON (((667199.4 15…\n\n\nLat Phrao\n60.166667\n60.857143\nMULTIPOLYGON (((673842.9 15…\n\n\nVadhana\n53.833333\n47.000000\nMULTIPOLYGON (((668704.8 15…\n\n\nBang Khae\n258.000000\n268.333333\nMULTIPOLYGON (((647693 1520…\n\n\nLak Si\n119.166667\n106.571429\nMULTIPOLYGON (((671045.4 15…\n\n\nSai Mai\n240.250000\n225.000000\nMULTIPOLYGON (((679686.2 15…\n\n\nKhan Na Yao\n157.400000\n205.333333\nMULTIPOLYGON (((680806.2 15…\n\n\nSaphan Sung\n311.428571\n320.750000\nMULTIPOLYGON (((685556.9 15…\n\n\nWang Thonglang\n34.333333\n33.250000\nMULTIPOLYGON (((671782.5 15…\n\n\nKhlong Sam Wa\n241.000000\n233.142857\nMULTIPOLYGON (((693668.9 15…\n\n\nBang Na\n366.800000\n319.000000\nMULTIPOLYGON (((675501.8 15…\n\n\nThawi Watthana\n190.666667\n269.285714\nMULTIPOLYGON (((650687.8 15…\n\n\nThung Khru\n212.000000\n181.000000\nMULTIPOLYGON (((660699.8 15…\n\n\nBang Bon\n234.857143\n218.000000\nMULTIPOLYGON (((656343.6 15…\n\n\nMueang Samut Prakan\n324.200000\n312.333333\nMULTIPOLYGON (((673201.8 15…\n\n\nBang Bo\n540.500000\n515.800000\nMULTIPOLYGON (((712294.1 15…\n\n\nBang Phli\n444.500000\n457.571429\nMULTIPOLYGON (((687139.8 15…\n\n\nPhra Pradaeng\n86.875000\n132.222222\nMULTIPOLYGON (((670827.4 15…\n\n\nPhra Samut Chedi\n261.750000\n228.000000\nMULTIPOLYGON (((669191.5 15…\n\n\nBang Sao Thong\n626.333333\n581.500000\nMULTIPOLYGON (((695481.3 15…\n\n\nMueang Nonthaburi\n112.571429\n119.625000\nMULTIPOLYGON (((662112.2 15…\n\n\nBang Kruai\n223.857143\n202.125000\nMULTIPOLYGON (((654095.9 15…\n\n\nBang Yai\n115.200000\n115.833333\nMULTIPOLYGON (((649983.7 15…\n\n\nBang Bua Thong\n124.600000\n143.500000\nMULTIPOLYGON (((649993.4 15…\n\n\nSai Noi\n120.200000\n110.000000\nMULTIPOLYGON (((644817.9 15…\n\n\nPak Kret\n120.000000\n130.285714\nMULTIPOLYGON (((652378.8 15…\n\n\nMueang Pathum Thani\n290.428571\n270.125000\nMULTIPOLYGON (((672162.5 15…\n\n\nKhlong Luang\n149.750000\n252.000000\nMULTIPOLYGON (((689473.3 15…\n\n\nThanyaburi\n348.000000\n355.400000\nMULTIPOLYGON (((706757.7 15…\n\n\nNong Suea\n523.000000\n356.666667\nMULTIPOLYGON (((704086 1575…\n\n\nLat Lum Kaeo\n135.800000\n127.166667\nMULTIPOLYGON (((650538.8 15…\n\n\nLam Luk Ka\n165.500000\n224.571429\nMULTIPOLYGON (((706764.9 15…\n\n\nSam Khok\n291.000000\n233.750000\nMULTIPOLYGON (((665864.3 15…\n\n\nMueang Nakhon Pathom\n121.500000\n146.200000\nMULTIPOLYGON (((602747 1541…\n\n\nKamphaeng Saen\n125.333333\n114.500000\nMULTIPOLYGON (((612428.1 15…\n\n\nNakhon Chai Si\n140.600000\n134.833333\nMULTIPOLYGON (((627397.1 15…\n\n\nDon Tum\n133.250000\n112.800000\nMULTIPOLYGON (((620292.6 15…\n\n\nBang Len\n67.600000\n73.000000\nMULTIPOLYGON (((631987.6 15…\n\n\nSam Phran\n190.285714\n199.875000\nMULTIPOLYGON (((636176.3 15…\n\n\nPhutthamonthon\n206.000000\n187.750000\nMULTIPOLYGON (((637713.4 15…\n\n\nMueang Samut Sakhon\n138.250000\n277.600000\nMULTIPOLYGON (((646615.4 15…\n\n\nKrathum Baen\n262.400000\n230.333333\nMULTIPOLYGON (((641549.1 15…\n\n\nBan Phaeo\n390.666667\n320.500000\nMULTIPOLYGON (((625054.6 15…\n\n\n\n\n\nWe now plot the lag accident count and w_ave_acc maps next to each other for comparison using the qtm() function of the tmap package.\n\nw_avg_acc &lt;- qtm(boundary_with_accident_count, \"lag_window_avg acc\")\ntmap_arrange(lag_acc, w_avg_acc, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\nequal &lt;- tm_shape(boundary_with_accident_count) +\n  tm_fill(\"accident_count\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile &lt;- tm_shape(boundary_with_accident_count) +\n  tm_fill(\"accident_count\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#monte-carlo-morans-i",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#monte-carlo-morans-i",
    "title": "Take Home Exercise 1",
    "section": "Monte Carlo Moran’s I",
    "text": "Monte Carlo Moran’s I\nWe now implement the moran.mc() function of the spdep package. In this scenario, we will run 1000 simulations.\n\nbperm= moran.mc(boundary_with_accident_count$accident_count, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  boundary_with_accident_count$accident_count \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.23576, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nBased on the above output, p-value (0.001)&lt;0.05, thus we can reject the null hypothesis at a 5% significance level and conclude that there is indeed spatial clustering."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#visualizing-monte-carlo-morans-i",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#visualizing-monte-carlo-morans-i",
    "title": "Take Home Exercise 1",
    "section": "Visualizing Monte Carlo Moran’s I",
    "text": "Visualizing Monte Carlo Moran’s I\nWe can visualize the test statistics obtained from the simulation above by implementing the hist() and abline() functions of R graphics.\n\nSummary StatisticsThe plotggplot method\n\n\nWe first calculate the mean and variance, and obtain the summary statistics.\n\nmean(bperm$res[1:999])\n\n[1] -0.01073838\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.00437831\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.20513 -0.05612 -0.01518 -0.01074  0.03086  0.23281 \n\n\n\n\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\n\n\n\n\nFrom the above, we can infer that over half of all simulations indicate a negative value for Moran’s I statistic. Generally, a negative value indicates that dissimilar regions are located next to each other. (i.e: regions with dissimilar number of Accidents are located next to each other)\n\n\nWe can also make use of the ggplot2 R package to produce a plot.\n\ndata &lt;- data.frame(simulated_moran = bperm$res)\n\nggplot(data, aes(x = simulated_moran)) +\n  geom_histogram(binwidth = (max(data$simulated_moran) - min(data$simulated_moran)) / 20, \n                 fill = \"lightblue\", color = \"black\") +\n  geom_vline(xintercept = 0, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"Simulated Moran's I\", \n       y = \"Frequency\",\n       title = \"Histogram of Simulated Moran's I\") +\n  theme_minimal()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#local-morans-i",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#local-morans-i",
    "title": "Take Home Exercise 1",
    "section": "Local Morans I",
    "text": "Local Morans I\nWe implement the localmoran() function of spdep compute the local Moran’s I statistic. This function helps us compute li values, given a set of zi values and a listw object providing neighbor weighting information for the polygon associated with the zi values.\nWe compute local Moran’s I of accident_count at the district level.\n\nfips &lt;- order(boundary_with_accident_count$accident_count)\nlocalMI &lt;- localmoran(boundary_with_accident_count$accident_count, rswm_q)\nhead(localMI)\n\n           Ii          E.Ii      Var.Ii       Z.Ii Pr(z != E(Ii))\n1  0.60429563 -0.0079097813 0.070446604  2.3065726    0.021078658\n2  0.45651029 -0.0079097813 0.070446604  1.7497699    0.080158019\n3 -0.65867321 -0.0031893365 0.060342196 -2.6684032    0.007621273\n4  0.54837408 -0.0071586128 0.106462820  1.7025922    0.088644413\n5  0.02048823 -0.0004311934 0.003869271  0.3363063    0.736639872\n6  0.17288609 -0.0069766753 0.085295392  0.6158550    0.537990224\n\n\n\nlocalmoran() function returns a matrix of values whose columns are:\n\nIi: the local Moran’s I statistics\nE.Ii: the expectation of local moran statistic under the randomisation hypothesis\nVar.Ii: the variance of local moran statistic under the randomisation hypothesis\nZ.Ii:the standard deviate of local moran statistic\nPr(): the p-value of local moran statistic\n\n\nWe now use the printCoefmat() to display the content of the local Moran matrix that we created above.\n\nprintCoefmat(data.frame(\n  localMI[fips,], \n  row.names=boundary_with_accident_count$ADM2_EN.x[fips]),\n  check.names=FALSE)\n\n                              Ii        E.Ii      Var.Ii        Z.Ii\nPhra Nakhon           6.0430e-01 -7.9098e-03  7.0447e-02  2.3066e+00\nDusit                 4.5651e-01 -7.9098e-03  7.0447e-02  1.7498e+00\nPom Prap Sattru Phai  5.7718e-01 -7.9098e-03  1.1755e-01  1.7065e+00\nSamphanthawong        5.7643e-01 -7.9098e-03  1.1755e-01  1.7044e+00\nBangkok Yai           2.7767e-01 -7.9098e-03  1.1755e-01  8.3295e-01\nNong Khaem           -5.0752e-01 -7.9098e-03  1.1755e-01 -1.4572e+00\nKhlong San            5.9394e-01 -7.8138e-03  9.5450e-02  1.9477e+00\nBangkok Noi           2.6106e-01 -7.8138e-03  1.1613e-01  7.8898e-01\nThon Buri             4.9558e-01 -7.7185e-03  7.9701e-02  1.7828e+00\nPhasi Charoen         7.2382e-02 -7.7185e-03  7.9701e-02  2.8373e-01\nPhra Khanong         -2.1018e-01 -7.3429e-03  8.9740e-02 -6.7710e-01\nDin Daeng             3.2865e-01 -7.3429e-03  1.3835e-01  9.0331e-01\nVadhana               3.9977e-01 -7.3429e-03  8.9740e-02  1.3590e+00\nBang Rak              5.4837e-01 -7.1586e-03  1.0646e-01  1.7026e+00\nSathon                4.3876e-01 -7.1586e-03  8.7504e-02  1.5074e+00\nBang Sue              3.2934e-01 -7.1586e-03  7.3961e-02  1.2373e+00\nBang Kapi             1.7289e-01 -6.9767e-03  8.5295e-02  6.1586e-01\nBang Kho Laem         4.2715e-01 -6.7082e-03  9.9809e-02  1.3733e+00\nBueng Kum            -1.4140e-01 -6.3583e-03  9.4637e-02 -4.3898e-01\nBang Phlat            2.5840e-01 -5.8512e-03  7.1616e-02  9.8744e-01\nNong Suea            -1.1495e+00 -5.7687e-03  2.2361e-01 -2.4187e+00\nThung Khru           -1.5046e-01 -5.6055e-03  8.3495e-02 -5.0131e-01\nHuai Khwang           3.3009e-01 -5.4446e-03  4.8612e-02  1.5219e+00\nWang Thonglang        3.9902e-01 -5.2861e-03  1.3487e-01  1.1009e+00\nLak Si                1.3769e-01 -5.2077e-03  6.3782e-02  5.6584e-01\nDon Tum               9.4804e-02 -5.2077e-03  9.8330e-02  3.1894e-01\nRatchathewi           4.0649e-01 -4.9761e-03  6.0959e-02  1.6665e+00\nKhlong Toei           1.3206e-01 -4.2420e-03  5.2005e-02  5.9770e-01\nPathum Wan            4.1399e-01 -4.1719e-03  3.7296e-02  2.1653e+00\nBang Kruai           -1.5533e-01 -3.8297e-03  3.9701e-02 -7.6037e-01\nRat Burana            7.0045e-02 -3.5022e-03  4.2967e-02  3.5481e-01\nSai Noi               1.0630e-01 -3.2507e-03  4.8535e-02  4.9727e-01\nNong Chok            -6.5867e-01 -3.1893e-03  6.0342e-02 -2.6684e+00\nPhutthamonthon       -9.9194e-02 -3.1893e-03  3.3083e-02 -5.2782e-01\nSam Khok             -2.9599e-01 -3.0683e-03  7.8458e-02 -1.0458e+00\nLat Phrao             2.3647e-01 -2.8911e-03  3.5491e-02  1.2706e+00\nDon Mueang           -8.3944e-02 -2.6075e-03  3.2019e-02 -4.5455e-01\nKrathum Baen         -2.1123e-01 -2.6075e-03  3.8957e-02 -1.0570e+00\nMin Buri             -4.9826e-01 -2.4982e-03  3.7327e-02 -2.5660e+00\nBang Na              -3.8999e-01 -2.0842e-03  3.1155e-02 -2.1977e+00\nPhaya Thai            2.3471e-01 -1.9866e-03  2.9698e-02  1.3735e+00\nKamphaeng Saen        7.3445e-02 -1.9866e-03  5.0854e-02  3.3450e-01\nLat Lum Kaeo          5.2453e-02 -1.8913e-03  2.8277e-02  3.2317e-01\nPhra Samut Chedi     -1.5870e-01 -1.4915e-03  2.8267e-02 -9.3503e-01\nBang Bon             -1.0360e-01 -1.2133e-03  1.2611e-02 -9.1175e-01\nBang Len              1.4226e-01 -1.2133e-03  1.8152e-02  1.0649e+00\nNakhon Chai Si        3.1698e-02 -9.9768e-04  1.4930e-02  2.6759e-01\nBan Phaeo            -2.8097e-01 -8.6565e-04  2.2184e-02 -1.8806e+00\nBang Yai              5.0958e-02 -6.0283e-04  9.0244e-03  5.4276e-01\nBang Khen             2.0488e-02 -4.3119e-04  3.8693e-03  3.3631e-01\nMueang Pathum Thani  -1.0470e-01 -3.8742e-04  4.0301e-03 -1.6432e+00\nYan Nawa              2.4924e-02 -2.0371e-04  3.0508e-03  4.5494e-01\nChom Thong            4.0971e-02 -1.2158e-04  1.4967e-03  1.0622e+00\nChatuchak             3.5183e-02 -6.0530e-05  4.7609e-04  1.6152e+00\nSai Mai              -6.5785e-04 -4.2214e-08  8.0124e-07 -7.3488e-01\nSuan Luang           -3.8712e-05 -7.6848e-07  9.4613e-06 -1.2336e-02\nMueang Nonthaburi    -5.4655e-03 -6.2488e-06  6.5027e-05 -6.7699e-01\nKhlong Sam Wa         3.7824e-02 -1.3683e-04  1.6844e-03  9.2494e-01\nPak Kret             -2.7988e-02 -2.2332e-04  2.7488e-03 -5.2957e-01\nBang Bua Thong       -6.6869e-02 -1.5866e-03  2.3728e-02 -4.2380e-01\nMueang Nakhon Pathom -7.8933e-02 -1.9026e-03  3.6044e-02 -4.0574e-01\nMueang Samut Prakan   3.2339e-01 -2.2990e-03  3.4358e-02  1.7571e+00\nSam Phran             6.0701e-02 -3.0827e-03  3.1981e-02  3.5667e-01\nBang Khun Thian       1.8656e-01 -3.4537e-03  5.1556e-02  8.3683e-01\nBang Khae             3.3266e-01 -7.0892e-03  1.0544e-01  1.0463e+00\nThanyaburi            9.2497e-01 -1.4248e-02  2.6658e-01  1.8191e+00\nSaphan Sung           7.4410e-01 -1.4378e-02  1.4747e-01  1.9751e+00\nBang Bo               2.1695e+00 -1.8681e-02  3.4795e-01  3.7095e+00\nKhan Na Yao          -4.4722e-02 -2.3052e-02  3.3734e-01 -3.7310e-02\nTaling Chan          -1.2591e-02 -2.3382e-02  2.3763e-01  2.2136e-02\nBang Sao Thong        2.9810e+00 -2.3382e-02  5.8570e-01  3.9257e+00\nPhra Pradaeng        -5.8509e-01 -3.1998e-02  2.7807e-01 -1.0489e+00\nBang Phli             2.3769e+00 -4.0427e-02  4.7760e-01  3.4978e+00\nPrawet                1.6089e+00 -4.2186e-02  4.9747e-01  2.3410e+00\nLam Luk Ka            1.0605e-02 -5.0323e-02  5.8839e-01  7.9431e-02\nKhlong Luang         -1.6589e-01 -7.2197e-02  1.2714e+00 -8.3095e-02\nThawi Watthana        3.4609e-01 -9.7330e-02  1.0817e+00  4.2635e-01\nMueang Samut Sakhon  -4.0011e-01 -1.3165e-01  2.1698e+00 -1.8225e-01\nLat Krabang           3.2578e+00 -1.6980e-01  1.4670e+00  2.8299e+00\n                     Pr.z....E.Ii..\nPhra Nakhon                  0.0211\nDusit                        0.0802\nPom Prap Sattru Phai         0.0879\nSamphanthawong               0.0883\nBangkok Yai                  0.4049\nNong Khaem                   0.1451\nKhlong San                   0.0514\nBangkok Noi                  0.4301\nThon Buri                    0.0746\nPhasi Charoen                0.7766\nPhra Khanong                 0.4983\nDin Daeng                    0.3664\nVadhana                      0.1741\nBang Rak                     0.0886\nSathon                       0.1317\nBang Sue                     0.2160\nBang Kapi                    0.5380\nBang Kho Laem                0.1697\nBueng Kum                    0.6607\nBang Phlat                   0.3234\nNong Suea                    0.0156\nThung Khru                   0.6162\nHuai Khwang                  0.1280\nWang Thonglang               0.2709\nLak Si                       0.5715\nDon Tum                      0.7498\nRatchathewi                  0.0956\nKhlong Toei                  0.5500\nPathum Wan                   0.0304\nBang Kruai                   0.4470\nRat Burana                   0.7227\nSai Noi                      0.6190\nNong Chok                    0.0076\nPhutthamonthon               0.5976\nSam Khok                     0.2957\nLat Phrao                    0.2039\nDon Mueang                   0.6494\nKrathum Baen                 0.2905\nMin Buri                     0.0103\nBang Na                      0.0280\nPhaya Thai                   0.1696\nKamphaeng Saen               0.7380\nLat Lum Kaeo                 0.7466\nPhra Samut Chedi             0.3498\nBang Bon                     0.3619\nBang Len                     0.2869\nNakhon Chai Si               0.7890\nBan Phaeo                    0.0600\nBang Yai                     0.5873\nBang Khen                    0.7366\nMueang Pathum Thani          0.1003\nYan Nawa                     0.6492\nChom Thong                   0.2882\nChatuchak                    0.1063\nSai Mai                      0.4624\nSuan Luang                   0.9902\nMueang Nonthaburi            0.4984\nKhlong Sam Wa                0.3550\nPak Kret                     0.5964\nBang Bua Thong               0.6717\nMueang Nakhon Pathom         0.6849\nMueang Samut Prakan          0.0789\nSam Phran                    0.7213\nBang Khun Thian              0.4027\nBang Khae                    0.2954\nThanyaburi                   0.0689\nSaphan Sung                  0.0483\nBang Bo                      0.0002\nKhan Na Yao                  0.9702\nTaling Chan                  0.9823\nBang Sao Thong               0.0001\nPhra Pradaeng                0.2942\nBang Phli                    0.0005\nPrawet                       0.0192\nLam Luk Ka                   0.9367\nKhlong Luang                 0.9338\nThawi Watthana               0.6698\nMueang Samut Sakhon          0.8554\nLat Krabang                  0.0047\n\n\n\nMapping the local Moran’s I\nBefore we map the local Moran’s I map, it is wise to append the local Moran’s data-frame (localMI) onto our SpatialPolygonDataFrame.\n\nbmr.localMI &lt;- cbind(boundary_with_accident_count,localMI) %&gt;%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\n\nMapping Local Moran’s I values\nWe now make use of the tmap package and its choropleth mapping functions to plot the local Moran’s I values.\n\ntm_shape(bmr.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\nMapping Local Moran’s I p-values\nThe Choropleth reveals the presence of both positive, as well as negative I values. This indicates that there are varying levels of spatial autocorrelation, however, we must examine the p-values for these I values to check for statistical significance.\nWe use the tmap package to draw a choropleth map of Moran’s I p-values.\n\ntm_shape(bmr.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\nMapping both local Moran’s I values and p-values\nIn the interest of easier analysis and interpretation, we plot the two maps next to each other.\n\nlocalMI.map &lt;- tm_shape(bmr.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\npvalue.map &lt;- tm_shape(bmr.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#getis-and-ords-g-statistics",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#getis-and-ords-g-statistics",
    "title": "Take Home Exercise 1",
    "section": "Getis and Ord’s G-Statistics",
    "text": "Getis and Ord’s G-Statistics\nAn alternative spatial statistic used to detect spatial anomalies is the Getis-Ord G-statistic (Getis and Ord, 1972; Ord and Getis, 1995). This method examines spatial relationships within a defined proximity to identify clusters of high or low values. Statistically significant hotspots are areas where high values are spatially clustered, meaning that not only do these areas have high values, but their neighboring areas also exhibit similarly high values.\nThe analysis involves three key steps:\n\nDeriving the spatial weight matrix: This defines the spatial relationships between areas, specifying which locations are considered neighbors based on proximity.\nComputing the Gi statistic: This step calculates the G-statistic for each location, identifying regions where values are significantly higher or lower than expected.\nMapping the Gi statistics: The results are visualized to reveal spatial patterns of high-value clusters (hotspots) and low-value clusters (cold spots).\n\nThis approach is useful for identifying localized patterns of spatial clustering and detecting significant anomalies in the data."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#deriving-distance-based-weight-matrix",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#deriving-distance-based-weight-matrix",
    "title": "Take Home Exercise 1",
    "section": "Deriving Distance Based Weight Matrix",
    "text": "Deriving Distance Based Weight Matrix\nWe start by defining a new set of neighbors. While the spatial autocorrelation considered units which shared borders, for Getis-Ord, we will define the neighbors based on distance.\n\nThere are two types of distance-based proximity matrices:\n\nFixed Distance Weight Matrix\nAdaptive Distance Weight Matrix\n\n\nBefore creating our connectivity graph, we need to assign a point to each polygon. This requires more than simply running st_centroid() on the us.bound spatial object. Specifically, we need to extract the coordinates into a separate data frame. We have already done this earlier and stored them under the name coords.\nMapping functions apply a specific operation to each element of a vector and return a vector of the same length. In our case, the input vector will be the geometry column from us.bound, and the function we’ll apply is st_centroid(). We’ll use the map_dbl variation from the purrr package, which is designed to return numeric (double) values.\nTo extract the longitude values, we’ll map the st_centroid() function over the geometry column and use double bracket notation [[]] with 1 to access the first element of each centroid, which corresponds to the longitude.\nFor more detailed information, you can refer to the map documentation here.\n\nDetermine the Cut-off Distance\nTo determine the upper limit for the distance band, we follow these steps:\n\nFind the k-nearest neighbors: Use the knearneigh() function from the spdep package. This function returns a matrix that contains the indices of points corresponding to the k-nearest neighbors for each observation.\nConvert to a neighbors list: Take the k-nearest neighbors object returned by knearneigh() and convert it into a neighbors list (class nb) by using the knn2nb() function. This generates a list of integer vectors, where each vector contains the region numbers corresponding to its neighbors.\nCalculate neighbor distances: Use the nbdists() function from spdep to calculate the distances between neighbors. The function returns the lengths of neighbor relationship edges in the units of the coordinates (e.g., kilometers if the coordinates are geographic).\nFlatten the distance list: The distances returned by nbdists() are stored in a list. Use the unlist() function to remove the list structure and return a single vector of distances.\n\nThis process helps identify the upper limit for a distance band by analyzing the distances between neighboring regions.\n\nk1 &lt;- knn2nb(knearneigh(coords))\nk1dists &lt;- unlist(nbdists(k1, coords, longlat = FALSE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1390    2805    4986    6259    8476   16797 \n\n\nFrom the above output, we can infer that the largest first-nearest neighbor distance is just under 17000M.\nUsing this as the upper threshold gives certainty that all units will have at least one neighbor.\n\n\nComputing fixed distance weight matrix\nWe implement the dnearneigh() function of the spdep package to compute the distance weight matrix.\n\nwm_d62 &lt;- dnearneigh(coords, 0, 17000, longlat = FALSE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 1766 \nPercentage nonzero weights: 28.29675 \nAverage number of links: 22.35443 \n\n\nAfter this, we implement the nb2listw() function to convert the nb object into spatial weights object.\nOn average, each region has approximately 22.3neighbors.\n\nwm62_lw &lt;- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 1766 \nPercentage nonzero weights: 28.29675 \nAverage number of links: 22.35443 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 19 20 21 22 23 25 26 27 29 31 32 \n 3  5  3  6  1  2  1  2  2  1  1  1  1  1  3  1  1  1  2  1  2  1  1  2  2  1 \n33 34 35 36 37 38 39 40 41 42 \n 1  1  5  1  4  4  8  4  1  2 \n3 least connected regions:\n66 71 79 with 1 link\n2 most connected regions:\n14 37 with 42 links\n\nWeights style: B \nWeights constants summary:\n   n   nn   S0   S1     S2\nB 79 6241 1766 3532 226656\n\n\n\n\nComputing Gi statistics using Fixed Distance\n\nfips &lt;- order(boundary_with_accident_count$accident_count)\ngi.fixed &lt;- localG(boundary_with_accident_count$accident_count, wm62_lw)\ngi.fixed\n\n [1] -3.35336397 -3.12912595  2.66840322 -3.40300611 -1.55553377 -1.60535680\n [7] -3.49157140 -3.33512452 -2.30441253  1.39585137  2.02857406 -3.14674976\n[13] -3.17369454 -3.11393349 -2.81776564 -2.72683627 -2.88374141 -3.09409303\n[19] -3.12869158 -2.97426998 -1.24486361 -2.45871841 -0.73868252 -3.41408938\n[25] -2.89311199 -3.10698762 -1.21501813 -3.40300611 -3.97875100 -3.49579305\n[31] -3.68769474  0.40369815 -2.86023380 -2.45892382 -2.82195856 -0.92940375\n[37] -3.00458192 -2.79839385 -3.02803442 -2.34863826 -2.70055541 -0.22060572\n[43] -0.64115983  0.20224677 -3.19200023  1.40767563 -2.13429423 -2.10096499\n[49] -2.78620527 -1.47043641  1.55439452  2.25397760  3.05249557 -3.47654632\n[55] -0.01782564  4.36180044 -2.68397915 -2.21092597  0.65770388 -0.78671988\n[61] -0.20919415 -1.51459191 -0.54373150  0.45951200  2.18029716  1.04197980\n[67] -0.32317456  0.39447801  1.04576806 -0.64165535 -0.63894290 -0.13934645\n[73] -0.31893930 -0.81293378 -1.00959192  0.67569728 -0.47712106  2.54803258\n[79]  3.18220373\nattr(,\"internals\")\n               Gi      E(Gi)        V(Gi)       Z(Gi) Pr(z != E(Gi))\n [1,] 0.272139227 0.51282051 0.0051513761 -3.35336397   7.983565e-04\n [2,] 0.288233482 0.51282051 0.0051513761 -3.12912595   1.753271e-03\n [3,] 0.136391769 0.05128205 0.0010173148  2.66840322   7.621273e-03\n [4,] 0.255432270 0.50000000 0.0051650300 -3.40300611   6.664879e-04\n [5,] 0.180171073 0.28205128 0.0042896392 -1.55553377   1.198190e-01\n [6,] 0.333924168 0.44871795 0.0051132094 -1.60535680   1.084153e-01\n [7,] 0.247971563 0.50000000 0.0052102341 -3.49157140   4.801881e-04\n [8,] 0.273448329 0.51282051 0.0051513761 -3.33512452   8.526121e-04\n [9,] 0.296456086 0.46153846 0.0051319328 -2.30441253   2.119950e-02\n[10,] 0.241985442 0.16666667 0.0029115761  1.39585137   1.627593e-01\n[11,] 0.224129353 0.12820513 0.0022360158  2.02857406   4.250169e-02\n[12,] 0.258016812 0.48717949 0.0053035095 -3.14674976   1.650962e-03\n[13,] 0.272139227 0.50000000 0.0051547652 -3.17369454   1.505120e-03\n[14,] 0.313468692 0.53846154 0.0052205800 -3.11393349   1.846111e-03\n[15,] 0.284889094 0.48717949 0.0051539569 -2.81776564   4.835909e-03\n[16,] 0.278838749 0.47435897 0.0051412089 -2.72683627   6.394476e-03\n[17,] 0.292251891 0.50000000 0.0051899304 -2.88374141   3.929813e-03\n[18,] 0.290720062 0.51282051 0.0051526678 -3.09409303   1.974156e-03\n[19,] 0.183188452 0.41025641 0.0052672775 -3.12869158   1.755865e-03\n[20,] 0.261070466 0.47435897 0.0051424981 -2.97426998   2.936866e-03\n[21,] 0.109258240 0.17948718 0.0031826485 -1.24486361   2.131819e-01\n[22,] 0.260782502 0.43589744 0.0050725786 -2.45871841   1.394339e-02\n[23,] 0.198059449 0.24358974 0.0037991399 -0.73868252   4.600998e-01\n[24,] 0.203309875 0.44871795 0.0051668746 -3.41408938   6.399558e-04\n[25,] 0.278947774 0.48717949 0.0051803995 -2.89311199   3.814453e-03\n[26,] 0.302696456 0.52564103 0.0051489035 -3.10698762   1.890043e-03\n[27,] 0.287300486 0.37179487 0.0048360434 -1.21501813   2.243592e-01\n[28,] 0.255432270 0.50000000 0.0051650300 -3.40300611   6.664879e-04\n[29,] 0.214054554 0.50000000 0.0051650300 -3.97875100   6.927825e-05\n[30,] 0.219772515 0.47435897 0.0053037027 -3.49579305   4.726551e-04\n[31,] 0.222076621 0.48717949 0.0051679573 -3.68769474   2.262949e-04\n[32,] 0.348255907 0.32051282 0.0047227618  0.40369815   6.864347e-01\n[33,] 0.268196569 0.47435897 0.0051953627 -2.86023380   4.233288e-03\n[34,] 0.270124805 0.44871795 0.0052752059 -2.45892382   1.393542e-02\n[35,] 0.244120853 0.44871795 0.0052565120 -2.82195856   4.773134e-03\n[36,] 0.139284608 0.19230769 0.0032547762 -0.92940375   3.526799e-01\n[37,] 0.322498456 0.53846154 0.0051664346 -3.00458192   2.659461e-03\n[38,] 0.247349276 0.44871795 0.0051780488 -2.79839385   5.135745e-03\n[39,] 0.282434515 0.50000000 0.0051624800 -3.02803442   2.461500e-03\n[40,] 0.181588505 0.34615385 0.0049095816 -2.34863826   1.884220e-02\n[41,] 0.138865303 0.32051282 0.0045243141 -2.70055541   6.922381e-03\n[42,] 0.179613165 0.19230769 0.0033113077 -0.22060572   8.253994e-01\n[43,] 0.251734311 0.29487179 0.0045266509 -0.64115983   5.214188e-01\n[44,] 0.295476190 0.28205128 0.0044061520  0.20224677   8.397238e-01\n[45,] 0.269990738 0.50000000 0.0051923603 -3.19200023   1.412912e-03\n[46,] 0.228125000 0.15384615 0.0027843582  1.40767563   1.592271e-01\n[47,] 0.246087091 0.39743590 0.0050286269 -2.13429423   3.281870e-02\n[48,] 0.123152307 0.25641026 0.0040229869 -2.10096499   3.564404e-02\n[49,] 0.144135802 0.33333333 0.0046111018 -2.78620527   5.332909e-03\n[50,] 0.174530498 0.26923077 0.0041477249 -1.47043641   1.414436e-01\n[51,] 0.137752297 0.07692308 0.0015314471  1.55439452   1.200903e-01\n[52,] 0.078208290 0.02564103 0.0005439157  2.25397760   2.419758e-02\n[53,] 0.259036145 0.11538462 0.0022146771  3.05249557   2.269471e-03\n[54,] 0.169802258 0.42307692 0.0053074689 -3.47654632   5.079165e-04\n[55,] 0.114558287 0.11538462 0.0021488926 -0.01782564   9.857780e-01\n[56,] 0.193237100 0.05128205 0.0010591808  4.36180044   1.289965e-05\n[57,] 0.205586331 0.39743590 0.0051093231 -2.68397915   7.275164e-03\n[58,] 0.217455164 0.37179487 0.0048731182 -2.21092597   2.704096e-02\n[59,] 0.174321909 0.14102564 0.0025628920  0.65770388   5.107284e-01\n[60,] 0.067540006 0.10256410 0.0019819543 -0.78671988   4.314459e-01\n[61,] 0.032644852 0.03846154 0.0007731295 -0.20919415   8.342967e-01\n[62,] 0.104971080 0.19230769 0.0033250748 -1.51459191   1.298758e-01\n[63,] 0.078550319 0.10256410 0.0019505280 -0.54373150   5.866262e-01\n[64,] 0.036267748 0.02564103 0.0005348167  0.45951200   6.458665e-01\n[65,] 0.100309499 0.03846154 0.0008046729  2.18029716   2.923544e-02\n[66,] 0.029702206 0.01282051 0.0002624904  1.04197980   2.974210e-01\n[67,] 0.052627500 0.06410256 0.0012607702 -0.32317456   7.465630e-01\n[68,] 0.064076731 0.05128205 0.0010519939  0.39447801   6.932282e-01\n[69,] 0.067548747 0.03846154 0.0007736300  1.04576806   2.956681e-01\n[70,] 0.010752688 0.02564103 0.0005383798 -0.64165535   5.210970e-01\n[71,] 0.002402356 0.01282051 0.0002658629 -0.63894290   5.228601e-01\n[72,] 0.046816770 0.05128205 0.0010268471 -0.13934645   8.891764e-01\n[73,] 0.041142416 0.05128205 0.0010107147 -0.31893930   7.497725e-01\n[74,] 0.006984324 0.02564103 0.0005266952 -0.81293378   4.162560e-01\n[75,] 0.018554918 0.05128205 0.0010508100 -1.00959192   3.126908e-01\n[76,] 0.117669813 0.08974359 0.0017081266  0.67569728   4.992329e-01\n[77,] 0.014813596 0.02564103 0.0005149838 -0.47712106   6.332759e-01\n[78,] 0.175209043 0.07692308 0.0014878977  2.54803258   1.083324e-02\n[79,] 0.064849332 0.01282051 0.0002673203  3.18220373   1.461590e-03\nattr(,\"cluster\")\n [1] Low  Low  Low  Low  Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[16] Low  Low  Low  High Low  High Low  Low  Low  Low  Low  Low  Low  Low  Low \n[31] Low  High Low  High Low  Low  Low  Low  Low  High Low  Low  High High Low \n[46] High Low  High Low  Low  High High High High Low  High High Low  Low  High\n[61] Low  High Low  High High Low  Low  High Low  High Low  Low  Low  Low  High\n[76] Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = boundary_with_accident_count$accident_count, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of the localG() function is a vector containing G or G* values, with the following attributes: - \"gstari\": Indicates whether the G* version of the statistic was used (TRUE or FALSE). - \"call\": Stores the function call. - \"class\": Set to \"localG\", identifying the object type.\nThe Gi statistic is represented as a Z-score, where larger values signify stronger clustering. The sign of the value indicates the type of cluster: positive values point to high-value clusters (hotspots), while negative values indicate low-value clusters (cold spots).\nTo merge the Gi values with their corresponding geographic data in the BMR spatial dataframe, use the following code to join the results to the boundary_with_accident_count sf object. This allows for the spatial visualization of clusters within the geographic data.\n\nbmr.gi &lt;- cbind(boundary_with_accident_count, as.matrix(gi.fixed)) %&gt;%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\n\nthe code chunk above actually performs three tasks. First, it convert the output vector (i.e. gi.fixed) into r matrix object by using as.matrix(). Next, cbind() is used to join bmr@data and gi.fixed matrix to produce a new SpatialPolygonDataFrame called bmr.gi. Lastly, the field name of the gi values is renamed to gstat_fixed by using rename().\n\nWe can now map the Gi values derived using the fixed-distance weight matrix.\n\nacc_count &lt;- qtm(boundary_with_accident_count, \"accident_count\")\n\nGimap &lt;-tm_shape(bmr.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(acc_count, Gimap, asp=1, ncol=2)\n\n\n\n\n\n\n\n\nFrom the above plot, we can infer that ‘hot spots’ tend to be neighboring regions and likewise for the cold spots too. We see more high value (hot) clusters in the South East region of the Bangkok Metropolitan Region- Near Samut Prakan. The Central Area, near Bangkok and Nonthaburi showcase more ‘cold spots’."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#calculating-g-function-estimates-and-testing-for-complete-spatial-randomness",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#calculating-g-function-estimates-and-testing-for-complete-spatial-randomness",
    "title": "Take Home Exercise 1",
    "section": "Calculating G-function estimates and testing for Complete Spatial Randomness",
    "text": "Calculating G-function estimates and testing for Complete Spatial Randomness\nWe now focus on computing G-function estimates.\nThe test below allows us to understand if accidents in the Bangkok Metropolitan Region exhibit Spatial Clustering or if they are Randomly Distributed.\nWe apply the test for Complete Spatial Randomness to each region individually.\n\nBangkokSamut PrakhanNonthaburiNakhon PathomSamut Sakhon\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Bangkok. Following that, we plot the result.\n\nG_bkk = Gest(acc_bkk_ppp, correction = \"border\")\nplot(G_bkk, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now carry out the monte carlo simulation test for complete spatial randomness.\n\nG_bkk.csr &lt;- envelope(acc_bkk_ppp, Gest, nsim = 99)\n\nGenerating 99 simulations of CSR  ...\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, \n99.\n\nDone.\n\n\n\nplot(G_bkk.csr)\n\n\n\n\n\n\n\n\nIt is clear that that there is clustering exhibited in this scenario as the black line, observed values, is far above the envelope. We have sufficient evidence to reject the null hypothesis.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Samut Prakhan. Following that, we plot the result.\n\nG_smt_pkn = Gest(acc_smt_pkn_ppp, correction = \"border\")\nplot(G_smt_pkn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now implement a monte carlo simulation test for Complete Spatial Random in Samut Prakan.\n\nG_smt_pkn.csr &lt;- envelope(acc_smt_pkn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_smt_pkn.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Samut Prakan do indeed exhibit clustering, more so than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Nonthaburi. Following that, we plot the result.\n\nG_ntbr = Gest(acc_ntbr_ppp, correction = \"border\")\nplot(G_ntbr, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now implement a Monte-Carlo Simulation test to check for complete spatial randomness of roads accidents in Nonthaburi.\n\nG_ntbr.csr &lt;- envelope(acc_ntbr_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_ntbr.csr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Nakhon Pathom. Following that, we plot the result.\n\nG_nkn_ptn = Gest(acc_nkn_ptn_ppp, correction = \"border\")\nplot(G_nkn_ptn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte-Carlo Simulation test for complete spatial randomness for accidents in Nakhon Pathom.\n\nG_nkn_ptn.csr &lt;- envelope(acc_nkn_ptn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_nkn_ptn.csr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Samut Sakhon. Following that, we plot the result.\n\nG_smt_skn = Gest(acc_smt_skn_ppp, correction = \"border\")\nplot(G_smt_skn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte-Carlo Simulation test for complete spatial randomness for accidents in Samut Sakhon.\n\nG_smt_skn.csr &lt;- envelope(acc_smt_skn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_smt_skn.csr)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe grey zone indicates the confidence envelop (In this case, we have set it as 95% as indicated by the critical value of 0.05)\nWhen an observed L value is greater than its corresponding L(theo) value for a particular distance and lower than the upper confidence envelop, spatial clustering for that distance is statistically NOT significant (e.g. distance between B and C).\nWhen an observed L value is smaller than its corresponding L(theo) value for a particular distance and beyond the lower confidence envelop, spatial dispersion for that distance is statistically significant. - When an observed L value is smaller than its corresponding L(theo) value for a particular distance and within the lower confidence envelop, spatial dispersion for that distance is statistically NOT significant (e.g. distance between A and B)."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#kernel-density-estimation-kde",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#kernel-density-estimation-kde",
    "title": "Take Home Exercise 1",
    "section": "1.4.1 Kernel Density Estimation (KDE)",
    "text": "1.4.1 Kernel Density Estimation (KDE)\nKDE will allow us to better estimate the distribution of accidents acrosss the Bangkok Metropolitan Region. Using this, we can make more informed decisions on where to focus resources on to reduce the rate of accidents across the region.\nWe start off by preparing the data for KDE.\n\n# Step 3: Define the window (bounding box) from the boundary\nboundary_bbox &lt;- bbox(boundary_sp)  # Get bounding box of boundary\nwindow &lt;- owin(xrange = boundary_bbox[1, ], yrange = boundary_bbox[2, ])  # Define window\n\n# Step 4: Extract the coordinates from the SpatialPoints object\ncoordinates &lt;- coordinates(bmracc_sp)\n\n# Step 5: Convert the SpatialPoints into a ppp object using the window\nbmracc_ppp &lt;- ppp(x = coordinates[,1], y = coordinates[,2], window = window)\n\n# Step 6: Check the structure of the resulting point pattern object\nsummary(bmracc_ppp)\n\nPlanar point pattern:  12986 points\nAverage intensity 1.101448e-06 points per square unit\n\n*Pattern contains duplicated points*\n\nCoordinates are given to 10 decimal places\n\nWindow: rectangle = [587893.5, 712440.5] x [1484413.7, 1579076.3] units\n                    (124500 x 94660 units)\nWindow area = 11789900000 square units\n\n# You can now use the ppp object for spatial analysis with spatstat\n\n\nNote that you must ensure to convert the spatial objects into ppp (planar point pattern) form before proceeding with Kernel Density Estimation. The spatstat package requires data to be in this format before conducting point pattern analysis. This also improves computational efficiency.\n\n\n1.4.1.1 Dealing with Duplicates\nAfter creating the above PPP object, we check for duplicates by implementing the code chunk below.\n\nany(duplicated(bmracc_ppp))\n\n[1] TRUE\n\n\nWe check the number of duplicates in our data-frame using the code chunk below. The multiplicity() function creates a list of all duplicates after which the sum() function counts the total.\n\nsum(multiplicity(bmracc_ppp)&gt;1)\n\n[1] 2293\n\n\nThere are over 2293 duplicates. In this case, it means we have 2293 overlapping data points.\nUsing the rjitter() function, we deal with these data points by spacing them out slightly around the point. The function adds noise to the data and spreads these points out a little to facilitate visualization.\n\nbmr_ppp_jit &lt;- rjitter(bmracc_ppp, \n                             retry=TRUE, \n                             nsim=1, \n                             drop=TRUE)\n\n\n\n1.4.1.2 Creating an owin object\nWhen analyzing Spatial Point patterns, it is a good practice to confine the boundaries of the analysis with a Geographical area, such as Singapore’s boundary. Using the spatstat package, we can create an owin object that is designed to represent such polygonal regions.\nWe use the as.owin() function as shown in the code chunk below.\n\nbmr_owin &lt;- as.owin(bmr_boundary)\n\nWe use the plot() function to verify if the owin object has been correctly created.\n\nplot(bmr_owin)\n\n\n\n\n\n\n\n\n\n\n1.4.1.3 Computing KDE using automatic bandwidth selection\nWe use the density() function of the spatstat package to compute the kernel density. These are the key configurations used in the computation:\n\nbw.diggle() automatic bandwidth selection method.\nThe smoothing kernel used in this instance is gaussian. Other smoothing methods include “epanechnikov”, “quartic”. or “disc”.\n\n\nkde_bmracc_bw &lt;- density(bmr_ppp_jit,\n                              sigma=bw.diggle,\n                              edge=TRUE,\n                            kernel=\"gaussian\") \n\n\nThe other two methods aside from bw.diggle() are bw.scott() and bw.ppl(). While bw.diggle() focuses on minimizing error in spatial density estimation for point process data and is tailor-made for spatial applications, bw.scott() (Scott’s rule) provides a rule-of-thumb bandwidth and is used in several KDE applications across different types of data besides just spatial data. bw.ppl() uses a more complex and data-driven approach (plug-in) for selecting the bandwidth, aiming to minimize the error in KDE. Like bw.diggle(), It is also tailor-made for spatial point processes, however, it takes a slightly different approach to bw.diggle()\n\nWe will now plot the above using the plot() function.\n\nplot(kde_bmracc_bw)\n\n\n\n\n\n\n\n\nImmediately we notice that the density values are very small. This is because the unit of measurement is in meter, meaning that the density values are computed with a unit of ‘number of points per square meter.’\nWe now use the rescale.ppp() function of the spatstat package to convert the unit of measurement from meter to kilometer. This is done by implementing the code chunk below.\n\nbmracc_ppp.km &lt;- rescale.ppp(bmr_ppp_jit, 1000, \"km\")\n\nAfter this, we re-deploy the density() function using the re-scaled data and plot the KDE map.\n\nkde_bmracc.bw &lt;- density(bmracc_ppp.km, \n                         sigma=bw.diggle, \n                         edge=TRUE, \n                         kernel=\"gaussian\")\nplot(kde_bmracc.bw)\n\n\n\n\n\n\n\n\n\n\n1.4.1.4 Converting the KDE output into a grid object\n\n1.4.1.4.1 Gridded raster\nWe convert the gridded kernel density objects into RasterLayer object by using raster() of the raster package.\n\nkde_bmracc_bw_raster &lt;- raster(kde_bmracc.bw)\n\nThe CRS above is NA, so we now set the CRS to EPSG 32647 of Thailand.\nAfter that, we can implement the plot() function to plot the same.\n\nprojection(kde_bmracc_bw_raster) &lt;- CRS(\"+init=EPSG:32647\")\nplot(kde_bmracc_bw_raster)\n\n\n\n\n\n\n\n\nFrom the above, we infer that the South-East region, specifically districts around the Samut Prakan province seem to have a higher density of accidents."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#second-order-spatial-point-pattern-analysis.",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#second-order-spatial-point-pattern-analysis.",
    "title": "Take Home Exercise 1",
    "section": "1.4.2 Second-Order Spatial Point Pattern Analysis.",
    "text": "1.4.2 Second-Order Spatial Point Pattern Analysis.\nWe now focus on Second Order Spatial Point Patterns Analysis.\nWe first filter the data down to the regions of interest and create separate boundaries for each of them. Following this, we produce an owin object using the as.owin() function.\n\n# Filtering the data down to the regions of interest\nbkk = bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Bangkok\")\nsmt_pkn = bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Samut Prakan\")\nntbr = bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Nonthaburi\")\nnkn_ptn= bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Nakhon Pathom\")\nsmt_skn= bmr_boundary %&gt;%\n  filter(ADM1_EN == \"Samut Sakhon\")\nptm_thn= bmr_boundary%&gt;%\n  filter(ADM1_EN=='Pathum Thani')\n\n# Creating the owin object\nbkk_owin = as.owin(bkk)\nsmt_pkn_owin = as.owin(smt_pkn)\nntbr_owin = as.owin(ntbr)\nnkn_ptn_owin = as.owin(nkn_ptn)\nsmt_skn_owin = as.owin(smt_skn)\nptm_thn_owin= as.owin(ptm_thn)\n\n#Creating point planar patterns\nacc_bkk_ppp = bmr_ppp_jit[bkk_owin]\nacc_smt_pkn_ppp = bmr_ppp_jit[smt_pkn_owin]\nacc_ntbr_ppp = bmr_ppp_jit[ntbr_owin]\nacc_nkn_ptn_ppp = bmr_ppp_jit[nkn_ptn_owin]\nacc_smt_skn_ppp= bmr_ppp_jit[smt_skn_owin]\nacc_ptm_thn_ppp= bmr_ppp_jit[ptm_thn_owin]\n\n\n1.4.2.1 Calculating G-function estimates and testing for Complete Spatial Randomness\nWe now focus on computing G-function estimates.\nThe test below allows us to understand if accidents in the Bangkok Metropolitan Region exhibit Spatial Clustering or if they are Randomly Distributed.\nWe apply the test for Complete Spatial Randomness to each region individually. The tests are conducted at a 5% significance level.\nThe hypotheses are as follows.\n\nH0: There is no spatial clustering. The accidents are randomly distributed across the region.\nH1: There is spatial clustering. The accidents are NOT randomly distributed across the region.\n\n\nBangkokSamut PrakhanNonthaburiNakhon PathomSamut SakhonPatum Thani\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Bangkok. Following that, we plot the result.\n\nG_bkk = Gest(acc_bkk_ppp, correction = \"border\")\nplot(G_bkk, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now carry out the monte carlo simulation test, using the envelope() function, for complete spatial randomness.\n\nG_bkk.csr &lt;- envelope(acc_bkk_ppp, Gest, nsim = 99)\n\nGenerating 99 simulations of CSR  ...\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, \n99.\n\nDone.\n\n\n\nplot(G_bkk.csr)\n\n\n\n\n\n\n\n\nIt is clear that that there is clustering exhibited in this scenario as the black line, observed values, is far above the envelope. We have sufficient evidence to reject the null hypothesis.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Samut Prakhan. Following that, we plot the result.\n\nG_smt_pkn = Gest(acc_smt_pkn_ppp, correction = \"border\")\nplot(G_smt_pkn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now implement a monte carlo simulation test, using the envelope() function, for Complete Spatial Random in Samut Prakan.\n\nG_smt_pkn.csr &lt;- envelope(acc_smt_pkn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_smt_pkn.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Samut Prakan do indeed exhibit clustering, more so than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Nonthaburi. Following that, we plot the result.\n\nG_ntbr = Gest(acc_ntbr_ppp, correction = \"border\")\nplot(G_ntbr, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now implement a Monte-Carlo Simulation test, using the envelope() function, to check for complete spatial randomness of roads accidents in Nonthaburi.\n\nG_ntbr.csr &lt;- envelope(acc_ntbr_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_ntbr.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Nonthaburi do indeed exhibit clustering, more than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Nakhon Pathom. Following that, we plot the result.\n\nG_nkn_ptn = Gest(acc_nkn_ptn_ppp, correction = \"border\")\nplot(G_nkn_ptn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte-Carlo Simulation test, using the envelope() function, for complete spatial randomness for accidents in Nakhon Pathom.\n\nG_nkn_ptn.csr &lt;- envelope(acc_nkn_ptn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_nkn_ptn.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Nakhon Pathom do indeed exhibit clustering, more than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the spatstat package to compute a G-function estimation for Samut Sakhon. Following that, we plot the result.\n\nG_smt_skn = Gest(acc_smt_skn_ppp, correction = \"border\")\nplot(G_smt_skn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte-Carlo Simulation test, using the envelope() function, for complete spatial randomness for accidents in Samut Sakhon.\n\nG_smt_skn.csr &lt;- envelope(acc_smt_skn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_smt_skn.csr)\n\n\n\n\n\n\n\n\nWe once again have sufficient evidence to reject the null hypothesis and conclude that accidents in Samut Sakhon do indeed exhibit clustering, more so than is expected in a region that is randomly distributed.\n\n\nWe use the Gest() function of the Spatstat package to compute a G-function estimation for Patum Thani\n\nG_ptm_thn = Gest(acc_ptm_thn_ppp, correction = \"border\")\nplot(G_nkn_ptn, xlim=c(0,500))\n\n\n\n\n\n\n\n\nWe now conduct the Monte Carlo Simulation Test for Complete Spatial Randomness by implementing the envelope() function.\n\nG_ptm_thn.csr &lt;- envelope(acc_ptm_thn_ppp, Gest, nsim = 199)\n\nGenerating 199 simulations of CSR  ...\n1, 2, 3, 4.6.8.10.12.14.16.18.20.22.24.26.28.30.32.34\n.36.38.40.42.44.46.48.50.52.54.56.58.60.62.64.66.68.70.72.74\n.76.78.80.82.84.86.88.90.92.94.96.98.100.102.104.106.108.110.112.114\n.116.118.120.122.124.126.128.130.132.134.136.138.140.142.144.146.148.150.152.154\n.156.158.160.162.164.166.168.170.172.174.176.178.180.182.184.186.188.190.192.194\n.196.198\n199.\n\nDone.\n\n\n\nplot(G_ptm_thn.csr)\n\n\n\n\n\n\n\n\nWe have sufficient Evidence to reject the null hypothesis and can conclude that accidents in Pathum Thani are not randomly distributed and do indeed exhibit spatial clustering.\n\n\n\n\n\nThe grey zone indicates the confidence envelop (In this case, we have set it as 95% as indicated by the critical value of 0.05)\nWhen an observed L value is greater than its corresponding L(theo) value for a particular distance and lower than the upper confidence envelop, spatial clustering for that distance is statistically NOT significant (e.g. distance between B and C).\nWhen an observed L value is smaller than its corresponding L(theo) value for a particular distance and beyond the lower confidence envelop, spatial dispersion for that distance is statistically significant. - When an observed L value is smaller than its corresponding L(theo) value for a particular distance and within the lower confidence envelop, spatial dispersion for that distance is statistically NOT significant (e.g. distance between A and B).\n\n\n\n1.4.2.2 Clark and Evans Test\nWe now perform the Clark-Evans test of Aggregation for a spatial point pattern by using the clarkevans.test() function of spatstat.\nThe hypotheses that we will be testing are as follows:\nHo = The distribution of accidents are randomly distributed.\nH1= The distribution of accidents are not randomly distributed.\nThe tests will be conducted at a 5% significance level.\n\nBangkokSamut PrakhanSamut SakhonNonthaburiNakhon PathomPatum Thani\n\n\n\nclarkevans.test(acc_bkk_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_bkk_ppp\nR = 0.17748, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_smt_pkn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_smt_pkn_ppp\nR = 0.19392, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_smt_skn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_smt_skn_ppp\nR = 0.27252, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_ntbr_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_ntbr_ppp\nR = 0.41864, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_nkn_ptn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_nkn_ptn_ppp\nR = 0.30788, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nclarkevans.test(acc_ptm_thn_ppp,\n                correction=\"none\",\n                clipregion=NULL,\n                alternative=c(\"two.sided\"),\n                nsim=999)\n\n\n    Clark-Evans test\n    No edge correction\n    Z-test\n\ndata:  acc_ptm_thn_ppp\nR = 0.27399, p-value &lt; 2.2e-16\nalternative hypothesis: two-sided\n\n\n\n\n\nFrom the above outputs, we are able to reject the null hypothesis given the observed p-value is less than 0.05. We have sufficient evidence and can conclude that the distribution of accidents across the Bangkok Metropolitan Region are not randomly distributed and do indeed exhibit spatial clustering."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#hot-and-cold-spot-areas",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#hot-and-cold-spot-areas",
    "title": "Take Home Exercise 1",
    "section": "1.4.5 Hot and Cold Spot Areas",
    "text": "1.4.5 Hot and Cold Spot Areas\n\n1.4.5.1 Getis and Ord’s G-Statistics\nAn alternative spatial statistic used to detect spatial anomalies is the Getis-Ord G-statistic (Getis and Ord, 1972; Ord and Getis, 1995). This method examines spatial relationships within a defined proximity to identify clusters of high or low values. Statistically significant hotspots are areas where high values are spatially clustered, meaning that not only do these areas have high values, but their neighboring areas also exhibit similarly high values.\nThe analysis involves three key steps:\n\nDeriving the spatial weight matrix: This defines the spatial relationships between areas, specifying which locations are considered neighbors based on proximity.\nComputing the Gi statistic: This step calculates the G-statistic for each location, identifying regions where values are significantly higher or lower than expected.\nMapping the Gi statistics: The results are visualized to reveal spatial patterns of high-value clusters (hotspots) and low-value clusters (cold spots).\n\nThis approach is useful for identifying localized patterns of spatial clustering and detecting significant anomalies in the data.\n\n\n1.4.5.2 Deriving Distance Based Weight Matrix\nWe start by defining a new set of neighbors. While the spatial autocorrelation considered units which shared borders, for Getis-Ord, we will define the neighbors based on distance.\n\nThere are two types of distance-based proximity matrices:\n\nFixed Distance Weight Matrix\nAdaptive Distance Weight Matrix\n\n\nBefore creating our connectivity graph, we need to assign a point to each polygon. This requires more than simply running st_centroid() on the us.bound spatial object. Specifically, we need to extract the coordinates into a separate data frame. We have already done this earlier and stored them under the name coords.\nMapping functions apply a specific operation to each element of a vector and return a vector of the same length. In our case, the input vector will be the geometry column from us.bound, and the function we’ll apply is st_centroid(). We’ll use the map_dbl variation from the purrr package, which is designed to return numeric (double) values.\nTo extract the longitude values, we’ll map the st_centroid() function over the geometry column and use double bracket notation [[]] with 1 to access the first element of each centroid, which corresponds to the longitude.\nFor more detailed information, you can refer to the map documentation here.\n\n1.4.5.2.1 Determine the Cut-off Distance\nTo determine the upper limit for the distance band, we follow these steps:\n\nFind the k-nearest neighbors: Use the knearneigh() function from the spdep package. This function returns a matrix that contains the indices of points corresponding to the k-nearest neighbors for each observation.\nConvert to a neighbors list: Take the k-nearest neighbors object returned by knearneigh() and convert it into a neighbors list (class nb) by using the knn2nb() function. This generates a list of integer vectors, where each vector contains the region numbers corresponding to its neighbors.\nCalculate neighbor distances: Use the nbdists() function from spdep to calculate the distances between neighbors. The function returns the lengths of neighbor relationship edges in the units of the coordinates (e.g., kilometers if the coordinates are geographic).\nFlatten the distance list: The distances returned by nbdists() are stored in a list. Use the unlist() function to remove the list structure and return a single vector of distances.\n\nThis process helps identify the upper limit for a distance band by analyzing the distances between neighboring regions.\n\nk1 &lt;- knn2nb(knearneigh(coords))\nk1dists &lt;- unlist(nbdists(k1, coords, longlat = FALSE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1390    2805    4986    6259    8476   16797 \n\n\nFrom the above output, we can infer that the largest first-nearest neighbor distance is just under 17000M.\nUsing this as the upper threshold gives certainty that all units will have at least one neighbor.\n\n\n1.4.5.2.2 Computing fixed distance weight matrix\nWe implement the dnearneigh() function of the spdep package to compute the distance weight matrix.\n\nwm_d62 &lt;- dnearneigh(coords, 0, 17000, longlat = FALSE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 1766 \nPercentage nonzero weights: 28.29675 \nAverage number of links: 22.35443 \n\n\nAfter this, we implement the nb2listw() function to convert the nb object into spatial weights object.\nOn average, each region has approximately 22.3neighbors.\n\nwm62_lw &lt;- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 79 \nNumber of nonzero links: 1766 \nPercentage nonzero weights: 28.29675 \nAverage number of links: 22.35443 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 19 20 21 22 23 25 26 27 29 31 32 \n 3  5  3  6  1  2  1  2  2  1  1  1  1  1  3  1  1  1  2  1  2  1  1  2  2  1 \n33 34 35 36 37 38 39 40 41 42 \n 1  1  5  1  4  4  8  4  1  2 \n3 least connected regions:\n66 71 79 with 1 link\n2 most connected regions:\n14 37 with 42 links\n\nWeights style: B \nWeights constants summary:\n   n   nn   S0   S1     S2\nB 79 6241 1766 3532 226656\n\n\n\n\n\n1.4.5.3 Computing Gi statistics using Fixed Distance\n\nfips &lt;- order(boundary_with_accident_count$accident_count)\ngi.fixed &lt;- localG(boundary_with_accident_count$accident_count, wm62_lw)\ngi.fixed\n\n [1] -3.35336397 -3.12912595  2.66840322 -3.40300611 -1.55553377 -1.60535680\n [7] -3.49157140 -3.33512452 -2.30441253  1.39585137  2.02857406 -3.14674976\n[13] -3.17369454 -3.11393349 -2.81776564 -2.72683627 -2.88374141 -3.09409303\n[19] -3.12869158 -2.97426998 -1.24486361 -2.45871841 -0.73868252 -3.41408938\n[25] -2.89311199 -3.10698762 -1.21501813 -3.40300611 -3.97875100 -3.49579305\n[31] -3.68769474  0.40369815 -2.86023380 -2.45892382 -2.82195856 -0.92940375\n[37] -3.00458192 -2.79839385 -3.02803442 -2.34863826 -2.70055541 -0.22060572\n[43] -0.64115983  0.20224677 -3.19200023  1.40767563 -2.13429423 -2.10096499\n[49] -2.78620527 -1.47043641  1.55439452  2.25397760  3.05249557 -3.47654632\n[55] -0.01782564  4.36180044 -2.68397915 -2.21092597  0.65770388 -0.78671988\n[61] -0.20919415 -1.51459191 -0.54373150  0.45951200  2.18029716  1.04197980\n[67] -0.32317456  0.39447801  1.04576806 -0.64165535 -0.63894290 -0.13934645\n[73] -0.31893930 -0.81293378 -1.00959192  0.67569728 -0.47712106  2.54803258\n[79]  3.18220373\nattr(,\"internals\")\n               Gi      E(Gi)        V(Gi)       Z(Gi) Pr(z != E(Gi))\n [1,] 0.272139227 0.51282051 0.0051513761 -3.35336397   7.983565e-04\n [2,] 0.288233482 0.51282051 0.0051513761 -3.12912595   1.753271e-03\n [3,] 0.136391769 0.05128205 0.0010173148  2.66840322   7.621273e-03\n [4,] 0.255432270 0.50000000 0.0051650300 -3.40300611   6.664879e-04\n [5,] 0.180171073 0.28205128 0.0042896392 -1.55553377   1.198190e-01\n [6,] 0.333924168 0.44871795 0.0051132094 -1.60535680   1.084153e-01\n [7,] 0.247971563 0.50000000 0.0052102341 -3.49157140   4.801881e-04\n [8,] 0.273448329 0.51282051 0.0051513761 -3.33512452   8.526121e-04\n [9,] 0.296456086 0.46153846 0.0051319328 -2.30441253   2.119950e-02\n[10,] 0.241985442 0.16666667 0.0029115761  1.39585137   1.627593e-01\n[11,] 0.224129353 0.12820513 0.0022360158  2.02857406   4.250169e-02\n[12,] 0.258016812 0.48717949 0.0053035095 -3.14674976   1.650962e-03\n[13,] 0.272139227 0.50000000 0.0051547652 -3.17369454   1.505120e-03\n[14,] 0.313468692 0.53846154 0.0052205800 -3.11393349   1.846111e-03\n[15,] 0.284889094 0.48717949 0.0051539569 -2.81776564   4.835909e-03\n[16,] 0.278838749 0.47435897 0.0051412089 -2.72683627   6.394476e-03\n[17,] 0.292251891 0.50000000 0.0051899304 -2.88374141   3.929813e-03\n[18,] 0.290720062 0.51282051 0.0051526678 -3.09409303   1.974156e-03\n[19,] 0.183188452 0.41025641 0.0052672775 -3.12869158   1.755865e-03\n[20,] 0.261070466 0.47435897 0.0051424981 -2.97426998   2.936866e-03\n[21,] 0.109258240 0.17948718 0.0031826485 -1.24486361   2.131819e-01\n[22,] 0.260782502 0.43589744 0.0050725786 -2.45871841   1.394339e-02\n[23,] 0.198059449 0.24358974 0.0037991399 -0.73868252   4.600998e-01\n[24,] 0.203309875 0.44871795 0.0051668746 -3.41408938   6.399558e-04\n[25,] 0.278947774 0.48717949 0.0051803995 -2.89311199   3.814453e-03\n[26,] 0.302696456 0.52564103 0.0051489035 -3.10698762   1.890043e-03\n[27,] 0.287300486 0.37179487 0.0048360434 -1.21501813   2.243592e-01\n[28,] 0.255432270 0.50000000 0.0051650300 -3.40300611   6.664879e-04\n[29,] 0.214054554 0.50000000 0.0051650300 -3.97875100   6.927825e-05\n[30,] 0.219772515 0.47435897 0.0053037027 -3.49579305   4.726551e-04\n[31,] 0.222076621 0.48717949 0.0051679573 -3.68769474   2.262949e-04\n[32,] 0.348255907 0.32051282 0.0047227618  0.40369815   6.864347e-01\n[33,] 0.268196569 0.47435897 0.0051953627 -2.86023380   4.233288e-03\n[34,] 0.270124805 0.44871795 0.0052752059 -2.45892382   1.393542e-02\n[35,] 0.244120853 0.44871795 0.0052565120 -2.82195856   4.773134e-03\n[36,] 0.139284608 0.19230769 0.0032547762 -0.92940375   3.526799e-01\n[37,] 0.322498456 0.53846154 0.0051664346 -3.00458192   2.659461e-03\n[38,] 0.247349276 0.44871795 0.0051780488 -2.79839385   5.135745e-03\n[39,] 0.282434515 0.50000000 0.0051624800 -3.02803442   2.461500e-03\n[40,] 0.181588505 0.34615385 0.0049095816 -2.34863826   1.884220e-02\n[41,] 0.138865303 0.32051282 0.0045243141 -2.70055541   6.922381e-03\n[42,] 0.179613165 0.19230769 0.0033113077 -0.22060572   8.253994e-01\n[43,] 0.251734311 0.29487179 0.0045266509 -0.64115983   5.214188e-01\n[44,] 0.295476190 0.28205128 0.0044061520  0.20224677   8.397238e-01\n[45,] 0.269990738 0.50000000 0.0051923603 -3.19200023   1.412912e-03\n[46,] 0.228125000 0.15384615 0.0027843582  1.40767563   1.592271e-01\n[47,] 0.246087091 0.39743590 0.0050286269 -2.13429423   3.281870e-02\n[48,] 0.123152307 0.25641026 0.0040229869 -2.10096499   3.564404e-02\n[49,] 0.144135802 0.33333333 0.0046111018 -2.78620527   5.332909e-03\n[50,] 0.174530498 0.26923077 0.0041477249 -1.47043641   1.414436e-01\n[51,] 0.137752297 0.07692308 0.0015314471  1.55439452   1.200903e-01\n[52,] 0.078208290 0.02564103 0.0005439157  2.25397760   2.419758e-02\n[53,] 0.259036145 0.11538462 0.0022146771  3.05249557   2.269471e-03\n[54,] 0.169802258 0.42307692 0.0053074689 -3.47654632   5.079165e-04\n[55,] 0.114558287 0.11538462 0.0021488926 -0.01782564   9.857780e-01\n[56,] 0.193237100 0.05128205 0.0010591808  4.36180044   1.289965e-05\n[57,] 0.205586331 0.39743590 0.0051093231 -2.68397915   7.275164e-03\n[58,] 0.217455164 0.37179487 0.0048731182 -2.21092597   2.704096e-02\n[59,] 0.174321909 0.14102564 0.0025628920  0.65770388   5.107284e-01\n[60,] 0.067540006 0.10256410 0.0019819543 -0.78671988   4.314459e-01\n[61,] 0.032644852 0.03846154 0.0007731295 -0.20919415   8.342967e-01\n[62,] 0.104971080 0.19230769 0.0033250748 -1.51459191   1.298758e-01\n[63,] 0.078550319 0.10256410 0.0019505280 -0.54373150   5.866262e-01\n[64,] 0.036267748 0.02564103 0.0005348167  0.45951200   6.458665e-01\n[65,] 0.100309499 0.03846154 0.0008046729  2.18029716   2.923544e-02\n[66,] 0.029702206 0.01282051 0.0002624904  1.04197980   2.974210e-01\n[67,] 0.052627500 0.06410256 0.0012607702 -0.32317456   7.465630e-01\n[68,] 0.064076731 0.05128205 0.0010519939  0.39447801   6.932282e-01\n[69,] 0.067548747 0.03846154 0.0007736300  1.04576806   2.956681e-01\n[70,] 0.010752688 0.02564103 0.0005383798 -0.64165535   5.210970e-01\n[71,] 0.002402356 0.01282051 0.0002658629 -0.63894290   5.228601e-01\n[72,] 0.046816770 0.05128205 0.0010268471 -0.13934645   8.891764e-01\n[73,] 0.041142416 0.05128205 0.0010107147 -0.31893930   7.497725e-01\n[74,] 0.006984324 0.02564103 0.0005266952 -0.81293378   4.162560e-01\n[75,] 0.018554918 0.05128205 0.0010508100 -1.00959192   3.126908e-01\n[76,] 0.117669813 0.08974359 0.0017081266  0.67569728   4.992329e-01\n[77,] 0.014813596 0.02564103 0.0005149838 -0.47712106   6.332759e-01\n[78,] 0.175209043 0.07692308 0.0014878977  2.54803258   1.083324e-02\n[79,] 0.064849332 0.01282051 0.0002673203  3.18220373   1.461590e-03\nattr(,\"cluster\")\n [1] Low  Low  Low  Low  Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[16] Low  Low  Low  High Low  High Low  Low  Low  Low  Low  Low  Low  Low  Low \n[31] Low  High Low  High Low  Low  Low  Low  Low  High Low  Low  High High Low \n[46] High Low  High Low  Low  High High High High Low  High High Low  Low  High\n[61] Low  High Low  High High Low  Low  High Low  High Low  Low  Low  Low  High\n[76] Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = boundary_with_accident_count$accident_count, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of the localG() function is a vector containing G or G* values, with the following attributes: - \"gstari\": Indicates whether the G* version of the statistic was used (TRUE or FALSE). - \"call\": Stores the function call. - \"class\": Set to \"localG\", identifying the object type.\nThe Gi statistic is represented as a Z-score, where larger values signify stronger clustering. The sign of the value indicates the type of cluster: positive values point to high-value clusters (hotspots), while negative values indicate low-value clusters (cold spots).\nTo merge the Gi values with their corresponding geographic data in the BMR spatial dataframe, use the following code to join the results to the boundary_with_accident_count sf object. This allows for the spatial visualization of clusters within the geographic data.\n\nbmr.gi &lt;- cbind(boundary_with_accident_count, as.matrix(gi.fixed)) %&gt;%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\n\nthe code chunk above actually performs three tasks. First, it convert the output vector (i.e. gi.fixed) into r matrix object by using as.matrix(). Next, cbind() is used to join bmr@data and gi.fixed matrix to produce a new SpatialPolygonDataFrame called bmr.gi. Lastly, the field name of the gi values is renamed to gstat_fixed by using rename().\n\nWe can now map the Gi values derived using the fixed-distance weight matrix.\n\nacc_count &lt;- qtm(boundary_with_accident_count, \"accident_count\")\n\nGimap &lt;-tm_shape(bmr.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(acc_count, Gimap, asp=1, ncol=2)\n\n\n\n\n\n\n\n\nFrom the above plot, we can infer that ‘hot spots’ tend to be neighboring regions and likewise for the cold spots too. We see more high value (hot) clusters in the South East region of the Bangkok Metropolitan Region- Near Samut Prakan. The Central Area, near Bangkok and Nonthaburi showcase more ‘cold spots’.\nDistricts Bang Phli, Bang Sao Thong, Bang Bo, Sinakharin, and Suwinthawong seem to be highly linked to each other based on accidents, all in the South-East region of the Bangkok Metropolitan Region."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-autocorrelation-morans-i-test.",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#spatial-autocorrelation-morans-i-test.",
    "title": "Take Home Exercise 1",
    "section": "1.4.4 Spatial Autocorrelation: Morans I test.",
    "text": "1.4.4 Spatial Autocorrelation: Morans I test.\nThe hypotheses for the test are as follows:\n\nH0: Regions with similar number of accidents are randomly distributed.\nH1: Regions with similar number of accidents are not randomly distributed and exhibit spatial clustering.\n\n\nmoran.test(boundary_with_accident_count$accident_count, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  boundary_with_accident_count$accident_count  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 3.7964, p-value = 7.34e-05\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.235764728      -0.012820513       0.004287482 \n\n\nFrom the output above, we can infer the following:\n\nThe p-value (7.34e-05)&lt;0.05, indicating that the observed spatial autocorrelation is statistically significant.\nMoran’s I statistic: The observed value of 0.236 indicates positive spatial autocorrelation, meaning that regions with similar number of accidents are more likely to be located near each other.\n\nSince Moran’s I Statistic is significantly greater than what we would expect in a randomly distributed region. There is significant evidence to reject H0 and conclude that there is indeed spatial clustering with regards to Accidents in the Bangkok Metropolitan Region.\n\n1.4.4.1 Monte Carlo Moran’s I\nWe now implement the moran.mc() function of the spdep package. In this scenario, we will run 1000 simulations.\n\nbperm= moran.mc(boundary_with_accident_count$accident_count, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  boundary_with_accident_count$accident_count \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.23576, observed rank = 999, p-value = 0.001\nalternative hypothesis: greater\n\n\nBased on the above output, p-value (0.001)&lt;0.05, thus we can reject the null hypothesis at a 5% significance level and conclude that there is indeed spatial clustering.\n\n\n1.4.4.2 Visualizing Monte Carlo Moran’s I\nWe can visualize the test statistics obtained from the simulation above by implementing the hist() and abline() functions of R graphics.\n\nSummary StatisticsThe plotggplot method\n\n\nWe first calculate the mean and variance, and obtain the summary statistics.\n\nmean(bperm$res[1:999])\n\n[1] -0.02023623\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.003934229\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.19669 -0.06401 -0.02402 -0.02024  0.01971  0.30376 \n\n\n\n\n\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n\n\n\n\n\n\n\n\nFrom the above, we can infer that over half of all simulations indicate a negative value for Moran’s I statistic. Generally, a negative value indicates that dissimilar regions are located next to each other. (i.e: regions with dissimilar number of Accidents are located next to each other)\n\n\nWe can also make use of the ggplot2 R package to produce a plot.\n\ndata &lt;- data.frame(simulated_moran = bperm$res)\n\nggplot(data, aes(x = simulated_moran)) +\n  geom_histogram(binwidth = (max(data$simulated_moran) - min(data$simulated_moran)) / 20, \n                 fill = \"lightblue\", color = \"black\") +\n  geom_vline(xintercept = 0, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"Simulated Moran's I\", \n       y = \"Frequency\",\n       title = \"Histogram of Simulated Moran's I\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.4.4.3 Local Morans I\nWe implement the localmoran() function of spdep compute the local Moran’s I statistic. This function helps us compute li values, given a set of zi values and a listw object providing neighbor weighting information for the polygon associated with the zi values.\nWe compute local Moran’s I of accident_count at the district level.\n\nfips &lt;- order(boundary_with_accident_count$accident_count)\nlocalMI &lt;- localmoran(boundary_with_accident_count$accident_count, rswm_q)\nhead(localMI)\n\n           Ii          E.Ii      Var.Ii       Z.Ii Pr(z != E(Ii))\n1  0.60429563 -0.0079097813 0.070446604  2.3065726    0.021078658\n2  0.45651029 -0.0079097813 0.070446604  1.7497699    0.080158019\n3 -0.65867321 -0.0031893365 0.060342196 -2.6684032    0.007621273\n4  0.54837408 -0.0071586128 0.106462820  1.7025922    0.088644413\n5  0.02048823 -0.0004311934 0.003869271  0.3363063    0.736639872\n6  0.17288609 -0.0069766753 0.085295392  0.6158550    0.537990224\n\n\n\nlocalmoran() function returns a matrix of values whose columns are:\n\nIi: the local Moran’s I statistics\nE.Ii: the expectation of local moran statistic under the randomisation hypothesis\nVar.Ii: the variance of local moran statistic under the randomisation hypothesis\nZ.Ii:the standard deviate of local moran statistic\nPr(): the p-value of local moran statistic\n\n\nWe now use the printCoefmat() to display the content of the local Moran matrix that we created above.\n\nprintCoefmat(data.frame(\n  localMI[fips,], \n  row.names=boundary_with_accident_count$ADM2_EN.x[fips]),\n  check.names=FALSE)\n\n                              Ii        E.Ii      Var.Ii        Z.Ii\nPhra Nakhon           6.0430e-01 -7.9098e-03  7.0447e-02  2.3066e+00\nDusit                 4.5651e-01 -7.9098e-03  7.0447e-02  1.7498e+00\nPom Prap Sattru Phai  5.7718e-01 -7.9098e-03  1.1755e-01  1.7065e+00\nSamphanthawong        5.7643e-01 -7.9098e-03  1.1755e-01  1.7044e+00\nBangkok Yai           2.7767e-01 -7.9098e-03  1.1755e-01  8.3295e-01\nNong Khaem           -5.0752e-01 -7.9098e-03  1.1755e-01 -1.4572e+00\nKhlong San            5.9394e-01 -7.8138e-03  9.5450e-02  1.9477e+00\nBangkok Noi           2.6106e-01 -7.8138e-03  1.1613e-01  7.8898e-01\nThon Buri             4.9558e-01 -7.7185e-03  7.9701e-02  1.7828e+00\nPhasi Charoen         7.2382e-02 -7.7185e-03  7.9701e-02  2.8373e-01\nPhra Khanong         -2.1018e-01 -7.3429e-03  8.9740e-02 -6.7710e-01\nDin Daeng             3.2865e-01 -7.3429e-03  1.3835e-01  9.0331e-01\nVadhana               3.9977e-01 -7.3429e-03  8.9740e-02  1.3590e+00\nBang Rak              5.4837e-01 -7.1586e-03  1.0646e-01  1.7026e+00\nSathon                4.3876e-01 -7.1586e-03  8.7504e-02  1.5074e+00\nBang Sue              3.2934e-01 -7.1586e-03  7.3961e-02  1.2373e+00\nBang Kapi             1.7289e-01 -6.9767e-03  8.5295e-02  6.1586e-01\nBang Kho Laem         4.2715e-01 -6.7082e-03  9.9809e-02  1.3733e+00\nBueng Kum            -1.4140e-01 -6.3583e-03  9.4637e-02 -4.3898e-01\nBang Phlat            2.5840e-01 -5.8512e-03  7.1616e-02  9.8744e-01\nNong Suea            -1.1495e+00 -5.7687e-03  2.2361e-01 -2.4187e+00\nThung Khru           -1.5046e-01 -5.6055e-03  8.3495e-02 -5.0131e-01\nHuai Khwang           3.3009e-01 -5.4446e-03  4.8612e-02  1.5219e+00\nWang Thonglang        3.9902e-01 -5.2861e-03  1.3487e-01  1.1009e+00\nLak Si                1.3769e-01 -5.2077e-03  6.3782e-02  5.6584e-01\nDon Tum               9.4804e-02 -5.2077e-03  9.8330e-02  3.1894e-01\nRatchathewi           4.0649e-01 -4.9761e-03  6.0959e-02  1.6665e+00\nKhlong Toei           1.3206e-01 -4.2420e-03  5.2005e-02  5.9770e-01\nPathum Wan            4.1399e-01 -4.1719e-03  3.7296e-02  2.1653e+00\nBang Kruai           -1.5533e-01 -3.8297e-03  3.9701e-02 -7.6037e-01\nRat Burana            7.0045e-02 -3.5022e-03  4.2967e-02  3.5481e-01\nSai Noi               1.0630e-01 -3.2507e-03  4.8535e-02  4.9727e-01\nNong Chok            -6.5867e-01 -3.1893e-03  6.0342e-02 -2.6684e+00\nPhutthamonthon       -9.9194e-02 -3.1893e-03  3.3083e-02 -5.2782e-01\nSam Khok             -2.9599e-01 -3.0683e-03  7.8458e-02 -1.0458e+00\nLat Phrao             2.3647e-01 -2.8911e-03  3.5491e-02  1.2706e+00\nDon Mueang           -8.3944e-02 -2.6075e-03  3.2019e-02 -4.5455e-01\nKrathum Baen         -2.1123e-01 -2.6075e-03  3.8957e-02 -1.0570e+00\nMin Buri             -4.9826e-01 -2.4982e-03  3.7327e-02 -2.5660e+00\nBang Na              -3.8999e-01 -2.0842e-03  3.1155e-02 -2.1977e+00\nPhaya Thai            2.3471e-01 -1.9866e-03  2.9698e-02  1.3735e+00\nKamphaeng Saen        7.3445e-02 -1.9866e-03  5.0854e-02  3.3450e-01\nLat Lum Kaeo          5.2453e-02 -1.8913e-03  2.8277e-02  3.2317e-01\nPhra Samut Chedi     -1.5870e-01 -1.4915e-03  2.8267e-02 -9.3503e-01\nBang Bon             -1.0360e-01 -1.2133e-03  1.2611e-02 -9.1175e-01\nBang Len              1.4226e-01 -1.2133e-03  1.8152e-02  1.0649e+00\nNakhon Chai Si        3.1698e-02 -9.9768e-04  1.4930e-02  2.6759e-01\nBan Phaeo            -2.8097e-01 -8.6565e-04  2.2184e-02 -1.8806e+00\nBang Yai              5.0958e-02 -6.0283e-04  9.0244e-03  5.4276e-01\nBang Khen             2.0488e-02 -4.3119e-04  3.8693e-03  3.3631e-01\nMueang Pathum Thani  -1.0470e-01 -3.8742e-04  4.0301e-03 -1.6432e+00\nYan Nawa              2.4924e-02 -2.0371e-04  3.0508e-03  4.5494e-01\nChom Thong            4.0971e-02 -1.2158e-04  1.4967e-03  1.0622e+00\nChatuchak             3.5183e-02 -6.0530e-05  4.7609e-04  1.6152e+00\nSai Mai              -6.5785e-04 -4.2214e-08  8.0124e-07 -7.3488e-01\nSuan Luang           -3.8712e-05 -7.6848e-07  9.4613e-06 -1.2336e-02\nMueang Nonthaburi    -5.4655e-03 -6.2488e-06  6.5027e-05 -6.7699e-01\nKhlong Sam Wa         3.7824e-02 -1.3683e-04  1.6844e-03  9.2494e-01\nPak Kret             -2.7988e-02 -2.2332e-04  2.7488e-03 -5.2957e-01\nBang Bua Thong       -6.6869e-02 -1.5866e-03  2.3728e-02 -4.2380e-01\nMueang Nakhon Pathom -7.8933e-02 -1.9026e-03  3.6044e-02 -4.0574e-01\nMueang Samut Prakan   3.2339e-01 -2.2990e-03  3.4358e-02  1.7571e+00\nSam Phran             6.0701e-02 -3.0827e-03  3.1981e-02  3.5667e-01\nBang Khun Thian       1.8656e-01 -3.4537e-03  5.1556e-02  8.3683e-01\nBang Khae             3.3266e-01 -7.0892e-03  1.0544e-01  1.0463e+00\nThanyaburi            9.2497e-01 -1.4248e-02  2.6658e-01  1.8191e+00\nSaphan Sung           7.4410e-01 -1.4378e-02  1.4747e-01  1.9751e+00\nBang Bo               2.1695e+00 -1.8681e-02  3.4795e-01  3.7095e+00\nKhan Na Yao          -4.4722e-02 -2.3052e-02  3.3734e-01 -3.7310e-02\nTaling Chan          -1.2591e-02 -2.3382e-02  2.3763e-01  2.2136e-02\nBang Sao Thong        2.9810e+00 -2.3382e-02  5.8570e-01  3.9257e+00\nPhra Pradaeng        -5.8509e-01 -3.1998e-02  2.7807e-01 -1.0489e+00\nBang Phli             2.3769e+00 -4.0427e-02  4.7760e-01  3.4978e+00\nPrawet                1.6089e+00 -4.2186e-02  4.9747e-01  2.3410e+00\nLam Luk Ka            1.0605e-02 -5.0323e-02  5.8839e-01  7.9431e-02\nKhlong Luang         -1.6589e-01 -7.2197e-02  1.2714e+00 -8.3095e-02\nThawi Watthana        3.4609e-01 -9.7330e-02  1.0817e+00  4.2635e-01\nMueang Samut Sakhon  -4.0011e-01 -1.3165e-01  2.1698e+00 -1.8225e-01\nLat Krabang           3.2578e+00 -1.6980e-01  1.4670e+00  2.8299e+00\n                     Pr.z....E.Ii..\nPhra Nakhon                  0.0211\nDusit                        0.0802\nPom Prap Sattru Phai         0.0879\nSamphanthawong               0.0883\nBangkok Yai                  0.4049\nNong Khaem                   0.1451\nKhlong San                   0.0514\nBangkok Noi                  0.4301\nThon Buri                    0.0746\nPhasi Charoen                0.7766\nPhra Khanong                 0.4983\nDin Daeng                    0.3664\nVadhana                      0.1741\nBang Rak                     0.0886\nSathon                       0.1317\nBang Sue                     0.2160\nBang Kapi                    0.5380\nBang Kho Laem                0.1697\nBueng Kum                    0.6607\nBang Phlat                   0.3234\nNong Suea                    0.0156\nThung Khru                   0.6162\nHuai Khwang                  0.1280\nWang Thonglang               0.2709\nLak Si                       0.5715\nDon Tum                      0.7498\nRatchathewi                  0.0956\nKhlong Toei                  0.5500\nPathum Wan                   0.0304\nBang Kruai                   0.4470\nRat Burana                   0.7227\nSai Noi                      0.6190\nNong Chok                    0.0076\nPhutthamonthon               0.5976\nSam Khok                     0.2957\nLat Phrao                    0.2039\nDon Mueang                   0.6494\nKrathum Baen                 0.2905\nMin Buri                     0.0103\nBang Na                      0.0280\nPhaya Thai                   0.1696\nKamphaeng Saen               0.7380\nLat Lum Kaeo                 0.7466\nPhra Samut Chedi             0.3498\nBang Bon                     0.3619\nBang Len                     0.2869\nNakhon Chai Si               0.7890\nBan Phaeo                    0.0600\nBang Yai                     0.5873\nBang Khen                    0.7366\nMueang Pathum Thani          0.1003\nYan Nawa                     0.6492\nChom Thong                   0.2882\nChatuchak                    0.1063\nSai Mai                      0.4624\nSuan Luang                   0.9902\nMueang Nonthaburi            0.4984\nKhlong Sam Wa                0.3550\nPak Kret                     0.5964\nBang Bua Thong               0.6717\nMueang Nakhon Pathom         0.6849\nMueang Samut Prakan          0.0789\nSam Phran                    0.7213\nBang Khun Thian              0.4027\nBang Khae                    0.2954\nThanyaburi                   0.0689\nSaphan Sung                  0.0483\nBang Bo                      0.0002\nKhan Na Yao                  0.9702\nTaling Chan                  0.9823\nBang Sao Thong               0.0001\nPhra Pradaeng                0.2942\nBang Phli                    0.0005\nPrawet                       0.0192\nLam Luk Ka                   0.9367\nKhlong Luang                 0.9338\nThawi Watthana               0.6698\nMueang Samut Sakhon          0.8554\nLat Krabang                  0.0047\n\n\n\n\n1.4.4.4 Mapping the local Moran’s I\nBefore we map the local Moran’s I map, it is wise to append the local Moran’s data-frame (localMI) onto our SpatialPolygonDataFrame.\n\nbmr.localMI &lt;- cbind(boundary_with_accident_count,localMI) %&gt;%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\nWe now make use of the tmap package and its choropleth mapping functions to plot the local Moran’s I values.\n\ntm_shape(bmr.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\nInterpreting Moran Value:\n\nValues lesser than 0 indicate negative spatial autocorrelation. (i.e: high accident areas are near low accident areas.)\nValue equal to 0 indicates random spatial distribution (No spatial autocorrelation).\nValues greater than 0 indicate spatial autocorrelation.\n\n\n\n\n1.4.4.5 Mapping Local Moran’s I p-values\nThe Choropleth reveals the presence of both positive, as well as negative I values. This indicates that there are varying levels of spatial autocorrelation, however, we must examine the p-values for these I values to check for statistical significance.\nWe use the tmap package to draw a choropleth map of Moran’s I p-values.\n\ntm_shape(bmr.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\nFrom the above we can infer that generally the local moran value ranges from -1 to 1. The biggest stand outs are:\n\nNong Suea, at the top right corner of the above map, seems to be absolutely dissimilar to its neighbors as indicated by its local Moran Value being of the highest magnitude. From our earlier analysis, we infer that this region actually has significantly fewer accidents than its neighbors.\nThe South-East region of the Bangkok Metropolitan Region has very high local Moran Values, indicating that the districts all showcase similar characteristics. They exhibit spatial clustering.\n\n\n\n1.4.4.6 Mapping both local Moran’s I values and p-values\nIn the interest of easier analysis and interpretation, we plot the two maps next to each other.\n\nlocalMI.map &lt;- tm_shape(bmr.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)\n\npvalue.map &lt;- tm_shape(bmr.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#network-kernel-density-estimation-nkde",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex01.html#network-kernel-density-estimation-nkde",
    "title": "Take Home Exercise 1",
    "section": "1.4.1.5 Network Kernel Density Estimation (NKDE)",
    "text": "1.4.1.5 Network Kernel Density Estimation (NKDE)\nBy completing Kernel Density Estimation, we have identified two provinces of interest, Bangkok and Samut Prakan.\nWe will first extract our target regions using the code chunk below.\n\nsmt_prk_boundary= bmr_boundary2%&gt;%\n  filter(ADM1_EN=='Samut Prakan')\nsmt_prk_roads= bmr_roads%&gt;%\n  filter(ADM1_EN=='Samut Prakan')\n\nWe will now join the OpenStreetMap data, smt_prk_roads and bkk_roads, using st_intersection function of the sf package.\n\nsmt_pkn_roads_intersection=st_intersection(smt_prk_roads, smt_prk_boundary)\n\nWe will now filter down our accident data, bmr_accsf, down to our target regions.\n\nsmt_pkn_acc=bmr_accsf%&gt;%\n  filter(province_en=='Samut Prakan')\n\nWe can now start with Network Kernel Density Estimation.\nWe must first cut the SpatialLines object into Lixels with a specified minimal distance.\n\nsmt_pkn_roads_intersection=st_cast(smt_pkn_roads_intersection, 'LINESTRING', group_or_split= TRUE)\nsamut_prakan_lines=st_cast(smt_pkn_roads_intersection,'LINESTRING')\nlixels_smt_pkn &lt;- lixelize_lines(smt_pkn_roads_intersection, \n                         10000, \n                         mindist = 5000)\n\n\nThere is another function, lixelize_lines.mc() that provides multicore support and is typically used in spatial analysis or geospatial data processing, specifically in contexts where large datasets of lines (such as roads, paths, or boundaries) need to be broken down into smaller, equally spaced segments or “lixels” (line pixels). This process is known as “lixelization.”\nThe main purpose of the lixelize_lines.mc() function is to improve the efficiency of the lixelization process by utilizing multiple CPU cores simultaneously. This is particularly beneficial when dealing with large datasets, as processing each line sequentially can be time-consuming.\n\nWe now proceed to generate a SpatialPointsDataFrame with line centre points using the lines_center() function of spNetwork.\n\nsamples_smt_pkn &lt;- lines_center(lixels_smt_pkn) \n\nNow, we can perform NKDE. We use the nkde() function to carry it out.\n\ndensities_smt_prk &lt;- nkde(smt_pkn_roads_intersection, \n                  events = smt_pkn_acc,\n                  w = rep(1, nrow(smt_pkn_acc)),\n                  samples = samples_smt_pkn,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  method = \"simple\")\n\n\nwrite_rds(densities_smt_prk, \"data/rds/density_samut\")\n\n\ndensities_smt_prk=read_rds('data/rds/density_samut')\n\n\n\nThe kernel_name argument specifies the type of kernel function used.\nPossible kernel methods supported by spNetwork include:\n\nQuartic\nTriangle\nGaussian\nScaled Gaussian\nTricube\nCosine\nTriweight\nEpanechnikov\nUniform\n\nThe method argument indicates the method used to calculate Network Kernel Density Estimation (NKDE).\nspNetwork supports three popular methods:\n\nSimple (method = \"simple\"):\n\nIntroduced by Xie et al. (2008).\nDistances between events and sampling points are replaced by network distances.\nThe kernel formula is adapted to calculate density over a linear unit instead of an areal unit.\n\nDiscontinuous (method = \"discontinuous\"):\n\nProposed by Okabe et al. (2008).\nDivides the mass density of an event at intersections of lixels.\nResults in a discontinuous kernel function.\n\nContinuous (method = \"continuous\"):\n\nAlso proposed by Okabe et al. (2008).\nAdjusts the density before intersections to create a continuous kernel function.\nStill divides the mass of the density at intersections but with a continuous adjustment.\n\n\n\n\nWe will now visualize NKDE.\nWe must first insert the computed density values into samples and lixels objects as the density field.\n\nsamples_smt_pkn$density&lt;- densities_smt_prk\nlixels_smt_pkn$density &lt;- densities_smt_prk\n\nWe now upscale the density for both in the interest of easier understanding.\n\nsamples_smt_pkn$density &lt;- samples_smt_pkn$density*1000\nlixels_smt_pkn$density &lt;- lixels_smt_pkn$density*1000\n\nWe can now plot the map as the data is now prepared.\nWe will use the tmap package to produce a highly cartographic and interactive map.\n\ntmap_mode('plot')\ntm_shape(lixels_smt_pkn)+\n  tm_lines(col=\"density\")+\ntm_shape(smt_pkn_acc)+\n  tm_dots()\n\n\n\n\n\n\n\n\nThe interactive map above effectively reveals road segments with relatively higher density of accidents than road segments with relatively lower density of accidents with the help of shading. The roads with darker shades have a relatively higher density.\nFrom all our analysis, we take away that the south-eastern part of Bangkok Metropolitan Region was a hotspot, and this map above allows us to further understand the distribution of accidents across the region.\n\n1.4.1.5.1 Network Constrained G- and K-Function Analysis\nWe will now conduct a test for Complete Spatial Randomness by using the kfunctions() function of the spNetwork package.\nThe hypotheses are as follows:\n\nHo: The observed spatial point events (i.e distribution of accidents) are uniformly distributed over a street network in Samut Prakan.\nH1: The observed spatial point events (i.e: distribution of accidents) are not uniformly distributed over a street network in Samut Prakan.\n\n\nkfun_accidents &lt;- kfunctions(smt_pkn_roads_intersection, \n                             smt_pkn_acc,\n                             start = 0, \n                             end = 1000, \n                             step = 50, \n                             width = 50, \n                             nsim = 50, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05,\n                             agg = 1)  # Set aggregation to merge close points\n\n\nwrite_rds(kfun_accidents, \"data/rds/kfunction\")\n\n\nkfun_accidents=read_rds('data/rds/kfunction')\n\n\nBelow are the arguments of the function above:\n\nlines: A SpatialLinesDataFrame containing the sampling points. The geometries must be valid; using invalid geometries may cause the process to crash.\npoints: A SpatialPointsDataFrame representing the points on the network. These points will be snapped to the network for analysis.\nstart: A numeric value indicating the starting point for evaluating the k and g functions.\nend: A numeric value specifying the endpoint for evaluating the k and g functions.\nstep: A numeric value that determines the interval between evaluations of the k and g functions.\nwidth: The width of each “donut” or ring used in calculating the g-function.\nnsim: An integer representing the number of Monte Carlo simulations to perform. In the example above, 50 simulations were conducted; however, more simulations are often necessary for accurate inference.\nresolution: Specifies the resolution when simulating random points on the network. A higher resolution can significantly reduce calculation time. If set to NULL, random points can occur anywhere on the network. If a value is provided, the network’s edges are divided according to this resolution, and random points are selected from the vertices of the newly segmented network.\nconf_int: A numeric value indicating the confidence interval width, with the default set to 0.05.\n\n\nThe k-function will output the following:\n\nplotk, a ggplot2 object representing the values of the k-function.\nplotg, a ggplot2 object representing the values of the g-function.\nvalues, a DataFrame with the values used to build the plots.\n\nBelow, we visualize the plots generated.\n\nPlot KPlot G\n\n\n\nkfun_accidents$plotk\n\n\n\n\n\n\n\n\nBased on the plot above, we can see the the blue line are entirely above the envelope at the bottom, indicating that we do indeed have sufficient evidence to reject the null hypothesis and conclude that the distribution of accidents across Samut Prakan do exhibit spatial clustering tendencies.\n\n\n\nkfun_accidents$plotg\n\n\n\n\n\n\n\n\nBased on the plot above, we can see that the blue line is entirely above the envelope at the bottom, similar to the k plot, indicating that we do indeed have sufficient evidence to reject the null hypothesis and conclude that the distribution of accidents across Samut Prakan do exhibit Spatial Clustering tendencies."
  }
]