---
title: "Take Home Exercise 1: Geospatial Analytics for Social Good"
author: "Arjun Singh"
date: 2024-09-02
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
  warning: false
format:
  html:
    css: styles.css  
---

# 1 Introduction

According to the World Health Organisation (WHO), road traffic accidents cause approximately 1.19 million deaths annually and result in between 20 and 50 million people with being down with non-fatal injuries. Over half of all road traffic deaths occur among vulnerable road users, such as pedestrians, cyclists and motorcyclists.

Road traffic injuries are the leading cause of death for children and young adults aged 5–29 while two-thirds of road traffic fatalities occur among people of working age (18–59 years). 9 in 10 fatalities on the roads occur in low and middle-income countries, even though these countries have only around 60% of the world’s vehicles.

In addition to the human suffering caused by road traffic injuries, they also inflict a heavy economic burden on victims and their families, both through treatment costs for the injured and through loss of productivity of those killed or disabled. More broadly, road traffic injuries have a serious impact on national economies, costing countries 3% of their annual GDP.

Thailand’s roads are the deadliest in Southeast Asia and among the worst in the world, according to the World Health Organisation. About 20,000 people die in road accidents each year, or about 56 deaths a day (WHO).

Between 2014 and 2021, Thailand experienced a notable increase in accidents. Specifically, 19% of all accidents in Thailand occurred on the national highways, which constituted the primary public thoroughfares connecting various regions, provinces, districts, and significant locations within a comprehensive network.

Within the broader context of accidents across the country, there existed a considerable 66% likelihood of encountering accident-prone zones, often termed ‘**black spots**,’ distributed as follows: 66% on straight road segments, 13% at curves, 6% at median points of cross-shaped intersections, 5% at T-shaped intersections and Y-shaped intersections, 3% at cross-shaped intersections, 2% on bridges, and 2% on steep slopes, respectively.

# 1.1 Objectives

For the most part, road accidents can be attributed to two key factors- behavioral factors. such as driving skill, and environmental factors, such as heavy rain.

For this exercise, we will implement Spatial and Spatio-Temporal Point Pattern Analysis methods to discover the underlying factors behind the accidents in the Bangkok Metropolitan Region.

# 1.2 Data and Packages

For the purpose of this study, we will use the following three data-frames.

-   [Thailand Road Accidents \[2019-2022\]](https://www.kaggle.com/datasets/thaweewatboy/thailand-road-accident-2019-2022), sourced from Kaggle.

-   [Thailand Roads Open Street Map Export](https://data.humdata.org/dataset/hotosm_tha_roads), sourced from Humanitarian Data Exchange.

-   [Thailand Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) sourced from Humanitarian Data Exchange.

You can click the link embedded on each of these data-frames to learn more.

We will use the following R packages for our analysis:

-   `sf`, a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.

-   `spatstat`, which has a wide range of useful functions for point pattern analysis. In this hands-on exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.

-   `raster`, which reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.

-   `tidyverse` simplifies spatial analysis by offering a consistent and efficient framework that facilitates working with spatial data.

-   `tmap` which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API.

-   `spNetwork` which provides functions to perform Spatial Point Patterns Analysis such as kernel density estimation (KDE) and K-function on network. It also can be used to build spatial matrices (‘listw’ objects like in ‘spdep’ package) to conduct any kind of traditional spatial analysis with spatial weights based on reticular distances.

We import them into our environment using the code chunk below.

<details>

<summary>Click to show/hide code chunk</summary>

```{r}
pacman::p_load(sf, spatstat, raster, tidyverse, tmap, spNetwork, spdep)
set.seed(123)
```

</details>

# 1.3 Importing the data

## 1.3.1 Aspatial Data

We will first import the road accident data into our environment and prepare it to suit our analysis.

::: panel-tabset
## Importing the aspatial data

```{r}
rdacc_sf=read_csv("data/rawdata/thai_road_accident_2019_2022.csv")%>%
  filter(!is.na(longitude) & longitude != "",
         !is.na(latitude) & latitude !="")%>%
  st_as_sf(coords=c(
    "longitude", "latitude"), 
    crs=4326)%>%
  st_transform(crs=32647)%>%
  mutate(Month=month(incident_datetime))%>%
  mutate(Month_fac=month(incident_datetime,
                     label=TRUE, abbr=TRUE))%>%
  mutate(dayofmonth= day(incident_datetime))
```

In the interest of computational efficiency, we will save this as an rds data file.

```{r}
write_rds(rdacc_sf, "data/rds/acc_sf")
```

```{r}
rdacc_sf=read_rds("data/rds/acc_sf")%>% 
  mutate(hourofday= hour(incident_datetime))
```

## Features of the dataset

We now use the glimpse() function to have an overview of the features of the dataset.

```{r}
glimpse(rdacc_sf)
```

## Checking for duplicates

We now check for duplicates using the group_by_all() function.

```{r}
duplicate <- rdacc_sf %>% 
  group_by_all() %>% 
  filter(n()>1) %>% 
  ungroup()
  
duplicate
```

We can confirm that there are zero duplicate rows across the data-frame.
:::

## 1.3.2 Geospatial Data

We will now import the Geospatial shapefiles into our environment using the **st_read()** function of the **sf** package.

::: panel-tabset
## Thailand Roads (Open Street Map Export)

We first import the Open Street Map export of the roads.

```{r}
road_sf <- st_read(dsn = "data/rawdata", layer="hotosm_tha_roads_lines_shp")
```

We notice that the CRS information is unavailable so we proceed to set the CRS using the **st_set_crs()** function of the **sf** package.

```{r}
road_sf=st_set_crs(road_sf,32647)
```

Given our area of focus is the Bangkok metropolitan we must narrow the data down to it.

## Thailand Subnational Administrative Boundaries

We implement the st_read() function of the sf package to import the Administrative Boundaries into our environment.

```{r}
map_sf <- st_read(dsn = "data/rawdata", layer="tha_admbnda_adm1_rtsd_20220121")
```

We take a quick look at the boundaries using the **qtm()** function of the **tmap** package.

```{r}
qtm(map_sf)
```
:::

As the final step, we will confirm that all data-frames are have consistent CRS information as it is key to obtain accurate insights. The **st_crs()** function of the **sf** package will be used.

::: panel-tabset
## Aspatial Data

We will implement the **st_crs()** function of the **sf** package to check the CRS information.

```{r}
st_crs(rdacc_sf)
```

## Geospatial Data

We first check the CRS information of the boundary data in `map_sf`.

```{r}
st_crs(map_sf)
```

The EPSG code is not consistent. We now transform the data for it to be consistent with the `rdacc_sf` data-frame. The **st_transform()** function of the **sf** package is used. After that, we verify to check if the changes have been made as intended.

```{r}
map_sf=st_transform(map_sf, crs=st_crs(rdacc_sf))
st_crs(map_sf)
```

Now, we proceed to check the CRS data for `road_sf`, the OpenStreetMap export.

```{r}
st_crs(road_sf)
```

The CRS information is accurate for `road_sf`.
:::

# 1.4 Data Wrangling

## 1.4.1 Aspatial Data

Given our area of interest is the Bangkok Metropolitan Region, we further narrow down our data-frame `rdacc_sf` using the **filter()** function for our study.

::: panel-tabset
## The code

```{r}
# We first create a list of the provinces in the Metropolitan Region
bmr_province=c("Bangkok", "Samut Prakan", "Samut Sakhon", "Nonthaburi", "Nakhon Pathom", "Pathum Thani")

#Implementing the filter() function with  the help of the list above.
bmr_accsf=rdacc_sf %>% 
  filter(province_en %in% bmr_province)
```

We have now filtered the `rdacc_sf` data-frame to contain accidents in only the Bangkok Metropolitan Region.

## Overview of the data-frame

We will now have a look at the newly obtained data-frame after filtering it down to the Bangkok Metropolitan Region.

```{r}
glimpse(bmr_accsf)
```

We see that there are 12986 features with 17 variables. We can now proceed with further data wrangling to continue with our analysis.
:::

## 1.4.2 Geospatial Data

We will now filter out `map_sf` to include only the Bangkok Metropolitan Region as well.

::: panel-tabset
## The code

```{r}
bmr_boundary=map_sf %>% 
  filter(ADM1_EN %in% bmr_province)
```

## Quick Thematic Map

We will now implement the qtm() function of the tmap package to gain a better understanding of the region.

```{r}
qtm(bmr_boundary)
```

The above confirms that the filter() function has worked as expected. We can now proceed with further analysis.

We will now filter the OpenStreetMap data to only include data points that fall within this boundary by using the **st_intersects()** function of the sf package.

```{r}
if (st_crs(road_sf) != st_crs(bmr_boundary)) {
  osm_data <- st_transform(road_sf, st_crs(bmr_boundary))
}

```

```{r}
# Filter OSM data to the boundary
filtered_osm_data <- st_intersection(road_sf, bmr_boundary)

```

```{r}
# Randomly sample 100,000 rows for faster plotting
sample_data <- road_sf[sample(nrow(road_sf), 100000), ]

# Plot the downsampled data
ggplot() +
  geom_sf(data = sample_data, color = "blue", size = 0.1) +
  theme_minimal()



```

```{r}

# Perform a spatial join
joined_data <- st_join(road_sf, bmr_boundary, join = st_within)  # or st_intersects depending on your use case

# View the first few rows of the joined data
head(joined_data)

```

```{r}
# Check column names after the join
colnames(joined_data)

# Look at specific columns of interest
joined_data %>% select(name, ADM1_EN, highway, geometry) %>% head()
```
:::

## 1.4.3 Converting Simple Feature Data-Frames to Spatial class.

We must start by converting the simple feature data-frames into Spatial objects using the **as_Spatial()** function of the **sf** package. This is done to facilitate analysis.

```{r}
bmr_acc <- as_Spatial(bmr_accsf)
bmr <- as_Spatial(bmr_boundary)
```

## 1.5 Exploratory Data Analysis

To gain a better understanding of the distribution of accidents across the different provinces.

```{r}
# Step 1: Summarize the number of hospitalizations per province
accident_summary <- bmr_accsf %>%
  group_by(province_en) %>%
  summarize(total_accidents = n())

# Step 2: Visualize using ggplot2
ggplot(accident_summary, aes(x = reorder(province_en, total_accidents), y = total_accidents)) +
  geom_bar(stat = "identity", fill = "darkred") +
  coord_flip() +  # Flip coordinates for better readability if many provinces
  labs(title = "Total Accidents by Province",
       x = "Province",
       y = "Number of Accidents") +
  theme_minimal()

```

Bangkok has the most accidents of any province in the Metropolitan Region, followed by Samut Prakhan and Pathum Thani.

We want to confirm this so we plot a highly cartographic, interactive map using the **tmap** package.

::: panel-tabset
## Determining count

To identify the region with the most accidents, we will first count the number of accidents in each region using the st_join() and group_by() function as shown in the code chunk below.

```{r}
# Spatial join: count number of accidents in each boundary polygon
bmr_with_accidents <- bmr_boundary %>%
  st_join(bmr_accsf) %>%
  group_by(region_id = province_en) %>%  # Replace with the column name of the region identifier
  summarise(accident_count = n()) 
```

## Creating the map

Now that we have determined the count of accidents in each province, we will use the tmap package to produce a highly cartographic map for the same.

```{r}
# Set tmap to interactive view mode (optional for exploration)
tmap_mode("view")

# Create the map with boundaries and accident points
tm_shape(bmr_boundary) +
  tm_borders(col = "black") +  # Show the boundaries
  tm_shape(bmr_accsf) +
  tm_dots(col = "red", size = 0.01) +  # Show accident points as red dots
  tm_layout(frame = FALSE, legend.outside = TRUE)

# Switch back to static mode after rendering (if needed)
tmap_mode("plot")
```

## Choropleth Map

```{r}
tmap_mode("view")

# Create the choropleth map
tm_shape(bmr_with_accidents) +
  tm_polygons(col = "accident_count", palette = "Reds", border.col = "black", title = "Accidents") +
  tm_layout(frame = FALSE, legend.outside = TRUE)  # Adjust layout as needed

# Switch back to static plot mode
tmap_mode('plot')

```
:::

Based on the maps above, our initial findings are confirmed. Bangkok has the most accidents of any province in the metropolitan region.

## 1.5.1 Region by Region EDA

```{r}
# Set tmap to interactive view mode (optional for exploration)
tmap_mode("view")

# Create the map with boundaries and accident points
tm_shape(bmr_boundary%>%filter(ADM1_EN=='Bangkok')) +
  tm_borders(col = "black") +  # Show the boundaries
  tm_shape(bmr_accsf%>%filter(province_en=='Bangkok')) +
  tm_dots(col = "red", size = 0.01) +  # Show accident points as red dots
  tm_layout(frame = FALSE, legend.outside = TRUE)

# Switch back to static mode after rendering (if needed)
tmap_mode("plot")
```

## 1.4.4 Converting the Spatial Class into generic sp format

```{r}

bmracc_sp <- as(bmr_acc, "SpatialPoints")
boundary_sp <- as(bmr, "SpatialPolygons")
```

```{r}
bmracc_sp <- as(bmr_acc, "SpatialPoints")

# Step 2: Ensure that bmr is a SpatialPolygons object
# Convert bmr to SpatialPolygons if necessary
boundary_sp <- as(bmr, "SpatialPolygons")

# Step 3: Define the window (bounding box) from the boundary
boundary_bbox <- bbox(boundary_sp)  # Get bounding box of boundary
window <- owin(xrange = boundary_bbox[1, ], yrange = boundary_bbox[2, ])  # Define window

# Step 4: Extract the coordinates from the SpatialPoints object
coordinates <- coordinates(bmracc_sp)

# Step 5: Convert the SpatialPoints into a ppp object using the window
bmracc_ppp <- ppp(x = coordinates[,1], y = coordinates[,2], window = window)

# Step 6: Check the structure of the resulting point pattern object
summary(bmracc_ppp)

# You can now use the ppp object for spatial analysis with spatstat
```

```{r}
any(duplicated(bmracc_ppp))
```

```{r}
multiplicity(bmracc_ppp)
```

```{r}
sum(multiplicity(bmracc_ppp)>1)
```

```{r}
bmr_ppp_jit <- rjitter(bmracc_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
bmr_owin <- as.owin(bmr_boundary)
```

```{r}
plot(bmr_owin)
```

```{r}
kde_bmracc_bw <- density(bmr_ppp_jit,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_bmracc_bw)
```

```{r}
bmracc_ppp.km <- rescale.ppp(bmr_ppp_jit, 1000, "km")
```

```{r}
kde_bmracc.bw <- density(bmracc_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_bmracc.bw)
```

```{r}
kde_bmracc_adaptive <- adaptive.density(bmracc_ppp.km, method="kernel")
plot(kde_bmracc_adaptive)
```

```{r}
par(mfrow=c(1,2))
plot(kde_bmracc.bw, main = "Fixed bandwidth")
plot(kde_bmracc_adaptive, main = "Adaptive bandwidth")
```

```{r}
kde_bmracc_bw_raster <- raster(kde_bmracc.bw)
```

```{r}
projection(kde_bmracc_bw_raster) <- CRS("+init=EPSG:32647")
plot(kde_bmracc_bw_raster)
```

we can further narrow it down to analyze it by Province.

::: panel-tabset
## Bangkok

```{r}
bkk_owin <- as.owin(bmr_boundary%>%filter(ADM1_EN== "Bangkok"))
plot(bkk_owin)
```

We now proceed to carry out the same steps as above.

<Details>

<summary>Creating PPP object</summary>

```{r}
bkk_acc=bmr_accsf%>%filter(province_en=="Bangkok")
bkk=as_Spatial(bkk_acc)


# Step 3: Define the window (bounding box) from the boundary
boundary_bbox <- bbox(boundary_sp)  # Get bounding box of boundary
window <- owin(xrange = boundary_bbox[1, ], yrange = boundary_bbox[2, ])  # Define window

# Step 4: Extract the coordinates from the SpatialPoints object
coordinates <- coordinates(bkk)

# Step 5: Convert the SpatialPoints into a ppp object using the window
bkkacc_ppp <- ppp(x = coordinates[,1], y = coordinates[,2], window = window)

# Step 6: Check the structure of the resulting point pattern object
summary(bkkacc_ppp)

bkk_ppp_jit <- rjitter(bkkacc_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
bkkacc_ppp.km <- rescale.ppp(bkk_ppp_jit, 1000, "km")
```

</Details>

```{r}
kde_bkkacc.bw <- density(bkkacc_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
plot(kde_bkkacc.bw)
```

```{r}
kde_bkkacc_bw_raster <- raster(kde_bkkacc.bw)
projection(kde_bkkacc_bw_raster) <- CRS("+init=EPSG:32647")
plot(kde_bkkacc_bw_raster)
```
:::

```{r}
bmr_joined=st_join(bmr_boundary, bmr_accsf)
wm_q <- poly2nb(bmr_boundary, 
                queen=TRUE)
summary(wm_q)
```

```{r}
rswm_q <- nb2listw(wm_q, 
                   style="W", 
                   zero.policy = TRUE)
rswm_q
```
