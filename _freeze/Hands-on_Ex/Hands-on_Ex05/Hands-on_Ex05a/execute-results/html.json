{
  "hash": "7f8025009c5b17568b9da46120b54349",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands On Exercise 5- Global Measures of Spatial Autocorrelation\"\nauthor: \"Arjun Singh\"\ndate: 2024-09-09\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n  warning: false\nformat:\n  html:\n    css: styles.css  \n---\n\n\n\n# 5 Introduction\n\nWe now focus on Global Measures of Spatial Autocorrelation (GMSA) with the help of the **spdep** package. Through this exercise we:\n\n-   compute Global Spatial Autocorrelation (GSA) statistics by using appropriate functions of **spdep** package,\n\n    -   plot Moran scatterplot,\n\n    -   compute and plot spatial correlogram using appropriate function of **spdep** package.\n\n-   provide statistically correct interpretation of GSA statistics.\n\n# 5.1 Objective\n\nIn spatial policy, a key objective for local governments and urban planners is to promote balanced development across the province. In this study, our goal is to apply appropriate spatial statistical methods to assess whether development is evenly distributed geographically in Hunan Province, People's Republic of China, using GDP per capita as a development indicator.\n\nIf we find that development is not evenly distributed, our next step will be to investigate whether there are signs of spatial clustering. Should clustering be present, we will then identify the locations of these clusters. Through this exercise, we aim to uncover the spatial patterns of development in the province.\n\n# 5.2 Data and Packages\n\nFor this exercise, we have the following two datasets:\n\n-   Hunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\nThe packages used are as follows:\n\n-   **`sf`**: Provides simple features support for handling and analyzing spatial vector data in R.\n-   **`spdep`**: A package for spatial dependence and spatial regression analysis, particularly for handling spatial weights.\n-   **`tmap`**: A flexible visualization package for thematic maps, supporting both static and interactive mapping in R.\n-   **`tidyverse`**: A collection of R packages designed for data science, emphasizing data manipulation, visualization, and functional programming.\n\nWe import these packages into our environment using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse)\nset.seed(1234)\n```\n:::\n\n\n\n# 5.3 Importing the Data\n\n::: panel-tabset\n## Geospatial Data\n\nWe will use the st_read() function of the sf package to import the Hunan Shapefile into our environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex05\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\n## Aspatial Data\n\nWe will use the read_csv() function of the readr package to import the Hunan_2012 data file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n\n:::\n\n## 5.3.1 Performing relational join\n\nWe will update the attribute table of `Hunan`'s SpatialPolygonsDataFrame with the attribute fields of the `hunan2012` data-frame. We can do this by using the left_join() function of the dplyr package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\n```\n:::\n\n\n\n# 5.4 Visualizing Regional Development Indicator\n\nWe are now going to prepare a basemap and a choropleth map to visualize the distribution of GDPPC 2012 by using the qtm() function of the tmap package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05a_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n# 5.5 Global Measures of Spatial Autocorrelation\n\nWe now focus on computing Global Spatial Autocorrelation Statistics and conducting tests for Complete Spatial Randomness for Global Spatial Autocorrelation.\n\nSpatial autocorrelation is an important concept in spatial statistics because it highlights the degree to which geographic proximity influences the distribution of a variable across a region. Moran’s I and Geary’s C are commonly used to measure spatial autocorrelation.\n\n## 5.5.1 Computing Contiguity Spatial Weights\n\nBefore computing the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area, the spatial weights are used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\n\nWe now implement the **poly2nb()** function of the **spdep** package to compute contiguity weight matrices for the study area selected.\n\nUsing this function, we are able to build a 'neighbors list' based on regions with contiguous boundaries.\n\nIn this function, we will pass an argument, 'queen', that can be set as either TRUE (default) or FALSE. If the 'queen' argument is not explicitly set to FALSE, the function returns a list of first order neighbors using the Queen criteria.\n\n[You may refer to the `spdep` package documentation here](https://cran.r-project.org/web/packages/spdep/spdep.pdf) to learn more about its functions and arguments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, \n                queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n\n\n:::\n:::\n\n\n\nFrom the output above, we can infer that there are 88 area units in total in Hunan. The *most connected* area unit has 11 neighbors. There are two area units with just 1 neighbor, while 24 area units have 5 neighbors.\n\n## 5.5.2 Row-Standardized Weights Matrix\n\nWe now need to assign weights to each neighboring polygon. We use equal weights (style=“W”), where each neighboring polygon is assigned a weight of 1 divided by the number of neighbors.\n\nThis means each neighboring county’s weight is calculated as 1/(# of neighbors), and these weights are then used to sum the weighted income values.\n\nWhile this method is intuitive for summarizing neighbors’ values, it has a drawback: polygons at the edges of the study area may rely on fewer neighbors, potentially skewing the spatial autocorrelation results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q, \n                   style=\"W\", \n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n\n\n:::\n:::\n\n\n\n::: insights-box\nThe `nb2listw()` function requires an input of class `nb`, representing a neighborhood object. The function's two key arguments are `style` and `zero.policy`.\n\n-   The `style` argument defines how the weights are calculated. It can take several values:\n\n    -   `\"B\"`: Binary coding, where weights are either 0 or 1.\n\n    -   `\"W\"`: Row-standardized, where the sum of weights across all neighbors equals 1.\n\n    -   `\"C\"`: Globally standardized, where the sum of weights across all neighbors equals the total number of neighbors.\n\n    -   `\"U\"`: A variation of `\"C\"`, where weights are normalized by the number of neighbors.\n\n    -   `\"S\"`: A variance-stabilizing scheme proposed by Tiefelsdorf et al. (1999), which adjusts weights based on the number of neighbors.\n\n-   The `zero.policy` argument, when set to `TRUE`, handles regions with no neighbors by assigning them a weight vector of zero length. This results in a spatial lag value of zero for regions without neighbors, which may or may not be a suitable assumption depending on the context. For such regions, the spatially lagged value is computed as the sum of the products of a zero vector with any numerical vector `x`, effectively setting the lagged value to zero for those regions.\n:::\n\n# 5.6 **Global Measures of Spatial Autocorrelation: Moran’s I**\n\nWe now conduct Moran's I statistics testing by using the **moran.test()** function of the **spdep** package.\n\n::: note-box\nStatistical tests are conducted at a 5% significance level.\n:::\n\n## 5.6.1 Maron's I test\n\nThe hypotheses for the test are as follows:\n\n-   H0: Regions with similar GDP Per Capita are randomly distributed.\n\n-   H1: Regions with similar GDP Per Capita are not randomly distributed and exhibit spatial clustering.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC, \n           listw=rswm_q, \n           zero.policy = TRUE, \n           na.action=na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n\nFrom the output above, we can infer the following:\n\n-   The p-value (1.095e-06)\\<0.05, indicating that the observed spatial autocorrelation is statistically significant.\n\n-   Moran's I statistic: The observed value of 0.3007 indicates **positive spatial autocorrelation**, meaning that regions with similar GDP Per Capita are more likely to be located near each other.\n\nSince Moran's I Statistic is significantly greater than what we would expect in a randomly distributed region. There is significant evidence to reject H0 and conclude that there is indeed spatial clustering with regards to GDP Per Capita in Hunan.\n\n## 5.6.2 Computing Monte Carlo Moran's I\n\nWe now implement the moran.mc() function of the spdep package. In this scenario, we will run 1000 simulations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbperm= moran.mc(hunan$GDPPC, \n                listw=rswm_q, \n                nsim=999, \n                zero.policy = TRUE, \n                na.action=na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\nBased on the above output, p-value (0.001)\\<0.05, thus we can reject the null hypothesis at a 5% significance level and conclude that there is indeed spatial clustering.\n\n## 5.6.3 Visualizing Monte Carlo Moran's I\n\nWe can visualize the test statistics obtained from the simulation above by implementing the hist() and abline() functions of R graphics.\n\n::: panel-tabset\n## Summary Statistics\n\nWe first calculate the mean and variance, and obtain the summary statistics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.01504572\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.004371574\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n\n\n:::\n:::\n\n\n\n## The Plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, \n     freq=TRUE, \n     breaks=20, \n     xlab=\"Simulated Moran's I\")\nabline(v=0, \n       col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05a_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nFrom the above, we can infer that over half of all simulations indicate a negative value for Moran's I statistic. Generally, a negative value indicates that **dissimilar** regions are located next to each other. (i.e: regions with dissimilar GDP Per Capita are located next to each other)\n\n## ggplot2 method\n\nWe can also use ggplot2 package to plot the above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(simulated_moran = bperm$res)\n\nggplot(data, aes(x = simulated_moran)) +\n  geom_histogram(binwidth = (max(data$simulated_moran) - min(data$simulated_moran)) / 20, \n                 fill = \"lightblue\", color = \"black\") +\n  geom_vline(xintercept = 0, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"Simulated Moran's I\", \n       y = \"Frequency\",\n       title = \"Histogram of Simulated Moran's I\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05a_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n:::\n\n::: insights-box\nIf Morans I Statistic is = 0, there is Random Spatial Distribution.\n:::\n\n# 5.7 **Global Measures of Spatial Autocorrelation: Geary’s C**\n\nWe will implement the Geary's C test for spatial autocorrelation by using the **geary.test()** function of the **spdep** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw=rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q   \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n\n\n:::\n:::\n\n\n\nFor Geary;s C test:\n\n-   Values less than 1 indicate positive spatial autocorrelation.\n\n-   Values greater than 1 indicate negative spatial autocorrelation.\n\n-   Values that are close or equal to 1 indicates no spatial autocorrelation.\n\n## 5.7.1 Computing Monte Carlo Geary's C\n\nWe implement the the geary.mc() function of the spdep package to conduct 1000 simulations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbperm=geary.mc(hunan$GDPPC, \n               listw=rswm_q, \n               nsim=999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n\n\n:::\n:::\n\n\n\nWe can infer that there is sufficient evidence to reject the null hypothesis (as p-value (0.001)\\<0.05) and conclude that there is indeed Positive Spatial Autocorrelation (as statistic= 0.691.)\n\n## 5.7.2 Visualizing Monte Carlo Geary's C\n\n::: panel-tabset\n## Summary Statistics\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.003309\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.006955922\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7645  0.9435  1.0044  1.0033  1.0565  1.2883 \n```\n\n\n:::\n:::\n\n\n\n## The plot\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res, freq=TRUE, breaks=20, xlab=\"Simulated Geary c\")\nabline(v=1, col=\"red\") \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05a_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\nFrom the plot, we infer that out of the 1000 simulations the value of the statistic is distributed approximately normally, however generally values are close to 1 indicating a lack of spatial autocorrelation.\n:::\n\n# 5.8 Spatial Correlogram\n\nSpatial correlograms are a powerful tool for analyzing patterns of spatial autocorrelation in your data or model residuals. They illustrate how the correlation between pairs of spatial observations changes as the distance (or lag) between them increases. Essentially, they plot an index of autocorrelation, such as Moran’s I or Geary’s C, against distance.\n\nWhile correlograms are not as central to geostatistics as variograms—an essential concept in that field—they offer valuable insights as an exploratory and descriptive tool. In fact, for examining spatial autocorrelation, correlograms often provide more detailed information than variograms, making them particularly useful for initial spatial data analysis.\n\n::: panel-tabset\n## Computing Moran's I correlogram\n\nWe implement the sp.correlogram() function of the spdep package to compute a 6-lag spatial correlogram of GDP Per Capita. The global spatial autocorrelation used in Moran’s I.\n\nThe **plot()** of base Graph is then used to plot the output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05a_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nThe plot above may not allow us to provide complete interpretation. This is because not all autocorrelation values are statistically significant. Hence, it is important for us to examine the full analysis report by printing out the analysis results as in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n\nFrom the output above, we infer that a majority of the time, there is indeed spatial autocorrelation in Hunan.\n\n## Compute Geary's C Correlogram and Plot\n\nWe implement the `sp.correlogram()` of **spdep** package is used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used in Geary’s C. The **plot()** of base Graph is then used to plot the output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q, \n                          hunan$GDPPC, \n                          order=6, \n                          method=\"C\", \n                          style=\"W\")\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex05a_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\nSimilar to the previous step, we will print out the analysis report by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n:::\n",
    "supporting": [
      "Hands-on_Ex05a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}