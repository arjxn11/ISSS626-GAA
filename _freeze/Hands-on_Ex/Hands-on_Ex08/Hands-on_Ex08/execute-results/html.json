{
  "hash": "ce560a467abfe54870ee29ce322764de",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands On Exercise 8- Geographically Weighted Predictive Models\"\nauthor: \"Arjun Singh\"\ndate: 2024-10-17\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n  warning: false\nformat:\n  html:\n    css: styles.css \n---\n\n\n\n# 8 Introduction\n\nPredictive modeling leverages statistical learning or machine learning techniques to forecast outcomes, typically focusing on future events. It relies on a dataset of known outcomes and predictor variables to train and fine-tune the model.\n\nGeospatial predictive modeling is grounded in the understanding that events of interest aren't randomly or uniformly distributed across space. Instead, their occurrence is influenced by a number of geospatial factors such as infrastructure, sociocultural dynamics, and topography.\n\nBy analyzing geographically referenced data, geospatial predictive modeling seeks to capture and describe these influences and constraints, creating spatial correlations between historical event locations and relevant environmental factors.\n\n# 8.1 Data and Packages\n\n## 8.1.1 The Data\n\n-   **Aspatial dataset**:\n\n    -   HDB Resale data: a list of HDB resale transacted prices in Singapore from Jan 2017 onwards. It is in csv format which can be downloaded from Data.gov.sg.\n\n-   **Geospatial dataset**:\n\n    -   *MP14_SUBZONE_WEB_PL*: a polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data. It is in ESRI shapefile format. This data set was also downloaded from Data.gov.sg\n\n-   **Locational factors with geographic coordinates**:\n\n    -   Downloaded from **Data.gov.sg**.\n\n        -   **Eldercare** data is a list of eldercare in Singapore. It is in shapefile format.\n\n        -   **Hawker Centre** data is a list of hawker centres in Singapore. It is in geojson format.\n\n        -   **Parks** data is a list of parks in Singapore. It is in geojson format.\n\n        -   **Supermarket** data is a list of supermarkets in Singapore. It is in geojson format.\n\n        -   **CHAS clinics** data is a list of CHAS clinics in Singapore. It is in geojson format.\n\n        -   **Childcare service** data is a list of childcare services in Singapore. It is in geojson format.\n\n        -   **Kindergartens** data is a list of kindergartens in Singapore. It is in geojson format.\n\n    -   Downloaded from **Datamall.lta.gov.sg**.\n\n        -   **MRT** data is a list of MRT/LRT stations in Singapore with the station names and codes. It is in shapefile format.\n\n        -   **Bus stops** data is a list of bus stops in Singapore. It is in shapefile format.\n\n-   **Locational factors without geographic coordinates**:\n\n    -   Downloaded from **Data.gov.sg**.\n\n        -   **Primary school** data is extracted from the list on General information of schools from data.gov portal. It is in csv format.\n\n    -   Retrieved/Scraped from **other sources**\n\n        -   **CBD** coordinates obtained from Google.\n\n        -   **Shopping malls** data is a list of Shopping malls in Singapore obtained from [Wikipedia](https://en.wikipedia.org/wiki/List_of_shopping_malls_in_Singapore).\n\n        -   **Good primary schools** is a list of primary schools that are ordered in ranking in terms of popularity and this can be found at [Local Salary Forum](https://www.salary.sg/2021/best-primary-schools-2021-by-popularity).\n\n## 8.1.2 The Packages\n\nWe will use the following packages for our analysis:\n\n-   **sf**: R package for handling, analyzing, and visualizing spatial data using simple features.\n\n-   **spdep**: R package for spatial dependence modeling, including spatial autocorrelation and regression analysis.\n\n-   **GWmodel**: R package for geographically weighted regression (GWR) and other localized spatial models.\n\n-   **SpatialML**: R package for spatial machine learning, offering tools for spatially explicit predictive modeling.\n\n-   **tmap**: R package for creating thematic maps, offering a flexible and layered approach for spatial visualization.\n\n-   **rsample**: R package for resampling datasets, facilitating model training and evaluation with various sampling methods.\n\n-   **Metrics**: R package for calculating common metrics for regression and classification models, such as RMSE and accuracy.\n\n-   **tidyverse**: A collection of R packages designed for data manipulation, analysis, and visualization in a consistent and coherent syntax.\n\nWe use the p_load() function of the pacman package as shown in the code chunk below to import these packages into our environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, GWmodel, SpatialML, tmap, rsample, Metrics, tidyverse)\nset.seed(1234)\n```\n:::\n\n\n\n# 8.2 Data Preparation\n\nWe start by importing our rds file into the environment,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdata <- read_rds(\"data/mdata.rds\")\n```\n:::\n\n\n\n## 8.2.1 Data Sampling\n\nThe entire data are split into training and test data sets with 65% and 35% respectively by using the *initial_split()* function of the **rsample** package.\n\nAfter splitting the data, we will store them as RDS files. We use the write_rds() function to create the RDS file and the read_rds() function to load the RDS file into our environment. This facilitates computational efficiency.\n\n::: panel-tabset\n## Data Sampling\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nresale_split <- initial_split(mdata, \n                              prop = 6.5/10,)\ntrain_data <- training(resale_split)\ntest_data <- testing(resale_split)\n```\n:::\n\n\n\n## RDS File creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(train_data, \"data/train_data.rds\")\nwrite_rds(test_data, \"data/test_data.rds\")\n```\n:::\n\n\n\n## Reading RDS Files\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data=read_rds('data/train_data.rds')\ntest_data=read_rds('data/test_data.rds')\n```\n:::\n\n\n:::\n\n# 8.3 Correlation Matrix\n\nAfter successfully completing the above split, we proceed to compute the correlation matrix.\n\nAs stated in previous exercises, this is a key step in predictive modelling as it helps you identify if there is multicollinearity.\n\n::: insights-box\nHaving a high level of multi-collinearity can lead to unsatisfactory models.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdata_nogeo <- mdata %>%\n  st_drop_geometry()\ncorrplot::corrplot(cor(mdata_nogeo[, 2:17]), \n                   diag = FALSE, \n                   order = \"AOE\",\n                   tl.pos = \"td\", \n                   tl.cex = 0.5, \n                   method = \"number\", \n                   type = \"upper\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nFrom the above, we infer that there is no multicollinearity as there is no value above 0.8.\n\nWe can now proceed with our analysis.\n\n# 8.4 **Building a non-spatial multiple linear regression model**\n\nWe create a model using the lm() function as shown in the code chunk below.\n\n::: panel-tabset\n## Creating model\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprice_mlr <- lm(resale_price ~ floor_area_sqm +\n                  storey_order + remaining_lease_mths +\n                  PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +\n                  PROX_MRT + PROX_PARK + PROX_MALL + \n                  PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                  WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                  WITHIN_1KM_PRISCH,\n                data=train_data)\nsummary(price_mlr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = resale_price ~ floor_area_sqm + storey_order + remaining_lease_mths + \n    PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER + PROX_MRT + PROX_PARK + \n    PROX_MALL + PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN + \n    WITHIN_350M_CHILDCARE + WITHIN_350M_BUS + WITHIN_1KM_PRISCH, \n    data = train_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-205193  -39120   -1930   36545  472355 \n\nCoefficients:\n                           Estimate Std. Error t value Pr(>|t|)    \n(Intercept)              107601.073  10601.261  10.150  < 2e-16 ***\nfloor_area_sqm             2780.698     90.579  30.699  < 2e-16 ***\nstorey_order              14299.298    339.115  42.167  < 2e-16 ***\nremaining_lease_mths        344.490      4.592  75.027  < 2e-16 ***\nPROX_CBD                 -16930.196    201.254 -84.124  < 2e-16 ***\nPROX_ELDERLYCARE         -14441.025    994.867 -14.516  < 2e-16 ***\nPROX_HAWKER              -19265.648   1273.597 -15.127  < 2e-16 ***\nPROX_MRT                 -32564.272   1744.232 -18.670  < 2e-16 ***\nPROX_PARK                 -5712.625   1483.885  -3.850 0.000119 ***\nPROX_MALL                -14717.388   2007.818  -7.330 2.47e-13 ***\nPROX_SUPERMARKET         -26881.938   4189.624  -6.416 1.46e-10 ***\nWITHIN_350M_KINDERGARTEN   8520.472    632.812  13.464  < 2e-16 ***\nWITHIN_350M_CHILDCARE     -4510.650    354.015 -12.741  < 2e-16 ***\nWITHIN_350M_BUS             813.493    222.574   3.655 0.000259 ***\nWITHIN_1KM_PRISCH         -8010.834    491.512 -16.298  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 61650 on 10320 degrees of freedom\nMultiple R-squared:  0.7373,\tAdjusted R-squared:  0.737 \nF-statistic:  2069 on 14 and 10320 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\n\n## RDS File creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(price_mlr, \"data/price_mlr.rds\" ) \n```\n:::\n\n\n\n## Reading RDS File\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprice_mlr=read_rds('data/price_mlr.rds')\n```\n:::\n\n\n:::\n\n# 8.5 gwr predictive method\n\nIn this section, we calibrate a model to predict HDB resale price by using the geographically weighted regression method of the [**GWmodel**](https://cran.r-project.org/web/packages/GWmodel/index.html) package.\n\n## 8.5.1 **Converting the sf data.frame to SpatialPointDataFrame**\n\nWe implement the as_Spatial() function of the sf package to conduct the conversion as shown in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data_sp <- as_Spatial(train_data)\ntrain_data_sp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatialPointsDataFrame \nfeatures    : 10335 \nextent      : 11597.31, 42623.63, 28217.39, 48741.06  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs \nvariables   : 17\nnames       : resale_price, floor_area_sqm, storey_order, remaining_lease_mths,          PROX_CBD,     PROX_ELDERLYCARE,        PROX_HAWKER,           PROX_MRT,          PROX_PARK,   PROX_GOOD_PRISCH,        PROX_MALL,            PROX_CHAS,     PROX_SUPERMARKET, WITHIN_350M_KINDERGARTEN, WITHIN_350M_CHILDCARE, ... \nmin values  :       218000,             74,            1,                  555, 0.999393538715878, 1.98943787433087e-08, 0.0333358643817954, 0.0220407324774434, 0.0441643212802781, 0.0652540365486641,                0, 6.20621206270077e-09, 1.21715176356525e-07,                        0,                     0, ... \nmax values  :      1186888,            133,           17,                 1164,  19.6500691667807,     3.30163731686804,   2.86763031236184,   2.13060636038504,   2.41313695915468,   10.6223726149914, 2.27100643784442,    0.808332738794272,     1.57131703651196,                        7,                    20, ... \n```\n\n\n:::\n:::\n\n\n\n## 8.5.2 **Computing adaptive bandwidth**\n\nWe now use the bw.gwr() function of the **GWmodel** package to determine the optimal bandwidth to be used.\n\n::: note-box\nThe code chunk below helps us determine adaptive bandwidth and the Cross Validation (CV) method is used to determine the optimal bandwidth.\n:::\n\n::: panel-tabset\n## Calculation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_adaptive <- bw.gwr(resale_price ~ floor_area_sqm +\n                  storey_order + remaining_lease_mths +\n                  PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +\n                  PROX_MRT + PROX_PARK + PROX_MALL + \n                  PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                  WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                  WITHIN_1KM_PRISCH,\n                  data=train_data_sp,\n                  approach=\"CV\",\n                  kernel=\"gaussian\",\n                  adaptive=TRUE,\n                  longlat=FALSE)\n```\n:::\n\n\n\n## RDS File creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(bw_adaptive, \"data/bw_adaptive.rds\")\n```\n:::\n\n\n\n## Read RDS File\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_adaptive <- read_rds(\"data/bw_adaptive.rds\")\n```\n:::\n\n\n:::\n\n## 8.5.3 Converting the test data from sf data.frame to SpatialPointDataFrame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data_sp <- test_data %>%\n  as_Spatial()\ntest_data_sp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatialPointsDataFrame \nfeatures    : 5566 \nextent      : 11597.31, 42623.63, 28287.8, 48669.59  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs \nvariables   : 17\nnames       : resale_price, floor_area_sqm, storey_order, remaining_lease_mths,         PROX_CBD,     PROX_ELDERLYCARE,        PROX_HAWKER,           PROX_MRT,          PROX_PARK,   PROX_GOOD_PRISCH,        PROX_MALL,            PROX_CHAS,     PROX_SUPERMARKET, WITHIN_350M_KINDERGARTEN, WITHIN_350M_CHILDCARE, ... \nmin values  :       230888,             74,            1,                  546, 1.00583660772922, 3.34897933104965e-07, 0.0474019664161957, 0.0414043955932523, 0.0502664084494264, 0.0907500295577619,                0, 4.55547870890763e-09, 1.21715176356525e-07,                        0,                     0, ... \nmax values  :      1050000,            138,           14,                 1151,  19.632402730488,     3.30163731686804,   2.83106651960209,   2.13060636038504,   2.41313695915468,   10.6169590126272, 2.26056404492346,     0.79249074802552,     1.53786629004208,                        7,                    16, ... \n```\n\n\n:::\n:::\n\n\n\n## 8.5.4 Constructing the adaptive bandwidth gwr model\n\nWe can now calibrate the gwr-based hedonic pricing model by using adaptive bandwidth and Gaussian kernel as shown in the code chunk below.\n\n::: panel-tabset\n## Computation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_adaptive <- gwr.basic(formula = resale_price ~\n                            floor_area_sqm + storey_order +\n                            remaining_lease_mths + PROX_CBD + \n                            PROX_ELDERLYCARE + PROX_HAWKER +\n                            PROX_MRT + PROX_PARK + PROX_MALL + \n                            PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                            WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                            WITHIN_1KM_PRISCH,\n                          data=train_data_sp,\n                          bw=bw_adaptive, \n                          kernel = 'gaussian', \n                          adaptive=TRUE,\n                          longlat = FALSE)\n```\n:::\n\n\n\n## RDS File creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwr_adaptive, 'data/gwr_adaptive.rds')\n```\n:::\n\n\n\n## Reading RDS File\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_adaptive=read_rds('data/gwr_adaptive.rds')\n```\n:::\n\n\n:::\n\n## 8.5.5 Computing adaptive bandwidth for the test data\n\n::: panel-tabset\n## Computation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_bw_test_adaptive <- bw.gwr(resale_price ~ floor_area_sqm +\n                  storey_order + remaining_lease_mths +\n                  PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +\n                  PROX_MRT + PROX_PARK + PROX_MALL + \n                  PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                  WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                  WITHIN_1KM_PRISCH,\n                  data=test_data_sp,\n                  approach=\"CV\",\n                  kernel=\"gaussian\",\n                  adaptive=TRUE,\n                  longlat=FALSE)\n```\n:::\n\n\n\n## RDS File Creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwr_bw_test_adaptive, 'data/gwr_bw_test_adaptive.rds')\n```\n:::\n\n\n\n## Read RDS File\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_bw_test_adaptive=read_rds('data/gwr_bw_test_adaptive.rds')\n```\n:::\n\n\n:::\n\n## 8.5.6 Computing predicted values of the test data\n\nThe gwr.predict() function is applied as shown in the code chunk below.\n\n::: panel-tabsrt\n## Computation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_pred <- gwr.predict(formula = resale_price ~\n                          floor_area_sqm + storey_order +\n                          remaining_lease_mths + PROX_CBD + \n                          PROX_ELDERLYCARE + PROX_HAWKER + \n                          PROX_MRT + PROX_PARK + PROX_MALL + \n                          PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                          WITHIN_350M_CHILDCARE + WITHIN_350M_BUS + \n                          WITHIN_1KM_PRISCH, \n                        data=train_data_sp, \n                        predictdata = test_data_sp, \n                        bw=40, \n                        kernel = 'gaussian', \n                        adaptive=TRUE, \n                        longlat = FALSE,\n                        theta = 0)\n```\n:::\n\n\n\n## RDS File creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwr_pred, 'data/gwr_pred.rds')\n```\n:::\n\n\n\n## Reading RDS file\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwr_pred=read_rds('data/gwr_pred.rds')\n```\n:::\n\n\n:::\n\n# 8.6 Preparing coordinates data\n\n## 8.6.1 Extracting Coordinate Data\n\nWe extract the coordinates for each of the following three data-frames: mdata, train_data, test_data.\n\nThe st_coordinates() function is used.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(mdata)\ncoords_train <- st_coordinates(train_data)\ncoords_test <- st_coordinates(test_data)\n```\n:::\n\n\n\n## 8.6.2 Dropping the Geometry Field\n\nWe now drop the geometry field from the train_data data-frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data <- train_data %>% \n  st_drop_geometry()\n```\n:::\n\n\n\n# 8.7 Calibrating Random Forest Models\n\nWe will use the [ranger](https://cran.r-project.org/web/packages/ranger/index.html) package to do this. Please click the link to learn more about the ranger package, which is primarily used to conduct random forest analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf <- ranger(resale_price ~ floor_area_sqm + storey_order + \n               remaining_lease_mths + PROX_CBD + PROX_ELDERLYCARE + \n               PROX_HAWKER + PROX_MRT + PROX_PARK + PROX_MALL + \n               PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n               WITHIN_350M_CHILDCARE + WITHIN_350M_BUS + \n               WITHIN_1KM_PRISCH,\n             data=train_data)\nrf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRanger result\n\nCall:\n ranger(resale_price ~ floor_area_sqm + storey_order + remaining_lease_mths +      PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER + PROX_MRT + PROX_PARK +      PROX_MALL + PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +      WITHIN_350M_CHILDCARE + WITHIN_350M_BUS + WITHIN_1KM_PRISCH,      data = train_data) \n\nType:                             Regression \nNumber of trees:                  500 \nSample size:                      10335 \nNumber of independent variables:  14 \nMtry:                             3 \nTarget node size:                 5 \nVariable importance mode:         none \nSplitrule:                        variance \nOOB prediction error (MSE):       728602496 \nR squared (OOB):                  0.9495728 \n```\n\n\n:::\n:::\n\n\n\n# 8.8 Calibrating Geographical Random Forest Models\n\nWe now use the [SpatialML](https://cran.r-project.org/web/packages/SpatialML/index.html)package to create a model that will allow us to calibrate a model to predict HDB resale price. Please follow the embedded link to learn more about the SpatialML package.\n\n## 8.8.1 Calibrating using training data\n\nThe code chunk below is used to calibrate a geographic ranform forest model by using the `grf()` function of the **SpatialML** package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwRF_adaptive <- grf(formula = resale_price ~ floor_area_sqm + storey_order +\n                       remaining_lease_mths + PROX_CBD + PROX_ELDERLYCARE +\n                       PROX_HAWKER + PROX_MRT + PROX_PARK + PROX_MALL +\n                       PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +\n                       WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +\n                       WITHIN_1KM_PRISCH,\n                     dframe=train_data, \n                     bw=55,\n                     kernel=\"adaptive\",\n                     coords=coords_train)\nwrite_rds(gwRF_adaptive, \"data/gwRF_adaptive.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngwRF_adaptive=read_rds('data/gwRF_adaptive.rds')\n```\n:::\n\n\n\n## 8.8.2 Predicting by using test data\n\n### 8.8.2.1 Preparing the test data\n\nThe code chunk below will be used to combine the test data with its corresponding coordinates data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data <- cbind(test_data, coords_test) %>%\n  st_drop_geometry()\n```\n:::\n\n\n\n### 8.8.2.2 Predicting with test data\n\nWe now implement the `predict.grf()` function of the spatialML package to predict the resale value by using the test data and gwRF_adaptive model calibrated earlier.\n\n::: panel-tabset\n## Calibration\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwRF_pred <- predict.grf(gwRF_adaptive, \n                           test_data, \n                           x.var.name=\"X\",\n                           y.var.name=\"Y\", \n                           local.w=1,\n                           global.w=0)\n```\n:::\n\n\n\n## RDS File Creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(gwRF_pred, \"data/GRF_pred.rds\")\n```\n:::\n\n\n\n## Reading RDS File\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGRF_pred <- read_rds(\"data/GRF_pred.rds\")\n```\n:::\n\n\n:::\n\n### 8.8.2.3 Converting the output into a data-frame\n\nWe implement the as.data.frame() function as shown in the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGRF_pred_df <- as.data.frame(GRF_pred)\n```\n:::\n\n\n\nIn the code chunk below, we use the `cbind()` function to append the predicted values onto the test_data data-frame.\n\n::: panel-tabset\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| eval: false\n\ntest_data_p <- cbind(test_data, GRF_pred_df)\n```\n:::\n\n\n\n## RDS File Creation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| eval: false\n\nwrite_rds(test_data_p, \"data/test_data_p.rds\")\n```\n:::\n\n\n\n## Reading RDS File\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data_p=read_rds('data/test_data_p.rds')\n```\n:::\n\n\n:::\n\n## 8.8.3 Root Mean Square Error (RMSE)\n\nThe root mean square error (RMSE) allows us to measure how far the predicted values are from the observed values in a regression analysis.\n\nIn the code chunk below, the rmse() function of the Metrics package is used to compute the RMSE.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmse(test_data_p$resale_price,\n     test_data_p$GRF_pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 27302.16\n```\n\n\n:::\n:::\n\n\n\n## 8.8.4 Visualizing the predicted values\n\nAlternatively, we can use a scatterplot to visualise the actual resale price and the predicted resale price by using the code chunk below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = test_data_p,\n       aes(x = GRF_pred,\n           y = resale_price)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n\n::: insights-box\nA better predictive model would have the scattered points close to the diagonal line. The scatter plot can be also used to detect if any outliers in the model.\n:::\n",
    "supporting": [
      "Hands-on_Ex08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}