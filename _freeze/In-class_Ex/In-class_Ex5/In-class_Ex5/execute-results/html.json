{
  "hash": "960ec05646fb9a68b73be477493a4a6d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In Class Exercise 5\"\nauthor: \"Arjun Singh\"\ndate: 2024-09-23\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  message: false\n  freeze: true\n  warning: false\nformat:\n  html:\n    css: styles.css  \n---\n\n\n\n# 5 Introduction\n\nThis exercise will help reinforce our learning from Hands on exercise 5. Additionally, we explore the sfdep package and its uses.\n\n# 5.1 Objective\n\nIn spatial policy, a key objective for local governments and urban planners is to promote balanced development across the province. In this study, our goal is to apply appropriate spatial statistical methods to assess whether development is evenly distributed geographically in Hunan Province, People's Republic of China, using GDP per capita as a development indicator.\n\nIf we find that development is not evenly distributed, our next step will be to investigate whether there are signs of spatial clustering. Should clustering be present, we will then identify the locations of these clusters. Through this exercise, we aim to uncover the spatial patterns of development in the province.\n\n# 5.2 Data and Packages\n\nFor this exercise, we have the following two datasets:\n\n-   Hunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\n\n-   Hunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\nThe packages used are as follows:\n\n-   **`sf`**: Provides simple features support for handling and analyzing spatial vector data in R.\n-   **`spdep`**: A package for spatial dependence and spatial regression analysis, particularly for handling spatial weights.\n-   **`tmap`**: A flexible visualization package for thematic maps, supporting both static and interactive mapping in R.\n-   **`tidyverse`**: A collection of R packages designed for data science, emphasizing data manipulation, visualization, and functional programming.\n-   `sfdep` is designed for spatial analysis, providing tools to work with spatial dependencies and spatial econometrics, particularly in conjunction with simple features (sf) objects. It helps analyze relationships and interactions between spatially distributed data.\n\nWe import these packages into our environment using the following code chunk.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, sfdep)\nset.seed(1234)\n```\n:::\n\n\n\n# 5.3 Importing the Data\n\n::: panel-tabset\n## Geospatial Data\n\nWe will use the st_read() function of the sf package to import the Hunan Shapefile into our environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `Hunan' from data source \n  `C:\\arjxn11\\ISSS626-GAA\\In-class_Ex\\In-class_Ex5\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\n\n## Aspatial Data\n\nWe will use the read_csv() function of the readr package to import the Hunan_2012 data file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n\n:::\n\n## 5.3.1 Performing relational join\n\nWe will update the attribute table of `Hunan`'s SpatialPolygonsDataFrame with the attribute fields of the `hunan2012` data-frame. We can do this by using the left_join() function of the dplyr package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_GDPPC <- left_join(hunan,hunan2012) %>%\n  select(1:4, 7, 15)\n```\n:::\n\n\n\n### 5.3.1.2 Plotting a Choropleth map\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(hunan_GDPPC)+\n  tm_fill('GDPPC', style='quantile', palette = 'Blues', title= 'GDPPC')\n```\n\n::: {.cell-output-display}\n![](In-class_Ex5_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n# 5.4 Global and Local Measures of Spatial Autocorrelation: sfdep methods\n\n## 5.4.1 Deriving Queens Contiguity Weights: sfdep methods\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q=hunan_GDPPC%>%\n  mutate(nb=st_contiguity(geometry),\n         wt=st_weights(nb,\n                       style='W'),\n         .before=1)\n```\n:::\n\n\n\n-   nb: A neighbor list object as created by st_neighbor.\n\n-   style: Default 'W' for row standardized weights. This value can also be 'B', 'C', 'U', 'minimax', and 'S'\n\n-   allow_zero: if TRUE, assigns zero as a lagged value to zone without neighbors.\n\n## 5.4.2 Computing Global Moran's I\n\nWe use the global_moran() function to compute this.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI= global_moran(wm_q$GDPPC,\n                     wm_q$nb,\n                     wm_q$wt)\n```\n:::\n\n\n\nThe below code chunk, using global_moran_test() helps us conduct the test easier.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n\n\n:::\n:::\n\n\n\nSince p-value is less than 0.05, we infer that there is indeed a sign of positive autocorrelation.\n\n## 5.4.3 Global Moran's Permutation Test\n\nIn practice, we generally use Monte Carlo simulation to conduct tests. This is where the global_moran_perm() function comes into play. The `nsim` argument is key.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n\n\n:::\n:::\n\n\n\n## 5.4.4 Computing Local Moran's I\n\nIn this section, we use the local_moran() function of the sfdep package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa=wm_q%>%\n  mutate(local_moran=local_moran(\n    GDPPC, nb, wt, nsim=99),\n    .before=1)%>%\n  unnest(local_moran)\n```\n:::\n\n\n\nunnest() helps us combine the data into the intended data-frame.\n\n## 5.4.5 Visualizing p-value of local Moran's I\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(lisa)+\n  tm_fill('p_ii_sim')+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title = 'p-value of Local Morans I',\n            main.title.size = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex5_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n### 5.4.5.1 Visualizing Local Moran's I\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(lisa)+\n  tm_fill('ii')+\n  tm_borders(alpha=0.5)+\n  tm_view(set.zoom.limits = c(6,8))+\n  tm_layout(main.title='Local Morans I of GDPPC',\n            main.title.size = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex5_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n### 5.4.5.2 Visualizing both\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap1= tm_shape(lisa)+\n  tm_fill('p_ii_sim')+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title = 'p-value of Local Morans I',\n            main.title.size = 2)\n\nmap2= tm_shape(lisa)+\n  tm_fill('ii')+\n  tm_borders(alpha=0.5)+\n  tm_view(set.zoom.limits = c(6,8))+\n  tm_layout(main.title='Local Morans I of GDPPC',\n            main.title.size = 2)\n\ntmap_arrange(map1,map2, ncol=2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex5_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n## 5.4.6 Visualizing LISA map\n\nLISA map is a categorical map showing outliers and clusters. There are two types of outliers- high-low and low-high outliers. Likewise, there are two types of clusters namely High-High and Low-Low.\n\nIn fact, LISA map is an interpreted map by combining local Moran's I of geographical areas and their respective p values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig=lisa%>%\n  filter(p_ii<0.05)\ntmap_mode('plot')\ntm_shape(lisa)+\n  tm_polygons()+\n  tm_borders(alpha=0.5)+\n  tm_shape(lisa_sig)+\n  tm_fill('mean')+\n  tm_borders(alpha=0.4)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex5_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nWe see two outliers in the cluster on the North-East region of Hunan which contains mostly high-high regions. rm -f .git/index.lock\n\n# 5.5 Computing Local Gi statistics\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw=hunan_GDPPC%>%\n  mutate(nb=st_contiguity(geometry),\n         wts=st_inverse_distance(nb, geometry, scale=1, alpha=1),\n         .before=1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA=wm_idw%>%\n  mutate(local_Gi=local_gstar_perm(\n    GDPPC, nb, wt, nsim=99),\n    .before=1)%>%\n  unnest(local_Gi)\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n   gi_star cluster   e_gi     var_gi std_dev p_value p_sim p_folded_sim skewness\n     <dbl> <fct>    <dbl>      <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.0416 Low     0.0114 0.00000641  0.0493 9.61e-1  0.7          0.35    0.875\n 2 -0.333  Low     0.0106 0.00000384 -0.0941 9.25e-1  1            0.5     0.661\n 3  0.281  High    0.0126 0.00000751 -0.151  8.80e-1  0.9          0.45    0.640\n 4  0.411  High    0.0118 0.00000922  0.264  7.92e-1  0.6          0.3     0.853\n 5  0.387  High    0.0115 0.00000956  0.339  7.34e-1  0.62         0.31    1.07 \n 6 -0.368  High    0.0118 0.00000591 -0.583  5.60e-1  0.72         0.36    0.594\n 7  3.56   High    0.0151 0.00000731  2.61   9.01e-3  0.06         0.03    1.09 \n 8  2.52   High    0.0136 0.00000614  1.49   1.35e-1  0.2          0.1     1.12 \n 9  4.56   High    0.0144 0.00000584  3.53   4.17e-4  0.04         0.02    1.23 \n10  1.16   Low     0.0104 0.00000370  1.82   6.86e-2  0.12         0.06    0.416\n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(HCSA)+\n  tm_fill('p_sim')+\n  tm_borders(alpha=0.5)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex5_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nWe can now visualize the hot and cold spots.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA_sig=HCSA%>%\n  filter(p_sim<0.05)\ntm_shape(HCSA)+\n  tm_polygons()+\n  tm_borders(alpha = 0.5)+\n  tm_shape(HCSA_sig)+\n  tm_fill('cluster')\n```\n\n::: {.cell-output-display}\n![](In-class_Ex5_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "In-class_Ex5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}